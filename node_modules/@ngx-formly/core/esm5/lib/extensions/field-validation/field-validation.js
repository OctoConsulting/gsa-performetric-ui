/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Validators } from '@angular/forms';
import { isObject, FORMLY_VALIDATORS, defineHiddenProp, isPromise, wrapProperty } from '../../utils';
import { updateValidity } from '../field-form/utils';
/**
 * \@experimental
 */
var /**
 * \@experimental
 */
FieldValidationExtension = /** @class */ (function () {
    function FieldValidationExtension(formlyConfig) {
        this.formlyConfig = formlyConfig;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    FieldValidationExtension.prototype.onPopulate = /**
     * @param {?} field
     * @return {?}
     */
    function (field) {
        if (!field.parent || !field.key) {
            return;
        }
        this.initFieldValidation(field, 'validators');
        this.initFieldValidation(field, 'asyncValidators');
    };
    /**
     * @private
     * @param {?} field
     * @param {?} type
     * @return {?}
     */
    FieldValidationExtension.prototype.initFieldValidation = /**
     * @private
     * @param {?} field
     * @param {?} type
     * @return {?}
     */
    function (field, type) {
        var _this = this;
        /** @type {?} */
        var validators = type === 'validators' ? [this.getPredefinedFieldValidation(field)] : [];
        if (field[type]) {
            for (var validatorName in field[type]) {
                if (validatorName === 'validation' && !Array.isArray(field[type].validation)) {
                    field[type].validation = [field[type].validation];
                    console.warn("NgxFormly(" + field.key + "): passing a non array value to the 'validation' is deprecated, pass an array instead");
                }
                validatorName === 'validation'
                    ? validators.push.apply(validators, tslib_1.__spread(field[type].validation.map((/**
                     * @param {?} v
                     * @return {?}
                     */
                    function (v) { return _this.wrapNgValidatorFn(field, v); })))) : validators.push(this.wrapNgValidatorFn(field, field[type][validatorName], validatorName));
            }
        }
        defineHiddenProp(field, '_' + type, type === 'validators' ? Validators.compose(validators) : Validators.composeAsync((/** @type {?} */ (validators))));
    };
    /**
     * @private
     * @param {?} field
     * @return {?}
     */
    FieldValidationExtension.prototype.getPredefinedFieldValidation = /**
     * @private
     * @param {?} field
     * @return {?}
     */
    function (field) {
        /** @type {?} */
        var VALIDATORS = [];
        FORMLY_VALIDATORS.forEach((/**
         * @param {?} opt
         * @return {?}
         */
        function (opt) { return wrapProperty(field.templateOptions, opt, (/**
         * @param {?} __0
         * @return {?}
         */
        function (_a) {
            var currentValue = _a.currentValue, firstChange = _a.firstChange;
            VALIDATORS = VALIDATORS.filter((/**
             * @param {?} o
             * @return {?}
             */
            function (o) { return o !== opt; }));
            if (currentValue != null && currentValue !== false) {
                VALIDATORS.push(opt);
            }
            if (!firstChange && field.formControl) {
                updateValidity(field.formControl);
            }
        })); }));
        return (/**
         * @param {?} control
         * @return {?}
         */
        function (control) {
            if (VALIDATORS.length === 0) {
                return null;
            }
            return Validators.compose(VALIDATORS.map((/**
             * @param {?} opt
             * @return {?}
             */
            function (opt) { return (/**
             * @return {?}
             */
            function () {
                /** @type {?} */
                var value = field.templateOptions[opt];
                switch (opt) {
                    case 'required':
                        return Validators.required(control);
                    case 'pattern':
                        return Validators.pattern(value)(control);
                    case 'minLength':
                        return Validators.minLength(value)(control);
                    case 'maxLength':
                        return Validators.maxLength(value)(control);
                    case 'min':
                        return Validators.min(value)(control);
                    case 'max':
                        return Validators.max(value)(control);
                }
            }); })))(control);
        });
    };
    /**
     * @private
     * @param {?} field
     * @param {?} validator
     * @param {?=} validatorName
     * @return {?}
     */
    FieldValidationExtension.prototype.wrapNgValidatorFn = /**
     * @private
     * @param {?} field
     * @param {?} validator
     * @param {?=} validatorName
     * @return {?}
     */
    function (field, validator, validatorName) {
        var _this = this;
        return (/**
         * @param {?} control
         * @return {?}
         */
        function (control) {
            /** @type {?} */
            var validatorFn = (/** @type {?} */ (validator));
            if (typeof validator === 'string') {
                validatorFn = _this.formlyConfig.getValidator(validator).validation;
            }
            if (isObject(validator)) {
                validatorFn = ((/** @type {?} */ (validator))).expression;
            }
            /** @type {?} */
            var isValid = validatorFn(control, field);
            if (validatorName) {
                if (isPromise(isValid)) {
                    return isValid.then((/**
                     * @param {?} result
                     * @return {?}
                     */
                    function (result) {
                        // workaround for https://github.com/angular/angular/issues/13200
                        if (field.options && field.options._markForCheck) {
                            field.options._markForCheck(field);
                        }
                        return _this.handleResult(field, result, { validatorName: validatorName, validator: validator });
                    }));
                }
                return _this.handleResult(field, isValid, { validatorName: validatorName, validator: validator });
            }
            return isValid;
        });
    };
    /**
     * @private
     * @param {?} field
     * @param {?} isValid
     * @param {?} __2
     * @return {?}
     */
    FieldValidationExtension.prototype.handleResult = /**
     * @private
     * @param {?} field
     * @param {?} isValid
     * @param {?} __2
     * @return {?}
     */
    function (field, isValid, _a) {
        var validatorName = _a.validatorName, validator = _a.validator;
        var _b, _c, _d;
        if (isObject(validator) && field.formControl && validator.errorPath) {
            /** @type {?} */
            var control = field.formControl.get(validator.errorPath);
            if (control) {
                /** @type {?} */
                var controlErrors = (control.errors || {});
                if (!isValid) {
                    control.setErrors(tslib_1.__assign({}, controlErrors, (_b = {}, _b[validatorName] = { message: validator.message }, _b)));
                }
                else {
                    delete controlErrors[validatorName];
                    control.setErrors(Object.keys(controlErrors).length === 0 ? null : controlErrors);
                }
            }
            return isValid ? null : (_c = {}, _c[validatorName] = { errorPath: validator.errorPath }, _c);
        }
        return isValid ? null : (_d = {}, _d[validatorName] = true, _d);
    };
    return FieldValidationExtension;
}());
/**
 * \@experimental
 */
export { FieldValidationExtension };
if (false) {
    /**
     * @type {?}
     * @private
     */
    FieldValidationExtension.prototype.formlyConfig;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmllbGQtdmFsaWRhdGlvbi5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BuZ3gtZm9ybWx5L2NvcmUvIiwic291cmNlcyI6WyJsaWIvZXh0ZW5zaW9ucy9maWVsZC12YWxpZGF0aW9uL2ZpZWxkLXZhbGlkYXRpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFFQSxPQUFPLEVBQW1CLFVBQVUsRUFBZSxNQUFNLGdCQUFnQixDQUFDO0FBQzFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsaUJBQWlCLEVBQUUsZ0JBQWdCLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUNyRyxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0scUJBQXFCLENBQUM7Ozs7QUFHckQ7Ozs7SUFDRSxrQ0FBb0IsWUFBMEI7UUFBMUIsaUJBQVksR0FBWixZQUFZLENBQWM7SUFBRyxDQUFDOzs7OztJQUVsRCw2Q0FBVTs7OztJQUFWLFVBQVcsS0FBNkI7UUFDdEMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFO1lBQy9CLE9BQU87U0FDUjtRQUVELElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxLQUFLLEVBQUUsWUFBWSxDQUFDLENBQUM7UUFDOUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLEtBQUssRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO0lBQ3JELENBQUM7Ozs7Ozs7SUFFTyxzREFBbUI7Ozs7OztJQUEzQixVQUE0QixLQUE2QixFQUFFLElBQXNDO1FBQWpHLGlCQXFCQzs7WUFwQk8sVUFBVSxHQUFrQixJQUFJLEtBQUssWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyw0QkFBNEIsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO1FBQ3pHLElBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ2YsS0FBSyxJQUFNLGFBQWEsSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLEVB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QyxJQUFJLENBQUMsQ0FBQyxXQUFHLEdBQUMsYUFBYSxJQUFHLEVBQUUsU0FBUyxFQUFFLFNBQVMsQ0FBQyxTQUFTLEVBQUUsS0FBRSxDQUFDO1NBQ2pGO1FBRUQsT0FBTyxPQUFPLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLFdBQUcsR0FBQyxhQUFhLElBQUcsSUFBSSxLQUFFLENBQUM7SUFDcEQsQ0FBQztJQUNILCtCQUFDO0FBQUQsQ0FBQyxBQXhIRCxJQXdIQzs7Ozs7Ozs7OztJQXZIYSxnREFBa0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBGb3JtbHlFeHRlbnNpb24sIEZpZWxkVmFsaWRhdG9yRm4sIEZvcm1seUNvbmZpZyB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2Zvcm1seS5jb25maWcnO1xuaW1wb3J0IHsgRm9ybWx5RmllbGRDb25maWdDYWNoZSB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvZm9ybWx5LmZpZWxkLmNvbmZpZyc7XG5pbXBvcnQgeyBBYnN0cmFjdENvbnRyb2wsIFZhbGlkYXRvcnMsIFZhbGlkYXRvckZuIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgaXNPYmplY3QsIEZPUk1MWV9WQUxJREFUT1JTLCBkZWZpbmVIaWRkZW5Qcm9wLCBpc1Byb21pc2UsIHdyYXBQcm9wZXJ0eSB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCB7IHVwZGF0ZVZhbGlkaXR5IH0gZnJvbSAnLi4vZmllbGQtZm9ybS91dGlscyc7XG5cbi8qKiBAZXhwZXJpbWVudGFsICovXG5leHBvcnQgY2xhc3MgRmllbGRWYWxpZGF0aW9uRXh0ZW5zaW9uIGltcGxlbWVudHMgRm9ybWx5RXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBmb3JtbHlDb25maWc6IEZvcm1seUNvbmZpZykge31cblxuICBvblBvcHVsYXRlKGZpZWxkOiBGb3JtbHlGaWVsZENvbmZpZ0NhY2hlKSB7XG4gICAgaWYgKCFmaWVsZC5wYXJlbnQgfHwgIWZpZWxkLmtleSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdEZpZWxkVmFsaWRhdGlvbihmaWVsZCwgJ3ZhbGlkYXRvcnMnKTtcbiAgICB0aGlzLmluaXRGaWVsZFZhbGlkYXRpb24oZmllbGQsICdhc3luY1ZhbGlkYXRvcnMnKTtcbiAgfVxuXG4gIHByaXZhdGUgaW5pdEZpZWxkVmFsaWRhdGlvbihmaWVsZDogRm9ybWx5RmllbGRDb25maWdDYWNoZSwgdHlwZTogJ3ZhbGlkYXRvcnMnIHwgJ2FzeW5jVmFsaWRhdG9ycycpIHtcbiAgICBjb25zdCB2YWxpZGF0b3JzOiBWYWxpZGF0b3JGbltdID0gdHlwZSA9PT0gJ3ZhbGlkYXRvcnMnID8gW3RoaXMuZ2V0UHJlZGVmaW5lZEZpZWxkVmFsaWRhdGlvbihmaWVsZCldIDogW107XG4gICAgaWYgKGZpZWxkW3R5cGVdKSB7XG4gICAgICBmb3IgKGNvbnN0IHZhbGlkYXRvck5hbWUgaW4gZmllbGRbdHlwZV0pIHtcbiAgICAgICAgaWYgKHZhbGlkYXRvck5hbWUgPT09ICd2YWxpZGF0aW9uJyAmJiAhQXJyYXkuaXNBcnJheShmaWVsZFt0eXBlXS52YWxpZGF0aW9uKSkge1xuICAgICAgICAgIGZpZWxkW3R5cGVdLnZhbGlkYXRpb24gPSBbZmllbGRbdHlwZV0udmFsaWRhdGlvbl07XG4gICAgICAgICAgY29uc29sZS53YXJuKGBOZ3hGb3JtbHkoJHtmaWVsZC5rZXl9KTogcGFzc2luZyBhIG5vbiBhcnJheSB2YWx1ZSB0byB0aGUgJ3ZhbGlkYXRpb24nIGlzIGRlcHJlY2F0ZWQsIHBhc3MgYW4gYXJyYXkgaW5zdGVhZGApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsaWRhdG9yTmFtZSA9PT0gJ3ZhbGlkYXRpb24nXG4gICAgICAgICAgPyB2YWxpZGF0b3JzLnB1c2goLi4uZmllbGRbdHlwZV0udmFsaWRhdGlvbi5tYXAodiA9PiB0aGlzLndyYXBOZ1ZhbGlkYXRvckZuKGZpZWxkLCB2KSkpXG4gICAgICAgICAgOiB2YWxpZGF0b3JzLnB1c2godGhpcy53cmFwTmdWYWxpZGF0b3JGbihmaWVsZCwgZmllbGRbdHlwZV1bdmFsaWRhdG9yTmFtZV0sIHZhbGlkYXRvck5hbWUpKVxuICAgICAgICA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVmaW5lSGlkZGVuUHJvcChcbiAgICAgIGZpZWxkLFxuICAgICAgJ18nICsgdHlwZSxcbiAgICAgIHR5cGUgPT09ICd2YWxpZGF0b3JzJyA/IFZhbGlkYXRvcnMuY29tcG9zZSh2YWxpZGF0b3JzKSA6IFZhbGlkYXRvcnMuY29tcG9zZUFzeW5jKHZhbGlkYXRvcnMgYXMgYW55KSxcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRQcmVkZWZpbmVkRmllbGRWYWxpZGF0aW9uKGZpZWxkOiBGb3JtbHlGaWVsZENvbmZpZ0NhY2hlKTogVmFsaWRhdG9yRm4ge1xuICAgIGxldCBWQUxJREFUT1JTID0gW107XG4gICAgRk9STUxZX1ZBTElEQVRPUlMuZm9yRWFjaChvcHQgPT4gd3JhcFByb3BlcnR5KGZpZWxkLnRlbXBsYXRlT3B0aW9ucywgb3B0LCAoeyBjdXJyZW50VmFsdWUsIGZpcnN0Q2hhbmdlIH0pID0+IHtcbiAgICAgIFZBTElEQVRPUlMgPSBWQUxJREFUT1JTLmZpbHRlcihvID0+IG8gIT09IG9wdCk7XG4gICAgICBpZiAoY3VycmVudFZhbHVlICE9IG51bGwgJiYgY3VycmVudFZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgICBWQUxJREFUT1JTLnB1c2gob3B0KTtcbiAgICAgIH1cbiAgICAgIGlmICghZmlyc3RDaGFuZ2UgJiYgZmllbGQuZm9ybUNvbnRyb2wpIHtcbiAgICAgICAgdXBkYXRlVmFsaWRpdHkoZmllbGQuZm9ybUNvbnRyb2wpO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIHJldHVybiAoY29udHJvbDogQWJzdHJhY3RDb250cm9sKSA9PiB7XG4gICAgICBpZiAoVkFMSURBVE9SUy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBWYWxpZGF0b3JzLmNvbXBvc2UoVkFMSURBVE9SUy5tYXAob3B0ID0+ICgpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBmaWVsZC50ZW1wbGF0ZU9wdGlvbnNbb3B0XTtcbiAgICAgICAgc3dpdGNoIChvcHQpIHtcbiAgICAgICAgICBjYXNlICdyZXF1aXJlZCc6XG4gICAgICAgICAgICByZXR1cm4gVmFsaWRhdG9ycy5yZXF1aXJlZChjb250cm9sKTtcbiAgICAgICAgICBjYXNlICdwYXR0ZXJuJzpcbiAgICAgICAgICAgIHJldHVybiBWYWxpZGF0b3JzLnBhdHRlcm4odmFsdWUpKGNvbnRyb2wpO1xuICAgICAgICAgIGNhc2UgJ21pbkxlbmd0aCc6XG4gICAgICAgICAgICByZXR1cm4gVmFsaWRhdG9ycy5taW5MZW5ndGgodmFsdWUpKGNvbnRyb2wpO1xuICAgICAgICAgIGNhc2UgJ21heExlbmd0aCc6XG4gICAgICAgICAgICByZXR1cm4gVmFsaWRhdG9ycy5tYXhMZW5ndGgodmFsdWUpKGNvbnRyb2wpO1xuICAgICAgICAgIGNhc2UgJ21pbic6XG4gICAgICAgICAgICByZXR1cm4gVmFsaWRhdG9ycy5taW4odmFsdWUpKGNvbnRyb2wpO1xuICAgICAgICAgIGNhc2UgJ21heCc6XG4gICAgICAgICAgICByZXR1cm4gVmFsaWRhdG9ycy5tYXgodmFsdWUpKGNvbnRyb2wpO1xuICAgICAgICB9XG4gICAgICB9KSkoY29udHJvbCk7XG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgd3JhcE5nVmFsaWRhdG9yRm4oZmllbGQ6IEZvcm1seUZpZWxkQ29uZmlnQ2FjaGUsIHZhbGlkYXRvcjogc3RyaW5nIHwgRmllbGRWYWxpZGF0b3JGbiwgdmFsaWRhdG9yTmFtZT86IHN0cmluZykge1xuICAgIHJldHVybiAoY29udHJvbDogQWJzdHJhY3RDb250cm9sKSA9PiB7XG4gICAgICBsZXQgdmFsaWRhdG9yRm4gPSB2YWxpZGF0b3IgYXMgRmllbGRWYWxpZGF0b3JGbjtcbiAgICAgIGlmICh0eXBlb2YgdmFsaWRhdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YWxpZGF0b3JGbiA9IHRoaXMuZm9ybWx5Q29uZmlnLmdldFZhbGlkYXRvcih2YWxpZGF0b3IpLnZhbGlkYXRpb247XG4gICAgICB9XG4gICAgICBpZiAoaXNPYmplY3QodmFsaWRhdG9yKSkge1xuICAgICAgICB2YWxpZGF0b3JGbiA9ICh2YWxpZGF0b3IgYXMgYW55KS5leHByZXNzaW9uO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpc1ZhbGlkID0gdmFsaWRhdG9yRm4oY29udHJvbCwgZmllbGQpO1xuICAgICAgaWYgKHZhbGlkYXRvck5hbWUpIHtcbiAgICAgICAgaWYgKGlzUHJvbWlzZShpc1ZhbGlkKSkge1xuICAgICAgICAgIHJldHVybiBpc1ZhbGlkLnRoZW4oKHJlc3VsdDogYm9vbGVhbikgPT4ge1xuICAgICAgICAgICAgLy8gd29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMTMyMDBcbiAgICAgICAgICAgIGlmIChmaWVsZC5vcHRpb25zICYmIGZpZWxkLm9wdGlvbnMuX21hcmtGb3JDaGVjaykge1xuICAgICAgICAgICAgICBmaWVsZC5vcHRpb25zLl9tYXJrRm9yQ2hlY2soZmllbGQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXN1bHQoZmllbGQsIHJlc3VsdCwgeyB2YWxpZGF0b3JOYW1lLCB2YWxpZGF0b3IgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXN1bHQoZmllbGQsIGlzVmFsaWQsIHsgdmFsaWRhdG9yTmFtZSwgdmFsaWRhdG9yIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXNWYWxpZDtcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVSZXN1bHQoZmllbGQ6IEZvcm1seUZpZWxkQ29uZmlnQ2FjaGUsIGlzVmFsaWQsIHsgdmFsaWRhdG9yTmFtZSwgdmFsaWRhdG9yIH0pIHtcbiAgICBpZiAoaXNPYmplY3QodmFsaWRhdG9yKSAmJiBmaWVsZC5mb3JtQ29udHJvbCAmJiB2YWxpZGF0b3IuZXJyb3JQYXRoKSB7XG4gICAgICBjb25zdCBjb250cm9sID0gZmllbGQuZm9ybUNvbnRyb2wuZ2V0KHZhbGlkYXRvci5lcnJvclBhdGgpO1xuICAgICAgaWYgKGNvbnRyb2wpIHtcbiAgICAgICAgY29uc3QgY29udHJvbEVycm9ycyA9IChjb250cm9sLmVycm9ycyB8fCB7fSk7XG4gICAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICAgIGNvbnRyb2wuc2V0RXJyb3JzKHsgLi4uY29udHJvbEVycm9ycywgW3ZhbGlkYXRvck5hbWVdOiB7IG1lc3NhZ2U6IHZhbGlkYXRvci5tZXNzYWdlIH0gfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGNvbnRyb2xFcnJvcnNbdmFsaWRhdG9yTmFtZV07XG4gICAgICAgICAgY29udHJvbC5zZXRFcnJvcnMoT2JqZWN0LmtleXMoY29udHJvbEVycm9ycykubGVuZ3RoID09PSAwID8gbnVsbCA6IGNvbnRyb2xFcnJvcnMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpc1ZhbGlkID8gbnVsbCA6IHsgW3ZhbGlkYXRvck5hbWVdOiB7IGVycm9yUGF0aDogdmFsaWRhdG9yLmVycm9yUGF0aCB9IH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzVmFsaWQgPyBudWxsIDogeyBbdmFsaWRhdG9yTmFtZV06IHRydWUgfTtcbiAgfVxufVxuIl19