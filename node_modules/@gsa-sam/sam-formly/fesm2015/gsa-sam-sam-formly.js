import { MatInputModule } from '@angular/material/input';
import { MatNativeDateModule } from '@angular/material/core';
import { MatDatepickerModule } from '@angular/material/datepicker';
import { trigger, state, style, transition, animate, group } from '@angular/animations';
import { FormlySelectModule } from '@ngx-formly/core/select';
import { FontAwesomeModule } from '@fortawesome/angular-fontawesome';
import { Router, ActivatedRoute } from '@angular/router';
import { stringify } from 'qs';
import { Md5 } from 'ts-md5/dist/md5';
import { Subject } from 'rxjs';
import { Component, ViewChild, ViewContainerRef, ChangeDetectionStrategy, ChangeDetectorRef, NgModule, Input, Output, EventEmitter, Optional, HostListener, Injectable, Inject, defineInjectable } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule, FormGroup, FormsModule } from '@angular/forms';
import { FieldWrapper, FieldType, FormlyModule } from '@ngx-formly/core';
import { SDSAutocompleteComponent, SdsTextComponent, SdsSearchComponent, SdsAccordionModule, SdsAutocompleteModule, SdsDialogModule, SdsTextModule, SdsSearchModule, SdsDialogRef, SDS_DIALOG_DATA, SdsDialogService } from '@gsa-sam/components';

class FormlyCustomWrapperComponent extends FieldWrapper {
}
FormlyCustomWrapperComponent.decorators = [
    { type: Component, args: [{
                selector: 'sam-formly-filter-wrapper-form-field',
                template: `
  <sds-accordion multi="true" displayMode="basic">
    <sds-accordion-item class="sds-accordion__panel">
      <sds-accordion-item-header> {{to.label}} </sds-accordion-item-header>
      <div class="usa-form-group" [class.usa-form-group--error]="showError">
      <label class="usa-label" *ngIf="to.label && to.hideLabel !== true" [attr.for]="id" [ngClass]="to.labelClass">
        <span *ngIf="to.tagText" class="usa-tag"  [ngClass]="to.tagClass ? to.tagClass : 'sds-tag--info-white'">{{to.tagText}}</span> 
        <span>{{ to.label }}</span>
        <span *ngIf="!to.required && !to.hideOptional"> (Optional)</span>
      </label>  
      <small *ngIf="to.description" class="form-text text-muted">{{ to.description }}</small>
      <ng-template #fieldComponent></ng-template>
      <div *ngIf="showError" class="usa-error-message" [style.display]="'block'">
        <formly-validation-message [field]="field"></formly-validation-message>
      </div>
      </div>
    </sds-accordion-item>
  </sds-accordion>
  `
            }] }
];
FormlyCustomWrapperComponent.propDecorators = {
    fieldComponent: [{ type: ViewChild, args: ['fieldComponent', { read: ViewContainerRef },] }]
};

/**
 * @param {string} [to.tagClass] Class to be added to the tag (default: sds-tag--info-white)
 * @param {string} [to.tagText] Text to be shown inside the tag
 * @param {string} [to.labelClass] Class to be applied to the label
 * @param {string} [to.label] Text to be shown for the label
 * @param {string} [to.required] Makes the field required
 * @param {string} [to.description] Add a description below the label
 * @param {string} [to.hideOptional] Remove the optional text
 * @param {string} [to.hideLabel] Hide the label
 *
 */
class FormlyWrapperFormFieldComponent extends FieldWrapper {
}
FormlyWrapperFormFieldComponent.decorators = [
    { type: Component, args: [{
                selector: 'sds-formly-wrapper-form-field',
                template: `
<div class="usa-form-group" [class.usa-form-group--error]="showError">
  <label class="usa-label" *ngIf="to.label && to.hideLabel !== true" [attr.for]="id" [ngClass]="to.labelClass">
    <span *ngIf="to.tagText" class="usa-tag"  [ngClass]="to.tagClass ? to.tagClass : 'sds-tag--info-white'">{{to.tagText}}</span>
    <span>{{ to.label }}</span>
    <span *ngIf="!to.required && !to.hideOptional"> (Optional)</span>
  </label>
  <small *ngIf="to.description" class="form-text text-muted">{{ to.description }}</small>
  <ng-template #fieldComponent></ng-template>
  <div *ngIf="showError" class="usa-error-message" [style.display]="'block'">
    <formly-validation-message [field]="field"></formly-validation-message>
  </div>
</div>
  `
            }] }
];
FormlyWrapperFormFieldComponent.propDecorators = {
    fieldComponent: [{ type: ViewChild, args: ['fieldComponent', { read: ViewContainerRef },] }]
};

/**
 * @param {string} [to.expand] to expand the accordion
 *
 */
class FormlyAccordianFormFieldComponent extends FieldWrapper {
    constructor() {
        super();
    }
    modelHasValue() {
        if (this.to.hasOwnProperty('expand')) {
            return this.to.expand;
        }
        else {
            const hasValue = this.formControl.value instanceof Object
                ? stringify(this.formControl.value, { skipNulls: true })
                : this.formControl.value;
            return hasValue ? true : false;
        }
    }
}
FormlyAccordianFormFieldComponent.decorators = [
    { type: Component, args: [{
                selector: 'sam-formly-accordian-form-field',
                template: `
    <sds-accordion multi="true" displayMode="basic">
      <sds-accordion-item
        class="sds-accordion__panel"
        [expanded]="modelHasValue()"
      >
        <sds-accordion-item-header> {{ to.label }} </sds-accordion-item-header>
        <ng-container #fieldComponent></ng-container>
      </sds-accordion-item>
    </sds-accordion>
  `
            }] }
];
/** @nocollapse */
FormlyAccordianFormFieldComponent.ctorParameters = () => [];
FormlyAccordianFormFieldComponent.propDecorators = {
    fieldComponent: [{ type: ViewChild, args: ['fieldComponent', { read: ViewContainerRef },] }]
};

/**
 * @param {string} [to.ariaHidden] Hide the label
 * @param {string} [to.label] Text to be shown for the label
 */
class FormlyFormFieldFilterWrapperComponent extends FieldWrapper {
}
FormlyFormFieldFilterWrapperComponent.decorators = [
    { type: Component, args: [{
                selector: 'sam-formly-filter-wrapper-form-field',
                template: `
    <div  class="wrapper-body">
      <div class="sds-accordion__trigger header-label" [attr.aria-hidden]="to.ariaHidden ? 'false' : 'true'"> {{to.label}} </div>
      <ng-container #fieldComponent></ng-container>
    </div>
  `
            }] }
];
FormlyFormFieldFilterWrapperComponent.propDecorators = {
    fieldComponent: [{ type: ViewChild, args: ['fieldComponent', { read: ViewContainerRef },] }]
};

class FormlyFieldInputComponent extends FieldType {
}
FormlyFieldInputComponent.decorators = [
    { type: Component, args: [{
                selector: 'sds-formly-field-input',
                template: `
  <input [class.usa-input--error]="showError" class="usa-input" [placeholder]="to.placeholder" name="input-success" [formlyAttributes]="field" [type]="to.inputType? to.inputType : 'text'" [formControl]="formControl">
  `
            }] }
];

class FormlyFieldSelectComponent extends FieldType {
    constructor() {
        super(...arguments);
        this.defaultOptions = {
            templateOptions: { options: [] },
        };
    }
}
FormlyFieldSelectComponent.decorators = [
    { type: Component, args: [{
                selector: 'sds-formly-field-select',
                template: `
    <select *ngIf="to.multiple; else singleSelect" 
      multiple
      [class.custom-select]="to.customSelect"
      [formControl]="formControl"
      [class.is-invalid]="showError"
      [formlyAttributes]="field">
        <ng-container *ngFor="let item of to.options | formlySelectOptions:field | async">
         <optgroup *ngIf="item.group" label="{{item.label}}">
            <option *ngFor="let child of item.group" [ngValue]="child.value" [disabled]="child.disabled">
              {{ child.label }}
            </option>
          </optgroup>
          <option *ngIf="!item.group" [ngValue]="item.value" [disabled]="item.disabled">{{ item.label }}</option>
        </ng-container>
    </select>
    <ng-template #singleSelect>
      <select class="usa-select"
        [formControl]="formControl"
        [class.custom-select]="to.customSelect"
        [class.is-invalid]="showError"
        [formlyAttributes]="field">
        <option *ngIf="to.placeholder" [ngValue]="null">{{ to.placeholder }}</option>
        <ng-container *ngFor="let item of to.options | formlySelectOptions:field | async">
          <optgroup *ngIf="item.group" label="{{item.label}}">
            <option *ngFor="let child of item.group" [ngValue]="child.value" [disabled]="child.disabled">
              {{ child.label }}
            </option>
          </optgroup>
          <option *ngIf="!item.group" [ngValue]="item.value" [disabled]="item.disabled">{{ item.label }}</option>
        </ng-container>
      </select>
    </ng-template>
  `
            }] }
];

class FormlyFieldRadioComponent extends FieldType {
    constructor() {
        super(...arguments);
        this.defaultOptions = {
            templateOptions: {
                options: []
            },
        };
    }
}
FormlyFieldRadioComponent.decorators = [
    { type: Component, args: [{
                selector: 'sds-formly-field-radio',
                template: `
  <div class="usa-radio">
      <div *ngFor="let option of to.options | formlySelectOptions:field | async; let i = index;">
        <input type="radio"
          [id]="id + '_' + i"
          class="usa-radio__input"
          [name]="id"
          [class.usa-input--error]="showError"
          [attr.value]="option.value"
          [value]="option.value"
          [formControl]="formControl"
          [formlyAttributes]="field">
        <label
          class="usa-radio__label"
          [for]="id + '_' + i">
          {{ option.label }}
        </label>
      </div>
    </div>
  `
            }] }
];

class FormlyFieldCheckboxComponent extends FieldType {
    constructor() {
        super(...arguments);
        this.defaultOptions = {
            templateOptions: {
                indeterminate: true,
                hideLabel: true,
            },
        };
    }
}
FormlyFieldCheckboxComponent.decorators = [
    { type: Component, args: [{
                selector: 'sds-formly-field-checkbox',
                template: `
    <div class="usa-checkbox">
      <input class="usa-checkbox__input" type="checkbox"
        [class.is-invalid]="showError"
        [indeterminate]="to.indeterminate && formControl.value === null"
        [formControl]="formControl"
        [formlyAttributes]="field">
      <label class="usa-checkbox__label" [for]="id">
        {{ to.label }}
        <span *ngIf="!to.required && !to.hideOptional"> (Optional)</span>
      </label>
    </div>
  `
            }] }
];

class FormlyFieldMultiCheckboxComponent extends FieldType {
    constructor() {
        super(...arguments);
        this.defaultOptions = {
            templateOptions: {
                options: [],
            },
        };
    }
    onChange(value, checked) {
        if (this.to.type === 'array') {
            this.formControl.patchValue(checked
                ? [...(this.formControl.value || []), value]
                : [...(this.formControl.value || [])].filter(o => o !== value));
        }
        else {
            this.formControl.patchValue(Object.assign({}, this.formControl.value, { [value]: checked }));
        }
        this.formControl.markAsTouched();
    }
}
FormlyFieldMultiCheckboxComponent.decorators = [
    { type: Component, args: [{
                selector: 'sds-formly-field-multicheckbox',
                template: `
  <div class="usa-checkbox">
    <div *ngFor="let option of to.options | formlySelectOptions:field | async; let i = index;">
    <input type="checkbox"
     [id]="id + '_' + i"
     class="usa-checkbox__input"
      [value]="option.value"
      [checked]="formControl.value && (this.to.type === 'array' ? formControl.value.includes(option.value) : formControl.value[option.value])"
      [formlyAttributes]="field"
      (change)="onChange(option.value, $event.target.checked)">
    <label
    class="usa-checkbox__label"
    [for]="id + '_' + i">
        {{ option.label }}
    </label>
  </div>
</div>
  `
            }] }
];

class FormlyFieldTextAreaComponent extends FieldType {
    constructor() {
        super(...arguments);
        this.defaultOptions = {
            templateOptions: {
                cols: 1,
                rows: 1,
            },
        };
    }
}
FormlyFieldTextAreaComponent.decorators = [
    { type: Component, args: [{
                selector: 'sds-formly-field-textarea',
                template: `
    <textarea [formControl]="formControl" [cols]="to.cols"
      [rows]="to.rows" class="usa-textarea" [class.usa-input--error]="showError"
      [formlyAttributes]="field">
    </textarea>
  `
            }] }
];

class AbstractSdsFormly extends FieldType {
    ngDoCheck() {
        this.setProperties(this.template, this.field.templateOptions);
    }
    setProperties(component, configuration) {
        Object.keys(configuration).forEach(key => {
            component[key] = configuration[key];
        });
        if (this.template.control) {
            this.template.control = this.formControl;
        }
        this.cdr.detectChanges();
    }
}

class FormlyFieldAutoCompleteComponent extends AbstractSdsFormly {
    constructor(_cdr) {
        super(); /* istanbul ignore next */
        this.cdr = _cdr;
    }
}
FormlyFieldAutoCompleteComponent.decorators = [
    { type: Component, args: [{
                selector: 'sds-formly-field-autocomplete',
                template: `
  <sds-autocomplete [formControl]="formControl"></sds-autocomplete>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
FormlyFieldAutoCompleteComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
FormlyFieldAutoCompleteComponent.propDecorators = {
    template: [{ type: ViewChild, args: [SDSAutocompleteComponent,] }]
};

class FormlyFieldDatePickerComponent extends FieldType {
}
FormlyFieldDatePickerComponent.decorators = [
    { type: Component, args: [{
                selector: 'sds-formly-field-datepicker',
                template: `
    <input
      [id]="id"
      class="usa-input display-inline-block margin-top-3"
      [class.usa-input--error]="showError"
      [formControl]="formControl"
      [formlyAttributes]="field"
      matInput
      [min]="to.minDate"
      [max]="to.maxDate"
      [matDatepicker]="picker"
      placeholder="Choose a date"
    />
    <mat-datepicker-toggle matSuffix [for]="picker"></mat-datepicker-toggle>
    <mat-datepicker [startAt]="to.startDate" #picker></mat-datepicker>
  `
            }] }
];

class FormlyFieldButtonComponent extends FieldType {
    onClick($event) {
        if (this.to.onClick) {
            this.to.onClick($event);
        }
    }
}
FormlyFieldButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'sds-formly-field-button',
                template: `
      <button [type]="to.type" [ngClass]="'btn btn-' + to.btnType" (click)="onClick($event)" class="usa-button--unstyled">
        {{ to.text }}
      </button>
  `
            }] }
];

class FormlyFieldTextComponent extends AbstractSdsFormly {
    constructor(_cdr) {
        super(); /* istanbul ignore next */
        this.cdr = _cdr;
    }
}
FormlyFieldTextComponent.decorators = [
    { type: Component, args: [{
                selector: 'sds-formly-field-text',
                template: `
  <sds-text [formControl]="formControl"></sds-text>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
FormlyFieldTextComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
FormlyFieldTextComponent.propDecorators = {
    template: [{ type: ViewChild, args: [SdsTextComponent,] }]
};

/**
 *
 * @param control
 * @param field
 */
function minDateValidator(control, field) {
    let toReturn = null;
    let minDateField = field.templateOptions.minDate;
    let value = control.value;
    if (value && minDateField) {
        if (value instanceof Date && minDateField instanceof Date) {
            if (value < minDateField) {
                if (!field.templateOptions.maxDate && !(field.templateOptions.maxDate instanceof Date)) {
                    toReturn = {
                        'minDate': true
                    };
                }
                else {
                    toReturn = {
                        'betweenDate': true
                    };
                }
            }
        }
    }
    return toReturn;
}
/**
 *
 * @param control
 * @param field
 */
function maxDateValidator(control, field) {
    let toReturn = null;
    let maxDateField = field.templateOptions.maxDate;
    let value = control.value;
    if (value && maxDateField) {
        if (value instanceof Date && maxDateField instanceof Date) {
            if (value > maxDateField) {
                if (!field.templateOptions.minDate && !(field.templateOptions.minDate instanceof Date)) {
                    toReturn = {
                        'maxDate': true
                    };
                }
                else {
                    toReturn = {
                        'betweenDate': true
                    };
                }
            }
        }
    }
    return toReturn;
}

let sdsFieldWrapper = ['label', 'description', 'validation'];
let sdsGroupWrapper = ['group'];
let sdsWrappers = [...sdsGroupWrapper, ...sdsFieldWrapper];

/**
 * @param {string} [to.tagClass] Class to be added to the tag (default: sds-tag--info-white)
 * @param {string} [to.tagText] Text to be shown inside the tag
 * @param {string} [to.label] Text to be shown for the label
 * @param {string} [to.required] Makes the field required
 * @param {string} [to.hideOptional] Remove the optional text
 *
 */
class FormlyLabelWrapperComponent extends FieldWrapper {
    hasLabel() {
        if (this.to.label) {
            if (!(this.field.type === 'checkbox' || this.field.type === 'multicheckbox')) {
                return true;
            }
        }
    }
}
FormlyLabelWrapperComponent.decorators = [
    { type: Component, args: [{
                template: `
    <div class="usa-form-group" [class.usa-form-group--error]="showError">
      <label class="usa-label" *ngIf="hasLabel()" [attr.for]="id" [ngClass]="{'usa-sr-only' : to.hideLabel || ((to.group==='panel' || to.group==='accordion') && field?.parent?.type!==
      'formly-group') }">
        <span *ngIf="to.tagText" class="usa-tag"  [ngClass]="to.tagClass ? to.tagClass : 'sds-tag--info-white'">{{to.tagText}}</span>
        <span>{{ to.label }}</span>
        <span *ngIf="!to.required && !to.hideOptional"> (Optional)</span>
      </label>
      <ng-container #fieldComponent></ng-container>
    </div>
  `
            }] }
];
FormlyLabelWrapperComponent.propDecorators = {
    fieldComponent: [{ type: ViewChild, args: ['fieldComponent', { read: ViewContainerRef },] }]
};

/**
 * @param {string} [to.description] Add a description below the label
 *
 */
class FormlyDescriptionWrapperComponent extends FieldWrapper {
}
FormlyDescriptionWrapperComponent.decorators = [
    { type: Component, args: [{
                template: `
    <div>
      <small *ngIf="to.description" class="form-text text-muted">{{ to.description }}</small>
      <ng-container #fieldComponent></ng-container>
    </div>
  `
            }] }
];
FormlyDescriptionWrapperComponent.propDecorators = {
    fieldComponent: [{ type: ViewChild, args: ['fieldComponent', { read: ViewContainerRef },] }]
};

/**
 * @param {string} [to.required] Makes the field required
 */
class FormlyValidationWrapperComponent extends FieldWrapper {
}
FormlyValidationWrapperComponent.decorators = [
    { type: Component, args: [{
                template: `
    <ng-container #fieldComponent></ng-container>
    <div *ngIf="showError" class="usa-error-message" [style.display]="'block'">
      <formly-validation-message [field]="field"></formly-validation-message>
    </div>
  `
            }] }
];
FormlyValidationWrapperComponent.propDecorators = {
    fieldComponent: [{ type: ViewChild, args: ['fieldComponent', { read: ViewContainerRef },] }]
};

/**
 * @param {string} [to.group] used to set the wrapper tupe
 * @param {string} [to.announceLabel] For screenreader
 * @param {string} [to.label] Text to be shown for the label
 * @param {string} [to.hideLabel] Hide the label
 *
 */
class FormlyGroupWrapperComponent extends FieldWrapper {
    constructor() {
        super();
    }
    modelHasValue() {
        if (this.to.hasOwnProperty('expand')) {
            return this.to.expand;
        }
        else {
            const hasValue = this.formControl.value instanceof Object
                ? stringify(this.formControl.value, { skipNulls: true })
                : this.formControl.value;
            return hasValue ? true : false;
        }
    }
}
FormlyGroupWrapperComponent.decorators = [
    { type: Component, args: [{
                template: `
    <ng-container [ngSwitch]="to.group">
      <ng-container *ngSwitchCase="'accordion'">
        <sds-accordion multi="true" displayMode="basic">
          <sds-accordion-item
            class="sds-accordion__panel"
            [expanded]="modelHasValue()"
          >
            <sds-accordion-item-header>
              <span
                *ngIf="!to.hideLabel"
                [attr.aria-hidden]="!to.announceLabel ? undefined : 'true'"
              >
                {{ to.label }}
              </span>
            </sds-accordion-item-header>
            <ng-container #fieldComponent></ng-container>
          </sds-accordion-item>
        </sds-accordion>
      </ng-container>
      <ng-container *ngSwitchCase="'panel'">
        <div
          class="sds-panel"
          [ngClass]="{ 'sds-panel--multiple': field?.fieldGroup?.length }"
        >
          <div
            class="sds-panel__header"
            *ngIf="!to.hideLabel"
            [attr.aria-hidden]="!to.announceLabel ? undefined : 'true'"
          >
            {{ to.label }}
          </div>
          <div class="sds-panel__body">
            <ng-container #fieldComponent></ng-container>
          </div>
        </div>
      </ng-container>
      <ng-container *ngSwitchDefault>
        <ng-container #fieldComponent></ng-container>
      </ng-container>
    </ng-container>
  `
            }] }
];
/** @nocollapse */
FormlyGroupWrapperComponent.ctorParameters = () => [];
FormlyGroupWrapperComponent.propDecorators = {
    fieldComponent: [{ type: ViewChild, args: ['fieldComponent', { read: ViewContainerRef },] }]
};

class FormlyFieldSearchComponent extends AbstractSdsFormly {
    constructor(_cdr) {
        super();
        this.cdr = _cdr;
    }
}
FormlyFieldSearchComponent.decorators = [
    { type: Component, args: [{
                selector: 'sds-formly-field-search',
                template: `
    <sds-search [formControl]="formControl"></sds-search>
    `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
FormlyFieldSearchComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
FormlyFieldSearchComponent.propDecorators = {
    template: [{ type: ViewChild, args: [SdsSearchComponent,] }]
};

const FIELD_TYPE_COMPONENTS = [
    FormlyFieldInputComponent,
    FormlyFieldCheckboxComponent,
    FormlyFieldRadioComponent,
    FormlyFieldSelectComponent,
    FormlyFieldTextAreaComponent,
    FormlyFieldMultiCheckboxComponent,
    FormlyWrapperFormFieldComponent,
    FormlyAccordianFormFieldComponent,
    FormlyFieldAutoCompleteComponent,
    FormlyFieldDatePickerComponent,
    FormlyFormFieldFilterWrapperComponent,
    FormlyFieldButtonComponent,
    FormlyCustomWrapperComponent,
    FormlyLabelWrapperComponent,
    FormlyDescriptionWrapperComponent,
    FormlyValidationWrapperComponent,
    FormlyFieldTextComponent,
    FormlyGroupWrapperComponent,
    FormlyFieldSearchComponent
];
const FORMLY_WRAPPERS = [
    {
        name: 'form-field',
        component: FormlyWrapperFormFieldComponent,
        componentName: 'FormlyWrapperFormFieldComponent'
    },
    {
        name: 'accordionwrapper',
        component: FormlyAccordianFormFieldComponent,
        componentName: 'FormlyAccordianFormFieldComponent'
    },
    {
        name: 'filterwrapper',
        component: FormlyFormFieldFilterWrapperComponent,
        componentName: 'FormlyFormFieldFilterWrapperComponent'
    },
    {
        name: 'label',
        component: FormlyLabelWrapperComponent,
        componentName: 'FormlyLabelWrapperComponent'
    },
    {
        name: 'description',
        component: FormlyDescriptionWrapperComponent,
        componentName: 'FormlyDescriptionWrapperComponent'
    },
    {
        name: 'validation',
        component: FormlyValidationWrapperComponent,
        componentName: 'FormlyValidationWrapperComponent'
    },
    {
        name: 'group',
        component: FormlyGroupWrapperComponent,
        componentName: 'FormlyGroupWrapperComponent'
    },
    {
        name: 'customwrapper',
        component: FormlyCustomWrapperComponent,
        componentName: 'FormlyCustomWrapperComponent'
    }
];
const FORMLY_CONFIG = {
    types: [
        {
            name: 'formly-group',
            wrappers: sdsGroupWrapper
        },
        {
            name: 'button',
            component: FormlyFieldButtonComponent
        },
        {
            name: 'customtext',
            component: FormlyFieldTextComponent,
            wrappers: sdsWrappers
        },
        {
            name: 'input',
            component: FormlyFieldInputComponent,
            wrappers: sdsWrappers
        },
        {
            name: 'checkbox',
            component: FormlyFieldCheckboxComponent,
            wrappers: sdsWrappers
        },
        {
            name: 'radio',
            component: FormlyFieldRadioComponent,
            wrappers: sdsWrappers
        },
        {
            name: 'select',
            component: FormlyFieldSelectComponent,
            wrappers: sdsWrappers
        },
        {
            name: 'textarea',
            component: FormlyFieldTextAreaComponent,
            wrappers: sdsWrappers
        },
        {
            name: 'multicheckbox',
            component: FormlyFieldMultiCheckboxComponent,
            wrappers: sdsWrappers
        },
        {
            name: 'autocomplete',
            component: FormlyFieldAutoCompleteComponent,
            wrappers: sdsWrappers
        },
        {
            name: 'datepicker',
            component: FormlyFieldDatePickerComponent,
            wrappers: sdsWrappers,
            defaultOptions: {
                validators: {
                    validation: [maxDateValidator, minDateValidator]
                }
            }
        },
        {
            name: 'daterangepicker',
            extends: 'formly-group',
            wrappers: sdsWrappers,
            defaultOptions: {
                fieldGroup: [
                    {
                        type: 'datepicker',
                        key: 'fromDate',
                        templateOptions: {
                            label: 'From'
                        },
                        expressionProperties: {
                            'templateOptions.minDate': minDateFromDateRangePicker,
                            'templateOptions.maxDate': maxDateFromDateRangePicker
                        }
                    },
                    {
                        type: 'datepicker',
                        key: 'toDate',
                        templateOptions: {
                            label: 'To'
                        },
                        expressionProperties: {
                            'templateOptions.minDate': minDateToDateRangePicker,
                            'templateOptions.maxDate': maxDateToDateRangePicker
                        }
                    }
                ]
            }
        },
        {
            name: 'search',
            component: FormlyFieldSearchComponent,
            wrappers: sdsWrappers
        }
    ],
    wrappers: [
        { name: 'label', component: FormlyLabelWrapperComponent },
        { name: 'description', component: FormlyDescriptionWrapperComponent },
        { name: 'validation', component: FormlyValidationWrapperComponent },
        { name: 'group', component: FormlyGroupWrapperComponent },
        { name: 'form-field', component: FormlyWrapperFormFieldComponent },
        { name: 'accordionwrapper', component: FormlyAccordianFormFieldComponent },
        { name: 'filterwrapper', component: FormlyFormFieldFilterWrapperComponent },
        { name: 'customwrapper', component: FormlyCustomWrapperComponent }
    ]
};
function minDateToDateRangePicker(model, formState, field) {
    let date = null;
    //Setting a minumn date for the date range picker
    if (field.parent.templateOptions.minDate) {
        date = new Date(field.parent.templateOptions.minDate.getTime());
    }
    if (model) {
        if (model.fromDate) {
            date = model.fromDate;
        }
    }
    return date;
}
function minDateFromDateRangePicker(model, formState, field) {
    let date = null;
    //Setting a minumn date for the date range picker
    if (field.parent.templateOptions.minDate) {
        date = new Date(field.parent.templateOptions.minDate.getTime());
    }
    return date;
}
function maxDateToDateRangePicker(model, formState, field) {
    let date = null;
    //Setting a max date for the date range picker
    if (field.parent.templateOptions.maxDate) {
        date = new Date(field.parent.templateOptions.maxDate.getTime());
    }
    return date;
}
function maxDateFromDateRangePicker(model, formState, field) {
    let date = null;
    //Setting a max date for the date range picker
    if (field.parent.templateOptions.maxDate) {
        date = new Date(field.parent.templateOptions.maxDate);
    }
    if (model) {
        if (model.toDate) {
            date = model.toDate;
        }
    }
    return date;
}

const SlideInOutAnimation = [
    trigger('slideInOut', [
        state('in', style({
            'max-height': '2000px', 'opacity': '1', 'visibility': 'visible',
        })),
        state('out', style({
            'max-height': '0px', 'opacity': '0', 'visibility': 'hidden',
        })),
        transition('in => out', [group([
                animate('400ms ease-in-out', style({
                    'opacity': '0',
                })),
                animate('600ms ease-in-out', style({
                    'max-height': '0px',
                })),
                animate('700ms ease-in-out', style({
                    'visibility': 'hidden',
                })),
            ])]),
        transition('out => in', [group([
                animate('1ms ease-in-out', style({
                    'visibility': 'visible',
                })),
                animate('600ms ease-in-out', style({
                    'max-height': '500px',
                })),
                animate('800ms ease-in-out', style({
                    'opacity': '1',
                })),
            ])]),
    ]),
];
class AnimationWrapperComponent extends FieldWrapper {
}
AnimationWrapperComponent.decorators = [
    { type: Component, args: [{
                selector: 'sam-formly-wrapper-animation',
                template: `
    <div [@slideInOut]="field.hide ? 'out' : 'in'">
      <ng-container #fieldComponent></ng-container>
    </div>
  `,
                // styles: [`
                //   ::ng-deep formly-field {
                //     display: block !important;
                //   }
                // `],
                animations: [SlideInOutAnimation]
            }] }
];

// Validate the min length of the character
function minlengthValidationMessage(err, field) {
    return `Should have atleast ${field.templateOptions.minLength} characters`;
}
// Validate the max length of the character
function maxlengthValidationMessage(err, field) {
    return `This value should be less than ${field.templateOptions.maxLength} characters`;
}
// Validate the min value of the character
function minValidationMessage(err, field) {
    return `This value should be more than ${field.templateOptions.min}`;
}
function minDateValidationMessage(err, field) {
    const dt = field.templateOptions.minDate;
    const dateFormat = (dt.getMonth() + 1) + "/" + dt.getDate() + "/" + dt.getFullYear();
    return `Date must be after ${dateFormat}`;
}
function maxDateValidationMessage(err, field) {
    const dt = field.templateOptions.maxDate;
    const dateFormat = (dt.getMonth() + 1) + "/" + dt.getDate() + "/" + dt.getFullYear();
    return `Date must be before ${dateFormat}`;
}
function betweenDateValidationMessage(err, field) {
    const dtnmax = field.templateOptions.maxDate;
    const dateMaxFormat = (dtnmax.getMonth() + 1) + "/" + dtnmax.getDate() + "/" + dtnmax.getFullYear();
    const dtmin = field.templateOptions.minDate;
    const dateMinFormat = (dtmin.getMonth() + 1) + "/" + dtmin.getDate() + "/" + dtmin.getFullYear();
    return `Date must be between ${dateMinFormat} and ${dateMaxFormat} `;
}
function invalidDateFormatValidationMessage(err, field) {
    return `Valid date format required (ex: MM/DD/YYYY)`;
}
// Validate the max value of the character
function maxValidationMessage(err, field) {
    return `This value should be less than ${field.templateOptions.max}`;
}
function animationExtension(field) {
    if (field.wrappers && field.wrappers.includes('animation')) {
        return;
    }
    field.wrappers = ['animation', ...(field.wrappers || [])];
}
class SdsFormlyModule {
    static forChild(config = {}) {
        return [{ ngModule: SdsFormlyModule, providers: [] }, FormlyModule.forChild(config)];
    }
}
SdsFormlyModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    FIELD_TYPE_COMPONENTS,
                    AnimationWrapperComponent,
                ],
                imports: [
                    CommonModule,
                    SdsAccordionModule,
                    SdsAutocompleteModule,
                    SdsDialogModule,
                    SdsSearchModule,
                    SdsTextModule,
                    MatNativeDateModule,
                    MatDatepickerModule,
                    MatInputModule,
                    FontAwesomeModule,
                    ReactiveFormsModule,
                    FormlySelectModule,
                    FormlyModule.forChild(FORMLY_CONFIG),
                    FormlyModule.forRoot({
                        validationMessages: [
                            { name: 'required', message: 'This field is required' },
                            { name: 'minlength', message: minlengthValidationMessage },
                            { name: 'maxlength', message: maxlengthValidationMessage },
                            { name: 'min', message: minValidationMessage },
                            { name: 'max', message: maxValidationMessage },
                            { name: 'minDate', message: minDateValidationMessage },
                            { name: 'maxDate', message: maxDateValidationMessage },
                            { name: 'betweenDate', message: betweenDateValidationMessage },
                            { name: 'matDatepickerParse', message: invalidDateFormatValidationMessage } // Comes from the datepicker
                        ],
                        validators: [
                            { name: 'minDate', validation: minDateValidator },
                            { name: 'maxDate', validation: maxDateValidator }
                        ],
                        wrappers: [
                            { name: 'animation', component: AnimationWrapperComponent },
                        ],
                        extensions: [
                            { name: 'animation', extension: { onPopulate: animationExtension } },
                        ],
                    })
                ]
            },] }
];

class SdsFormlyResetComponent {
    constructor() {
        /**
         * Pass in classes for reset button -- default .usa-button .usa-button--unstyled
         */
        this.classes = ['usa-button', 'usa-button--unstyled'];
    }
    resetAll() {
        this.options.resetModel();
    }
}
SdsFormlyResetComponent.decorators = [
    { type: Component, args: [{
                selector: 'sds-formly-reset',
                template: "<button (click)=\"resetAll()\" [ngClass]=\"classes\">\n  Reset All\n  <fa-icon [icon]=\"['sds', 'reset']\" [classes]=\"['icon-reset']\"></fa-icon>\n</button>\n",
                styles: [".usa-button--unstyled{padding-right:0;width:initial;text-decoration:none;font-weight:600}.usa-button--unstyled:active,.usa-button--unstyled:hover{background:initial;color:initial;text-decoration:underline}"]
            }] }
];
SdsFormlyResetComponent.propDecorators = {
    options: [{ type: Input }],
    classes: [{ type: Input }]
};

class SdsFormlyResetModule {
}
SdsFormlyResetModule.decorators = [
    { type: NgModule, args: [{
                declarations: [SdsFormlyResetComponent],
                imports: [
                    CommonModule,
                    FontAwesomeModule
                ],
                exports: [
                    SdsFormlyResetComponent
                ]
            },] }
];

class SDSFormlyUpdateComunicationService {
    constructor() {
        /**
         * Filter update subject
         */
        this.updateFilterSource = new Subject();
        /**
         * Observable to subscribe to for get updates of the filter
         */
        this.filterUpdate = this.updateFilterSource.asObservable();
    }
    /**
     * Update the filter
     * @param filterData
     */
    updateFilter(filterData) {
        this.updateFilterSource.next(filterData);
    }
}

class SdsFiltersComponent {
    constructor(formlyUpdateComunicationService, cdr, router, route) {
        this.formlyUpdateComunicationService = formlyUpdateComunicationService;
        this.cdr = cdr;
        this.router = router;
        this.route = route;
        /**
         *    Options for the form.
         */
        this.options = {};
        /**
         *  Emit results when model updated
         * To enable History Tracking
         *  If advanced filters dialog should be displayed -- defaults to false
         */
        this.advancedFilters = false;
        /**
         * Timer id for the timer awaiting the service call for more typeing
         */
        this.isHistoryEnable = true;
        /**
         *  Emit results when model updated
         */
        // TODO: check type -- Formly models are typically objects
        this.filterChange = new EventEmitter();
        this.sdsFilterHistory = [];
        this._isObj = (obj) => typeof obj === 'object' && obj !== null;
        this._isEmpty = (obj) => Object.keys(obj).length === 0;
        this.overwrite = (baseObj, newObj) => {
            let result = {};
            for (let key in baseObj) {
                if (Array.isArray(baseObj[key])) {
                    result[key] = newObj[key];
                }
                else if (this._isObj(baseObj[key])) {
                    result[key] = this.overwrite(baseObj[key], newObj[key] || {});
                }
                else {
                    result[key] = newObj[key] || null;
                }
            }
            return result;
        };
        this.nullify = (obj) => {
            for (let key in obj) {
                if (this._isObj(obj[key])) {
                    obj[key] = this.nullify(obj[key]);
                }
                else {
                    obj[key] = null;
                }
            }
            return obj;
        };
    }
    onpopstate() {
        const queryString = window.location.search;
        const urlParams = new URLSearchParams(queryString);
        const ref = urlParams.get('ref');
        const updatedFormValue = ref == null
            ? this.nullify(this.form.value)
            : JSON.parse(localStorage.getItem(ref));
        const updatedValue = this.overwrite(this.form.getRawValue(), updatedFormValue);
        this.form.setValue(updatedValue, { emitEvent: false });
        this.updateChange(updatedFormValue);
    }
    ngOnInit() {
        if (this.isHistoryEnable) {
            const queryString = window.location.search;
            const urlParams = new URLSearchParams(queryString);
            const initialRef = urlParams.get('ref');
            if (initialRef) {
                const updatedFormValue = JSON.parse(localStorage.getItem(initialRef));
                setTimeout(() => {
                    this.model = Object.assign({}, this.model, updatedFormValue);
                    this.updateChange(updatedFormValue);
                    this.cdr.detectChanges();
                }, 0);
            }
            else {
                this.updateChange(this.model);
                this.clearStorage();
            }
        }
        this.cdr.detectChanges();
    }
    onModelChange(change) {
        if (this.isHistoryEnable) {
            const md5 = new Md5();
            const hashCode = md5.appendStr(stringify(change)).end();
            this.router.navigate([], {
                relativeTo: this.route,
                queryParams: { ref: hashCode },
                queryParamsHandling: 'merge'
            });
            this.addToStorageList(hashCode);
            localStorage.setItem(hashCode.toString(), JSON.stringify(change));
        }
        this.updateChange(change);
    }
    updateChange(change) {
        this.filterChange.emit(change);
        if (this.formlyUpdateComunicationService) {
            this.formlyUpdateComunicationService.updateFilter(change);
        }
    }
    addToStorageList(hashCode) {
        const list = JSON.parse(localStorage.getItem('sdsFilterHistory'));
        this.sdsFilterHistory = (list && list.length > 0) ? list : this.sdsFilterHistory;
        this.sdsFilterHistory.push(hashCode);
        localStorage.setItem('sdsFilterHistory', JSON.stringify(this.sdsFilterHistory));
    }
    clearStorage() {
        const list = JSON.parse(localStorage.getItem('sdsFilterHistory'));
        if (list && list.length > 0) {
            const unique = list.filter((item, i, ar) => ar.indexOf(item) === i);
            unique.forEach(item => {
                localStorage.removeItem(item);
            });
        }
    }
}
SdsFiltersComponent.decorators = [
    { type: Component, args: [{
                selector: 'sds-filters',
                template: "<formly-form [form]=\"form\" [fields]=\"fields\" [options]=\"options\" [model]=\"model\" (modelChange)=\"onModelChange($event)\">\n</formly-form>\n<div class=\"grid-row\">\n  <div *ngIf=\"advancedFilters\" class=\"grid-col\">\n    <sds-advanced-filters [form]=\"form\" [fields]=\"fields\" [options]=\"options\" [model]=\"model\">\n    </sds-advanced-filters>\n  </div>\n  <div class=\"grid-col text-right\">\n    <sds-formly-reset [options]=\"options\"></sds-formly-reset>\n  </div>\n</div>\n"
            }] }
];
/** @nocollapse */
SdsFiltersComponent.ctorParameters = () => [
    { type: SDSFormlyUpdateComunicationService, decorators: [{ type: Optional }] },
    { type: ChangeDetectorRef },
    { type: Router },
    { type: ActivatedRoute }
];
SdsFiltersComponent.propDecorators = {
    form: [{ type: Input }],
    fields: [{ type: Input }],
    model: [{ type: Input }],
    options: [{ type: Input }],
    advancedFilters: [{ type: Input }],
    isHistoryEnable: [{ type: Input }],
    filterChange: [{ type: Output }],
    onpopstate: [{ type: HostListener, args: ['window:popstate', [''],] }]
};

class SdsAdvancedFiltersService {
    constructor() { }
    convertToCheckboxes(origFields) {
        const fields = [];
        origFields.forEach(origField => {
            if (origField.fieldGroup && origField.fieldGroup.length > 1) {
                const field = this.createMulticheckbox(origField);
                fields.push(field);
            }
            else {
                const field = {
                    type: 'checkbox',
                    key: origField.key,
                    defaultValue: !origField.hide,
                    templateOptions: {
                        hideOptional: true
                    }
                };
                if (origField.templateOptions && origField.templateOptions.label) {
                    field.templateOptions.label = origField.templateOptions.label;
                }
                fields.push(field);
            }
        });
        return fields;
    }
    // TODO: Should be changed so option has label field instead of key but multicheckbox field type must be updated so default value still works
    createMulticheckbox(origField) {
        const options = [];
        const defaultValue = [];
        origField.fieldGroup.forEach(field => {
            const label = field.templateOptions && field.templateOptions.label ? field.templateOptions.label : null;
            const option = {
                key: field.key,
                value: label
            };
            options.push(option);
            if (!origField.hide && !field.hide) {
                defaultValue.push(field.key);
            }
        });
        const field = {
            key: origField.key,
            type: 'multicheckbox',
            templateOptions: {
                hideOptional: true,
                type: 'array',
                options: options
            }
        };
        if (origField.templateOptions && origField.templateOptions.label) {
            field.templateOptions.label = origField.templateOptions.label;
        }
        if (!origField.hide) {
            field.defaultValue = defaultValue;
        }
        return field;
    }
    updateFields(selectedFields, fields, model) {
        fields.forEach((field) => {
            const key = field.key;
            const selectedField = selectedFields[key];
            if (field.fieldGroup && field.fieldGroup.length > 1) {
                const fieldModel = model[key];
                this.updateFieldGroup(field, selectedField, fieldModel);
            }
            else {
                this.updateSingleField(field, selectedField, model);
            }
        });
        return {
            fields: fields,
            model: model
        };
    }
    updateFieldGroup(parentField, selectedFields, model) {
        if (selectedFields && selectedFields.length) {
            parentField.hide = false;
            parentField.fieldGroup.forEach(field => {
                const key = field.key;
                const fieldSelected = selectedFields.includes(key);
                this.updateSingleField(field, fieldSelected, model);
            });
        }
        else {
            parentField.hide = true;
            parentField.fieldGroup.forEach(field => {
                this.updateSingleField(field, false, model);
            });
        }
    }
    updateSingleField(field, fieldSelected, model) {
        if (fieldSelected) {
            field.hide = false;
        }
        else {
            field.hide = true;
            field.templateOptions['required'] = false;
            model[field.key] = null;
        }
    }
}
SdsAdvancedFiltersService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
SdsAdvancedFiltersService.ctorParameters = () => [];
SdsAdvancedFiltersService.ngInjectableDef = defineInjectable({ factory: function SdsAdvancedFiltersService_Factory() { return new SdsAdvancedFiltersService(); }, token: SdsAdvancedFiltersService, providedIn: "root" });

class SdsFormlyDialogComponent {
    constructor(advancedFiltersService, dialogRef, data) {
        this.advancedFiltersService = advancedFiltersService;
        this.dialogRef = dialogRef;
        this.data = data;
    }
    ngOnInit() {
        this.fields = this.data.fields;
        this.form = this.data.form ? this.data.form : new FormGroup({});
        this.model = this.data.model ? this.data.model : {};
        this.options = this.data.options ? this.data.options : {};
        this.cancel = this.data.cancel ? this.data.cancel : 'Cancel';
        this.submit = this.data.submit ? this.data.submit : 'Submit';
    }
    onSubmit() {
        if (this.form.valid) {
            const results = this.advancedFiltersService.updateFields(this.model, this.data.originalFields, this.data.originalModel);
            this.dialogRef.close(results);
        }
    }
    onCancel() {
        this.dialogRef.close();
    }
}
SdsFormlyDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'sds-formly-dialog',
                template: "<form [formGroup]=\"form\" (ngSubmit)=\"onSubmit()\">\n  <div *ngIf=\"data.title\" sds-dialog-title>{{data.title}}</div>\n  <div *ngIf=\"data.subtitle\" sds-dialog-subtitle>{{data.subtitle}}</div>\n  <div sds-dialog-content>\n    <formly-form [form]=\"form\" [fields]=\"fields\" [options]=\"options\" [model]=\"model\"></formly-form>\n  </div>\n  <div sds-dialog-actions>\n    <button class=\"usa-button usa-button--base\" (click)=\"onCancel()\" type=\"button\">\n      {{cancel}}\n    </button>\n    <button class=\"usa-button\" type=\"submit\">\n      {{submit}}\n    </button>\n  </div>\n</form>\n"
            }] }
];
/** @nocollapse */
SdsFormlyDialogComponent.ctorParameters = () => [
    { type: SdsAdvancedFiltersService },
    { type: SdsDialogRef },
    { type: undefined, decorators: [{ type: Inject, args: [SDS_DIALOG_DATA,] }] }
];

class AdvancedFiltersComponent {
    constructor(dialog, advancedFiltersService) {
        this.dialog = dialog;
        this.advancedFiltersService = advancedFiltersService;
        /**
         *    Options for the form.
         */
        this.options = {};
    }
    openDialog() {
        const modalFields = this.advancedFiltersService.convertToCheckboxes(this.fields);
        const data = {
            fields: modalFields,
            originalFields: this.fields,
            originalModel: this.model,
            submit: 'Update',
            title: 'More Filters',
        };
        const dialogRef = this.dialog.open(SdsFormlyDialogComponent, {
            width: 'medium',
            data: data
        });
        dialogRef.afterClosed().subscribe(result => {
            if (result) {
                this.fields = result.fields;
                this.model = result.model;
            }
        });
    }
}
AdvancedFiltersComponent.decorators = [
    { type: Component, args: [{
                selector: 'sds-advanced-filters',
                template: "<button type=\"button\" (click)=\"openDialog()\" class=\"usa-button usa-button--unstyled\">More\n  Filters\n  <fa-icon [icon]=\"['sds', 'filter']\" [classes]=\"['icon-filter']\"></fa-icon>\n</button>\n",
                styles: [".usa-button--unstyled{padding-left:0;width:initial;text-decoration:none;font-weight:600}.usa-button--unstyled:active,.usa-button--unstyled:hover{background:initial;color:initial;text-decoration:underline}"]
            }] }
];
/** @nocollapse */
AdvancedFiltersComponent.ctorParameters = () => [
    { type: SdsDialogService },
    { type: SdsAdvancedFiltersService }
];
AdvancedFiltersComponent.propDecorators = {
    form: [{ type: Input }],
    fields: [{ type: Input }],
    model: [{ type: Input }],
    options: [{ type: Input }]
};

class SdsFiltersModule {
}
SdsFiltersModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    SdsFiltersComponent,
                    AdvancedFiltersComponent,
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    SdsAccordionModule,
                    SdsFormlyModule,
                    SdsFormlyResetModule,
                    FontAwesomeModule,
                    ReactiveFormsModule,
                    FormlySelectModule,
                    FormlyModule
                ],
                exports: [SdsFiltersComponent]
            },] }
];

class SdsFormlyDialogModule {
}
SdsFormlyDialogModule.decorators = [
    { type: NgModule, args: [{
                declarations: [SdsFormlyDialogComponent],
                imports: [
                    CommonModule,
                    SdsFiltersModule,
                    SdsDialogModule,
                    ReactiveFormsModule,
                    SdsFormlyModule,
                    FormlyModule,
                    FormsModule
                ],
                entryComponents: [SdsFormlyDialogComponent],
                exports: [SdsFormlyDialogComponent]
            },] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { AdvancedFiltersComponent as ɵw, SdsFiltersComponent as ɵv, SdsFormlyResetComponent as ɵu, FormlyFieldAutoCompleteComponent as ɵi, FormlyFieldButtonComponent as ɵl, FormlyFieldCheckboxComponent as ɵb, FormlyFieldDatePickerComponent as ɵj, FormlyFieldInputComponent as ɵa, FormlyFieldMultiCheckboxComponent as ɵf, FormlyFieldRadioComponent as ɵc, FormlyFieldSearchComponent as ɵs, FormlyFieldSelectComponent as ɵd, FormlyFieldTextComponent as ɵq, FormlyFieldTextAreaComponent as ɵe, FormlyCustomWrapperComponent as ɵm, FormlyDescriptionWrapperComponent as ɵo, FormlyAccordianFormFieldComponent as ɵh, AnimationWrapperComponent as ɵt, FormlyFormFieldFilterWrapperComponent as ɵk, FormlyWrapperFormFieldComponent as ɵg, FormlyGroupWrapperComponent as ɵr, FormlyLabelWrapperComponent as ɵn, FormlyValidationWrapperComponent as ɵp, minlengthValidationMessage, maxlengthValidationMessage, minValidationMessage, minDateValidationMessage, maxDateValidationMessage, betweenDateValidationMessage, invalidDateFormatValidationMessage, maxValidationMessage, animationExtension, SdsFormlyModule, maxDateValidator, minDateValidator, SdsFormlyResetModule, SdsFiltersModule, SdsFormlyDialogComponent, SdsFormlyDialogModule, SDSFormlyUpdateComunicationService, SdsAdvancedFiltersService, sdsFieldWrapper, sdsGroupWrapper, sdsWrappers, FIELD_TYPE_COMPONENTS, FORMLY_WRAPPERS, FORMLY_CONFIG, minDateToDateRangePicker, minDateFromDateRangePicker, maxDateToDateRangePicker, maxDateFromDateRangePicker, AbstractSdsFormly };

//# sourceMappingURL=gsa-sam-sam-formly.js.map