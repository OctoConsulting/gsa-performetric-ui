/**
 *
 * @param control
 * @param field
 */
export function minDateValidator(control, field) {
    let toReturn = null;
    let minDateField = field.templateOptions.minDate;
    let value = control.value;
    if (value && minDateField) {
        if (value instanceof Date && minDateField instanceof Date) {
            if (value < minDateField) {
                if (!field.templateOptions.maxDate && !(field.templateOptions.maxDate instanceof Date)) {
                    toReturn = {
                        'minDate': true
                    };
                }
                else {
                    toReturn = {
                        'betweenDate': true
                    };
                }
            }
        }
    }
    return toReturn;
}
/**
 * Usage:
 *  Override the required validator to allow autocompletes to behave more like
 *  the other inputs regarding error messages
 *
 // In the formly config
 {
      type: 'autocomplete',
      templateOptions: {
        required: true,
      },
      validators: {
        required: autocompleteRequired
      },
 */
export function autocompleteRequired(control) {
    return control.value && control.value.items && control.value.length ? { required: true } : null;
}
/**
 *
 * @param control
 * @param field
 */
export function maxDateValidator(control, field) {
    let toReturn = null;
    let maxDateField = field.templateOptions.maxDate;
    let value = control.value;
    if (value && maxDateField) {
        if (value instanceof Date && maxDateField instanceof Date) {
            if (value > maxDateField) {
                if (!field.templateOptions.minDate && !(field.templateOptions.minDate instanceof Date)) {
                    toReturn = {
                        'maxDate': true
                    };
                }
                else {
                    toReturn = {
                        'betweenDate': true
                    };
                }
            }
        }
    }
    return toReturn;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9ybWx5LnZhbGlkYXRvcnMuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AZ3NhLXNhbS9zYW0tZm9ybWx5LyIsInNvdXJjZXMiOlsibGliL2Zvcm1seS9mb3JtbHkudmFsaWRhdG9ycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFJQTs7OztHQUlHO0FBQ0gsTUFBTSxVQUFVLGdCQUFnQixDQUFDLE9BQW9CLEVBQUUsS0FBd0I7SUFDM0UsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDO0lBQ3BCLElBQUksWUFBWSxHQUFHLEtBQUssQ0FBQyxlQUFlLENBQUMsT0FBTyxDQUFDO0lBQ2pELElBQUksS0FBSyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUM7SUFDMUIsSUFBSSxLQUFLLElBQUksWUFBWSxFQUFFO1FBQ3ZCLElBQUksS0FBSyxZQUFZLElBQUksSUFBSSxZQUFZLFlBQVksSUFBSSxFQUFFO1lBQ3ZELElBQUksS0FBSyxHQUFHLFlBQVksRUFBRTtnQkFDdEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxlQUFlLENBQUMsT0FBTyxJQUFJLENBQUMsQ0FBQyxLQUFLLENBQUMsZUFBZSxDQUFDLE9BQU8sWUFBWSxJQUFJLENBQUMsRUFBRTtvQkFDcEYsUUFBUSxHQUFHO3dCQUNQLFNBQVMsRUFBRSxJQUFJO3FCQUNsQixDQUFDO2lCQUNMO3FCQUFNO29CQUNILFFBQVEsR0FBRzt3QkFDUCxhQUFhLEVBQUUsSUFBSTtxQkFDdEIsQ0FBQztpQkFDTDthQUNKO1NBQ0o7S0FDSjtJQUVELE9BQU8sUUFBUSxDQUFDO0FBQ3BCLENBQUM7QUFFRDs7Ozs7Ozs7Ozs7Ozs7R0FjRztBQUNILE1BQU0sVUFBVSxvQkFBb0IsQ0FBQyxPQUFvQjtJQUN2RCxPQUFPLE9BQU8sQ0FBQyxLQUFLLElBQUksT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLElBQUksT0FBTyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7QUFDbEcsQ0FBQztBQUVEOzs7O0dBSUc7QUFDSCxNQUFNLFVBQVUsZ0JBQWdCLENBQUMsT0FBb0IsRUFBRSxLQUF3QjtJQUMzRSxJQUFJLFFBQVEsR0FBRyxJQUFJLENBQUM7SUFDcEIsSUFBSSxZQUFZLEdBQUcsS0FBSyxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUM7SUFDakQsSUFBSSxLQUFLLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQztJQUMxQixJQUFJLEtBQUssSUFBSSxZQUFZLEVBQUU7UUFDdkIsSUFBSSxLQUFLLFlBQVksSUFBSSxJQUFJLFlBQVksWUFBWSxJQUFJLEVBQUU7WUFDdkQsSUFBSSxLQUFLLEdBQUcsWUFBWSxFQUFFO2dCQUN0QixJQUFJLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FBQyxPQUFPLElBQUksQ0FBQyxDQUFDLEtBQUssQ0FBQyxlQUFlLENBQUMsT0FBTyxZQUFZLElBQUksQ0FBQyxFQUFFO29CQUNwRixRQUFRLEdBQUc7d0JBQ1AsU0FBUyxFQUFFLElBQUk7cUJBQ2xCLENBQUM7aUJBQ0w7cUJBQU07b0JBQ0gsUUFBUSxHQUFHO3dCQUNQLGFBQWEsRUFBRSxJQUFJO3FCQUN0QixDQUFDO2lCQUNMO2FBQ0o7U0FDSjtLQUNKO0lBQ0QsT0FBTyxRQUFRLENBQUM7QUFDcEIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEZvcm1Db250cm9sLCBWYWxpZGF0aW9uRXJyb3JzIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgRm9ybWx5RmllbGRDb25maWcgfSBmcm9tICdAbmd4LWZvcm1seS9jb3JlJztcblxuXG4vKipcbiAqXG4gKiBAcGFyYW0gY29udHJvbFxuICogQHBhcmFtIGZpZWxkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtaW5EYXRlVmFsaWRhdG9yKGNvbnRyb2w6IEZvcm1Db250cm9sLCBmaWVsZDogRm9ybWx5RmllbGRDb25maWcpOiBWYWxpZGF0aW9uRXJyb3JzIHtcbiAgICBsZXQgdG9SZXR1cm4gPSBudWxsO1xuICAgIGxldCBtaW5EYXRlRmllbGQgPSBmaWVsZC50ZW1wbGF0ZU9wdGlvbnMubWluRGF0ZTtcbiAgICBsZXQgdmFsdWUgPSBjb250cm9sLnZhbHVlO1xuICAgIGlmICh2YWx1ZSAmJiBtaW5EYXRlRmllbGQpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSAmJiBtaW5EYXRlRmllbGQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPCBtaW5EYXRlRmllbGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZpZWxkLnRlbXBsYXRlT3B0aW9ucy5tYXhEYXRlICYmICEoZmllbGQudGVtcGxhdGVPcHRpb25zLm1heERhdGUgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICAgICAgICAgICAgICB0b1JldHVybiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW5EYXRlJzogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRvUmV0dXJuID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2JldHdlZW5EYXRlJzogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0b1JldHVybjtcbn1cblxuLyoqXG4gKiBVc2FnZTpcbiAqICBPdmVycmlkZSB0aGUgcmVxdWlyZWQgdmFsaWRhdG9yIHRvIGFsbG93IGF1dG9jb21wbGV0ZXMgdG8gYmVoYXZlIG1vcmUgbGlrZVxuICogIHRoZSBvdGhlciBpbnB1dHMgcmVnYXJkaW5nIGVycm9yIG1lc3NhZ2VzXG4gKlxuIC8vIEluIHRoZSBmb3JtbHkgY29uZmlnXG4ge1xuICAgICAgdHlwZTogJ2F1dG9jb21wbGV0ZScsXG4gICAgICB0ZW1wbGF0ZU9wdGlvbnM6IHtcbiAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICB9LFxuICAgICAgdmFsaWRhdG9yczoge1xuICAgICAgICByZXF1aXJlZDogYXV0b2NvbXBsZXRlUmVxdWlyZWRcbiAgICAgIH0sXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhdXRvY29tcGxldGVSZXF1aXJlZChjb250cm9sOiBGb3JtQ29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMge1xuICByZXR1cm4gY29udHJvbC52YWx1ZSAmJiBjb250cm9sLnZhbHVlLml0ZW1zICYmIGNvbnRyb2wudmFsdWUubGVuZ3RoID8geyByZXF1aXJlZDogdHJ1ZSB9IDogbnVsbDtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIGNvbnRyb2xcbiAqIEBwYXJhbSBmaWVsZFxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF4RGF0ZVZhbGlkYXRvcihjb250cm9sOiBGb3JtQ29udHJvbCwgZmllbGQ6IEZvcm1seUZpZWxkQ29uZmlnKTogVmFsaWRhdGlvbkVycm9ycyB7XG4gICAgbGV0IHRvUmV0dXJuID0gbnVsbDtcbiAgICBsZXQgbWF4RGF0ZUZpZWxkID0gZmllbGQudGVtcGxhdGVPcHRpb25zLm1heERhdGU7XG4gICAgbGV0IHZhbHVlID0gY29udHJvbC52YWx1ZTtcbiAgICBpZiAodmFsdWUgJiYgbWF4RGF0ZUZpZWxkKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUgJiYgbWF4RGF0ZUZpZWxkIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID4gbWF4RGF0ZUZpZWxkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWVsZC50ZW1wbGF0ZU9wdGlvbnMubWluRGF0ZSAmJiAhKGZpZWxkLnRlbXBsYXRlT3B0aW9ucy5taW5EYXRlIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9SZXR1cm4gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWF4RGF0ZSc6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b1JldHVybiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdiZXR3ZWVuRGF0ZSc6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvUmV0dXJuO1xufVxuXG4iXX0=