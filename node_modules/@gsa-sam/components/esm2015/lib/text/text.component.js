/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, forwardRef, ChangeDetectionStrategy, ChangeDetectorRef } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
export class SdsTextComponent {
    /**
     * @param {?} cd
     */
    constructor(cd) {
        this.cd = cd;
        this.items = [];
        this.multiple = true;
        this._onChange = (/**
         * @param {?} _
         * @return {?}
         */
        (_) => { });
        this._onTouched = (/**
         * @return {?}
         */
        () => { });
    }
    // Helper method to programatically add a value to the existing items array
    /**
     * @param {?} val
     * @return {?}
     */
    addItem(val) {
        if (this.multiple) {
            this.items = [...this.items, val];
            this.updateModel();
        }
    }
    // Method that is fired when the child component event notifies us that the items array has been modified within the child component
    /**
     * @param {?} $event
     * @return {?}
     */
    updateItems($event) {
        this.updateModel();
    }
    // Helper method that gets a new instance of the model and notifies ControlValueAccessor that we have a new model for this FormControl (our custom component)
    /**
     * @return {?}
     */
    updateModel() {
        /** @type {?} */
        const model = this.getModel();
        this._onChange(model);
    }
    // Helper method to return a new instance of an array that contains our items
    /**
     * @return {?}
     */
    getModel() {
        return [...this.items];
    }
    // ControlValueAccessor (and Formly) is trying to update the value of the FormControl (our custom component) programatically
    // If there is a value we will just overwrite items
    // If there is no value we reset the items array to be empty
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value && value.length && this.items !== value) {
            this.items = value;
            this.cd.markForCheck();
        }
        else {
            this.items = [];
            this.cd.markForCheck();
        }
    }
    // ControlValueAccessor hook that lets us call this._onChange(var) to let the form know our variable has changed (in this case model)
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChange = fn;
    }
    // ControlValueAccessor hook (not used)
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
}
SdsTextComponent.decorators = [
    { type: Component, args: [{
                selector: 'sds-text',
                template: `
    <div>
      <input #searchInput class="usa-input display-inline-block" />
      <button class="usa-button margin-left-05 display-inline-block" (click)="addItem(searchInput.value); searchInput.value=''">Add Item</button>
    </div>

    <h4>Component Items</h4>
    <pre>{{ items | json }}</pre>

    <hr />

    <h4>Child Component Items <small>(click to remove)</small></h4>
    <sds-text-child [(items)]="items" (itemsChange)="updateItems($event)"></sds-text-child>
  `,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => SdsTextComponent)),
                        multi: true
                    }
                ],
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
SdsTextComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
if (false) {
    /** @type {?} */
    SdsTextComponent.prototype.items;
    /** @type {?} */
    SdsTextComponent.prototype.multiple;
    /**
     * @type {?}
     * @private
     */
    SdsTextComponent.prototype._onChange;
    /**
     * @type {?}
     * @private
     */
    SdsTextComponent.prototype._onTouched;
    /**
     * @type {?}
     * @private
     */
    SdsTextComponent.prototype.cd;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGV4dC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AZ3NhLXNhbS9jb21wb25lbnRzLyIsInNvdXJjZXMiOlsibGliL3RleHQvdGV4dC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLHVCQUF1QixFQUFFLGlCQUFpQixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2xHLE9BQU8sRUFBd0IsaUJBQWlCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQTJCekUsTUFBTSxPQUFPLGdCQUFnQjs7OztJQVEzQixZQUFvQixFQUFxQjtRQUFyQixPQUFFLEdBQUYsRUFBRSxDQUFtQjtRQU56QyxVQUFLLEdBQUcsRUFBRSxDQUFDO1FBQ1gsYUFBUSxHQUFHLElBQUksQ0FBQztRQUVSLGNBQVM7Ozs7UUFBRyxDQUFDLENBQU0sRUFBRSxFQUFFLEdBQUcsQ0FBQyxFQUFDO1FBQzVCLGVBQVU7OztRQUFHLEdBQUcsRUFBRSxHQUFHLENBQUMsRUFBQztJQUVjLENBQUM7Ozs7OztJQUc5QyxPQUFPLENBQUMsR0FBRztRQUNULElBQUcsSUFBSSxDQUFDLFFBQVEsRUFBQztZQUNmLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUM7WUFDbEMsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO1NBQ3BCO0lBQ0gsQ0FBQzs7Ozs7O0lBR0QsV0FBVyxDQUFDLE1BQU07UUFDaEIsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQ3JCLENBQUM7Ozs7O0lBR0QsV0FBVzs7Y0FDSCxLQUFLLEdBQUcsSUFBSSxDQUFDLFFBQVEsRUFBRTtRQUM3QixJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3hCLENBQUM7Ozs7O0lBR0QsUUFBUTtRQUNOLE9BQU8sQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN6QixDQUFDOzs7Ozs7OztJQUtELFVBQVUsQ0FBQyxLQUFVO1FBQ25CLElBQUcsS0FBSyxJQUFJLEtBQUssQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLEtBQUssS0FBSyxLQUFLLEVBQUU7WUFDaEQsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7WUFDbkIsSUFBSSxDQUFDLEVBQUUsQ0FBQyxZQUFZLEVBQUUsQ0FBQztTQUN4QjthQUFNO1lBQ0wsSUFBSSxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUM7WUFDaEIsSUFBSSxDQUFDLEVBQUUsQ0FBQyxZQUFZLEVBQUUsQ0FBQztTQUN4QjtJQUNILENBQUM7Ozs7OztJQUdELGdCQUFnQixDQUFDLEVBQU87UUFDdEIsSUFBSSxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUM7SUFDdEIsQ0FBQzs7Ozs7O0lBR0QsaUJBQWlCLENBQUMsRUFBTztRQUN2QixJQUFJLENBQUMsVUFBVSxHQUFHLEVBQUUsQ0FBQztJQUN2QixDQUFDOzs7WUFoRkYsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSxVQUFVO2dCQUNwQixRQUFRLEVBQUU7Ozs7Ozs7Ozs7Ozs7R0FhVDtnQkFDRCxTQUFTLEVBQUU7b0JBQ1Q7d0JBQ0UsT0FBTyxFQUFFLGlCQUFpQjt3QkFDMUIsV0FBVyxFQUFFLFVBQVU7Ozt3QkFBQyxHQUFHLEVBQUUsQ0FBQyxnQkFBZ0IsRUFBQzt3QkFDL0MsS0FBSyxFQUFFLElBQUk7cUJBQ1o7aUJBQ0Y7Z0JBQ0QsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07YUFDaEQ7Ozs7WUEzQndELGlCQUFpQjs7OztJQThCeEUsaUNBQVc7O0lBQ1gsb0NBQWdCOzs7OztJQUVoQixxQ0FBb0M7Ozs7O0lBQ3BDLHNDQUErQjs7Ozs7SUFFbkIsOEJBQTZCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBmb3J3YXJkUmVmLCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ2hhbmdlRGV0ZWN0b3JSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnc2RzLXRleHQnLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxkaXY+XG4gICAgICA8aW5wdXQgI3NlYXJjaElucHV0IGNsYXNzPVwidXNhLWlucHV0IGRpc3BsYXktaW5saW5lLWJsb2NrXCIgLz5cbiAgICAgIDxidXR0b24gY2xhc3M9XCJ1c2EtYnV0dG9uIG1hcmdpbi1sZWZ0LTA1IGRpc3BsYXktaW5saW5lLWJsb2NrXCIgKGNsaWNrKT1cImFkZEl0ZW0oc2VhcmNoSW5wdXQudmFsdWUpOyBzZWFyY2hJbnB1dC52YWx1ZT0nJ1wiPkFkZCBJdGVtPC9idXR0b24+XG4gICAgPC9kaXY+XG5cbiAgICA8aDQ+Q29tcG9uZW50IEl0ZW1zPC9oND5cbiAgICA8cHJlPnt7IGl0ZW1zIHwganNvbiB9fTwvcHJlPlxuXG4gICAgPGhyIC8+XG5cbiAgICA8aDQ+Q2hpbGQgQ29tcG9uZW50IEl0ZW1zIDxzbWFsbD4oY2xpY2sgdG8gcmVtb3ZlKTwvc21hbGw+PC9oND5cbiAgICA8c2RzLXRleHQtY2hpbGQgWyhpdGVtcyldPVwiaXRlbXNcIiAoaXRlbXNDaGFuZ2UpPVwidXBkYXRlSXRlbXMoJGV2ZW50KVwiPjwvc2RzLXRleHQtY2hpbGQ+XG4gIGAsXG4gIHByb3ZpZGVyczogW1xuICAgIHtcbiAgICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gU2RzVGV4dENvbXBvbmVudCksXG4gICAgICBtdWx0aTogdHJ1ZVxuICAgIH1cbiAgXSxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgU2RzVGV4dENvbXBvbmVudCBpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yIHtcblxuICBpdGVtcyA9IFtdO1xuICBtdWx0aXBsZSA9IHRydWU7XG5cbiAgcHJpdmF0ZSBfb25DaGFuZ2UgPSAoXzogYW55KSA9PiB7IH07XG4gIHByaXZhdGUgX29uVG91Y2hlZCA9ICgpID0+IHsgfTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNkOiBDaGFuZ2VEZXRlY3RvclJlZikgeyB9XG5cbiAgLy8gSGVscGVyIG1ldGhvZCB0byBwcm9ncmFtYXRpY2FsbHkgYWRkIGEgdmFsdWUgdG8gdGhlIGV4aXN0aW5nIGl0ZW1zIGFycmF5XG4gIGFkZEl0ZW0odmFsKSB7XG4gICAgaWYodGhpcy5tdWx0aXBsZSl7XG4gICAgICB0aGlzLml0ZW1zID0gWy4uLnRoaXMuaXRlbXMsIHZhbF07XG4gICAgICB0aGlzLnVwZGF0ZU1vZGVsKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gTWV0aG9kIHRoYXQgaXMgZmlyZWQgd2hlbiB0aGUgY2hpbGQgY29tcG9uZW50IGV2ZW50IG5vdGlmaWVzIHVzIHRoYXQgdGhlIGl0ZW1zIGFycmF5IGhhcyBiZWVuIG1vZGlmaWVkIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50XG4gIHVwZGF0ZUl0ZW1zKCRldmVudCkge1xuICAgIHRoaXMudXBkYXRlTW9kZWwoKTtcbiAgfVxuXG4gIC8vIEhlbHBlciBtZXRob2QgdGhhdCBnZXRzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBtb2RlbCBhbmQgbm90aWZpZXMgQ29udHJvbFZhbHVlQWNjZXNzb3IgdGhhdCB3ZSBoYXZlIGEgbmV3IG1vZGVsIGZvciB0aGlzIEZvcm1Db250cm9sIChvdXIgY3VzdG9tIGNvbXBvbmVudClcbiAgdXBkYXRlTW9kZWwoKSB7XG4gICAgY29uc3QgbW9kZWwgPSB0aGlzLmdldE1vZGVsKCk7XG4gICAgdGhpcy5fb25DaGFuZ2UobW9kZWwpO1xuICB9XG5cbiAgLy8gSGVscGVyIG1ldGhvZCB0byByZXR1cm4gYSBuZXcgaW5zdGFuY2Ugb2YgYW4gYXJyYXkgdGhhdCBjb250YWlucyBvdXIgaXRlbXNcbiAgZ2V0TW9kZWwoKSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLml0ZW1zXTtcbiAgfVxuXG4gIC8vIENvbnRyb2xWYWx1ZUFjY2Vzc29yIChhbmQgRm9ybWx5KSBpcyB0cnlpbmcgdG8gdXBkYXRlIHRoZSB2YWx1ZSBvZiB0aGUgRm9ybUNvbnRyb2wgKG91ciBjdXN0b20gY29tcG9uZW50KSBwcm9ncmFtYXRpY2FsbHlcbiAgLy8gSWYgdGhlcmUgaXMgYSB2YWx1ZSB3ZSB3aWxsIGp1c3Qgb3ZlcndyaXRlIGl0ZW1zXG4gIC8vIElmIHRoZXJlIGlzIG5vIHZhbHVlIHdlIHJlc2V0IHRoZSBpdGVtcyBhcnJheSB0byBiZSBlbXB0eVxuICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpIHtcbiAgICBpZih2YWx1ZSAmJiB2YWx1ZS5sZW5ndGggJiYgdGhpcy5pdGVtcyAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuaXRlbXMgPSB2YWx1ZTtcbiAgICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaXRlbXMgPSBbXTtcbiAgICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ29udHJvbFZhbHVlQWNjZXNzb3IgaG9vayB0aGF0IGxldHMgdXMgY2FsbCB0aGlzLl9vbkNoYW5nZSh2YXIpIHRvIGxldCB0aGUgZm9ybSBrbm93IG91ciB2YXJpYWJsZSBoYXMgY2hhbmdlZCAoaW4gdGhpcyBjYXNlIG1vZGVsKVxuICByZWdpc3Rlck9uQ2hhbmdlKGZuOiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLl9vbkNoYW5nZSA9IGZuO1xuICB9XG5cbiAgLy8gQ29udHJvbFZhbHVlQWNjZXNzb3IgaG9vayAobm90IHVzZWQpXG4gIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiBhbnkpIHtcbiAgICB0aGlzLl9vblRvdWNoZWQgPSBmbjtcbiAgfVxufVxuIl19