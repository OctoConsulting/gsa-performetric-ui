/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, ElementRef, Input, HostListener, Injector, ViewContainerRef } from '@angular/core';
import { coerceNumberProperty } from '@angular/cdk/coercion';
import { ViewportRuler, OverlayConfig, Overlay } from '@angular/cdk/overlay';
import { Subscription, merge } from 'rxjs';
import { startWith } from 'rxjs/operators';
import { PortalInjector, ComponentPortal } from '@angular/cdk/portal';
import { SdsTruncatedTextContainerComponent } from './truncate-text-container.component';
import { SDS_TRUNCATED_TEXT_DATA } from './truncates-text-base';
export class SdsTruncateTextByLineDirective {
    /**
     * @param {?} _overlay
     * @param {?} _injector
     * @param {?} _element
     * @param {?} _viewportRuler
     * @param {?} _viewContainerRef
     */
    constructor(_overlay, _injector, _element, _viewportRuler, _viewContainerRef) {
        this._overlay = _overlay;
        this._injector = _injector;
        this._element = _element;
        this._viewportRuler = _viewportRuler;
        this._viewContainerRef = _viewContainerRef;
        /**
         * PortalOutlet
         */
        this._overlayRef = null;
        /**
         * Holds subscription to stream of overlay closing events
         */
        this._closingActionsSubscription = Subscription.EMPTY;
    }
    /**
     * Maximum lines of text limit
     * @return {?}
     */
    get textLinesLimit() {
        return this._textLinesLimit;
    }
    /**
     * @param {?} _textLinesLimit
     * @return {?}
     */
    set textLinesLimit(_textLinesLimit) {
        _textLinesLimit = coerceNumberProperty(_textLinesLimit);
        if (this._textLinesLimit !== _textLinesLimit) {
            this._textLinesLimit = _textLinesLimit;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.initialText = this._element.nativeElement.innerText.trim();
        // Clone element to facilitate calculations
        /** @type {?} */
        const hostCloneEl = (/** @type {?} */ (this._element.nativeElement.cloneNode()));
        // Add 1 character to calculate character width
        hostCloneEl.innerHTML = 'x';
        // Render the clone to get character width
        this._element.nativeElement.parentElement.appendChild(hostCloneEl);
        // Set the clone to inline to prevent cases where the clone
        // expands to 100% width of the container
        hostCloneEl.setAttribute('style', 'display: inline');
        // These are close approximations that are used to better guess
        // how many characters fit in X number of lines
        this.approximatedCharacterWidth = hostCloneEl.offsetWidth;
        // Remove clone after calculations
        hostCloneEl.remove();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.windowResize$ = this._viewportRuler
            .change(0)
            .pipe(startWith('Start'))
            .subscribe((/**
         * @return {?}
         */
        () => this.updateUI()));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this._overlayRef) {
            this._overlayRef.dispose();
        }
        this._closingActionsSubscription.unsubscribe();
        this.windowResize$.unsubscribe();
    }
    /**
     * Configures and creates the CDK overlay
     * @private
     * @return {?}
     */
    _createOverlay() {
        /** @type {?} */
        const overlayPositions = {
            originX: 'start',
            originY: 'bottom',
            overlayX: 'start',
            overlayY: 'top'
        };
        /** @type {?} */
        const config = new OverlayConfig({
            positionStrategy: this._overlay
                .position()
                .flexibleConnectedTo(this._element)
                .withLockedPosition()
                .withPositions([overlayPositions])
                .withTransformOriginOn('.sds-overlay'),
            hasBackdrop: true,
            backdropClass: 'cdk-overlay-transparent-backdrop',
            scrollStrategy: this._overlay.scrollStrategies.close()
        });
        return this._overlay.create(config);
    }
    /**
     * Attach a ComponentPortal to the overlay *
     * @private
     * @param {?} overlay
     * @return {?}
     */
    _attachContainer(overlay) {
        /** @type {?} */
        const injector = new PortalInjector(this._injector, new WeakMap([[SDS_TRUNCATED_TEXT_DATA, { text: this.initialText }]]));
        /** @type {?} */
        const containerPortal = new ComponentPortal(SdsTruncatedTextContainerComponent, this._viewContainerRef, injector);
        /** @type {?} */
        const containerRef = overlay.attach(containerPortal);
        return containerRef.instance;
    }
    /**
     * Returns a stream that emits whenever an action that should close the overlay occurs.
     * @private
     * @return {?}
     */
    _overlayClosingActions() {
        /** @type {?} */
        const backdrop = this._overlayRef.backdropClick();
        /** @type {?} */
        const detachments = this._overlayRef.detachments();
        return merge(backdrop, detachments);
    }
    /**
     * Width of host element
     * @private
     * @return {?}
     */
    _getHostWidth() {
        return this._element.nativeElement.offsetWidth;
    }
    /**
     * Approximated number of characters that are visible in the container
     * @private
     * @return {?}
     */
    _getVisibleCharacters() {
        return Math.floor((this._getHostWidth() / this.approximatedCharacterWidth) *
            this.textLinesLimit);
    }
    /**
     * @private
     * @return {?}
     */
    _isNotLongEnough() {
        return this._getVisibleCharacters() > this.initialText.length;
    }
    /**
     * @return {?}
     */
    openOverlay() {
        // Exit if all text can be visible in container
        if (this._isNotLongEnough())
            return;
        this._overlayRef = this._createOverlay();
        /** @type {?} */
        const container = this._attachContainer(this._overlayRef);
        this._closingActionsSubscription = this._overlayClosingActions().subscribe((/**
         * @return {?}
         */
        () => this.closeOverlay()));
        // Wait for the next event loop tick to start the animation
        setTimeout((/**
         * @return {?}
         */
        () => {
            container.startAnimation();
        }));
    }
    /**
     * @return {?}
     */
    updateUI() {
        // Exit if all text can be visible in container
        if (this._isNotLongEnough())
            return;
        /** @type {?} */
        const wordCut = false;
        /** @type {?} */
        const ellipsis = '...';
        /** @type {?} */
        const limit = this._getVisibleCharacters() - ellipsis.length;
        /** @type {?} */
        let visibleText = this.initialText.slice(0, limit);
        if (!wordCut) {
            /** @type {?} */
            const isEndofWord = this.initialText.substr(limit, limit + 1) === ' ';
            if (!isEndofWord) {
                /** @type {?} */
                const previousWord = visibleText.lastIndexOf(' ');
                visibleText = visibleText.slice(0, previousWord);
            }
        }
        this._element.nativeElement.innerText = visibleText + ellipsis;
    }
    /**
     * @return {?}
     */
    closeOverlay() {
        this._closingActionsSubscription.unsubscribe();
        this._overlayRef.detach();
    }
}
SdsTruncateTextByLineDirective.decorators = [
    { type: Directive, args: [{ selector: '[sdsTruncateTextByLine]' },] }
];
/** @nocollapse */
SdsTruncateTextByLineDirective.ctorParameters = () => [
    { type: Overlay },
    { type: Injector },
    { type: ElementRef },
    { type: ViewportRuler },
    { type: ViewContainerRef }
];
SdsTruncateTextByLineDirective.propDecorators = {
    textLinesLimit: [{ type: Input, args: ['sdsTruncateTextByLine',] }],
    openOverlay: [{ type: HostListener, args: ['click',] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    SdsTruncateTextByLineDirective.prototype._textLinesLimit;
    /**
     * PortalOutlet
     * @type {?}
     * @private
     */
    SdsTruncateTextByLineDirective.prototype._overlayRef;
    /**
     * Holds subscription to stream of overlay closing events
     * @type {?}
     * @private
     */
    SdsTruncateTextByLineDirective.prototype._closingActionsSubscription;
    /**
     * Holds initial text
     * @type {?}
     * @private
     */
    SdsTruncateTextByLineDirective.prototype.initialText;
    /**
     * Subscription to window resize stream
     * @type {?}
     */
    SdsTruncateTextByLineDirective.prototype.windowResize$;
    /**
     * Approximated character width of the host text
     * @type {?}
     * @private
     */
    SdsTruncateTextByLineDirective.prototype.approximatedCharacterWidth;
    /**
     * @type {?}
     * @private
     */
    SdsTruncateTextByLineDirective.prototype._overlay;
    /**
     * @type {?}
     * @private
     */
    SdsTruncateTextByLineDirective.prototype._injector;
    /**
     * @type {?}
     * @private
     */
    SdsTruncateTextByLineDirective.prototype._element;
    /**
     * @type {?}
     * @private
     */
    SdsTruncateTextByLineDirective.prototype._viewportRuler;
    /**
     * @type {?}
     * @private
     */
    SdsTruncateTextByLineDirective.prototype._viewContainerRef;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJ1bmNhdGUtdGV4dC5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AZ3NhLXNhbS9jb21wb25lbnRzLyIsInNvdXJjZXMiOlsibGliL3RydW5jYXRlLXRleHQvdHJ1bmNhdGUtdGV4dC5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFDTCxTQUFTLEVBQ1QsVUFBVSxFQUVWLEtBQUssRUFHTCxZQUFZLEVBQ1osUUFBUSxFQUNSLGdCQUFnQixFQUNqQixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUM3RCxPQUFPLEVBQ0wsYUFBYSxFQUNiLGFBQWEsRUFDYixPQUFPLEVBR1IsTUFBTSxzQkFBc0IsQ0FBQztBQUM5QixPQUFPLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMzQyxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDM0MsT0FBTyxFQUFFLGNBQWMsRUFBRSxlQUFlLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUN0RSxPQUFPLEVBQUUsa0NBQWtDLEVBQUUsTUFBTSxxQ0FBcUMsQ0FBQztBQUN6RixPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUdoRSxNQUFNLE9BQU8sOEJBQThCOzs7Ozs7OztJQThCekMsWUFDVSxRQUFpQixFQUNqQixTQUFtQixFQUNuQixRQUFvQixFQUNwQixjQUE2QixFQUM3QixpQkFBbUM7UUFKbkMsYUFBUSxHQUFSLFFBQVEsQ0FBUztRQUNqQixjQUFTLEdBQVQsU0FBUyxDQUFVO1FBQ25CLGFBQVEsR0FBUixRQUFRLENBQVk7UUFDcEIsbUJBQWMsR0FBZCxjQUFjLENBQWU7UUFDN0Isc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFrQjs7OztRQW5CckMsZ0JBQVcsR0FBc0IsSUFBSSxDQUFDOzs7O1FBR3RDLGdDQUEyQixHQUFH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T0FBTztZQVBQLFFBQVE7WUFOUixVQUFVO1lBV1YsYUFBYTtZQUpiLGdCQUFnQjs7OzZCQW9CZixLQUFLLFNBQUMsdUJBQXVCOzBCQXdJN0IsWUFBWSxTQUFDLE9BQU87Ozs7Ozs7SUE5SHJCLHlEQUFnQzs7Ozs7O0lBR2hDLHFEQUE4Qzs7Ozs7O0lBRzlDLHFFQUF5RDs7Ozs7O0lBR3pELHFEQUE0Qjs7Ozs7SUFHNUIsdURBQTRCOzs7Ozs7SUFHNUIsb0VBQTJDOzs7OztJQUd6QyxrREFBeUI7Ozs7O0lBQ3pCLG1EQUEyQjs7Ozs7SUFDM0Isa0RBQTRCOzs7OztJQUM1Qix3REFBcUM7Ozs7O0lBQ3JDLDJEQUEyQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIERpcmVjdGl2ZSxcbiAgRWxlbWVudFJlZixcbiAgT25Jbml0LFxuICBJbnB1dCxcbiAgT25EZXN0cm95LFxuICBBZnRlclZpZXdJbml0LFxuICBIb3N0TGlzdGVuZXIsXG4gIEluamVjdG9yLFxuICBWaWV3Q29udGFpbmVyUmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgY29lcmNlTnVtYmVyUHJvcGVydHkgfSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xuaW1wb3J0IHtcbiAgVmlld3BvcnRSdWxlcixcbiAgT3ZlcmxheUNvbmZpZyxcbiAgT3ZlcmxheSxcbiAgT3ZlcmxheVJlZixcbiAgQ29ubmVjdGVkUG9zaXRpb25cbn0gZnJvbSAnQGFuZ3VsYXIvY2RrL292ZXJsYXknO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uLCBtZXJnZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgc3RhcnRXaXRoIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgUG9ydGFsSW5qZWN0b3IsIENvbXBvbmVudFBvcnRhbCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9wb3J0YWwnO1xuaW1wb3J0IHsgU2RzVHJ1bmNhdGVkVGV4dENvbnRhaW5lckNvbXBvbmVudCB9IGZyb20gJy4vdHJ1bmNhdGUtdGV4dC1jb250YWluZXIuY29tcG9uZW50JztcbmltcG9ydCB7IFNEU19UUlVOQ0FURURfVEVYVF9EQVRBIH0gZnJvbSAnLi90cnVuY2F0ZXMtdGV4dC1iYXNlJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW3Nkc1RydW5jYXRlVGV4dEJ5TGluZV0nIH0pXG5leHBvcnQgY2xhc3MgU2RzVHJ1bmNhdGVUZXh0QnlMaW5lRGlyZWN0aXZlXG4gIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3ksIEFmdGVyVmlld0luaXQge1xuICAvKiogTWF4aW11bSBsaW5lcyBvZiB0ZXh0IGxpbWl0ICovXG4gIEBJbnB1dCgnc2RzVHJ1bmNhdGVUZXh0QnlMaW5lJylcbiAgZ2V0IHRleHRMaW5lc0xpbWl0KCk6IGFueSB7XG4gICAgcmV0dXJuIHRoaXMuX3RleHRMaW5lc0xpbWl0O1xuICB9XG4gIHNldCB0ZXh0TGluZXNMaW1pdChfdGV4dExpbmVzTGltaXQ6IGFueSkge1xuICAgIF90ZXh0TGluZXNMaW1pdCA9IGNvZXJjZU51bWJlclByb3BlcnR5KF90ZXh0TGluZXNMaW1pdCk7XG4gICAgaWYgKHRoaXMuX3RleHRMaW5lc0xpbWl0ICE9PSBfdGV4dExpbmVzTGltaXQpIHtcbiAgICAgIHRoaXMuX3RleHRMaW5lc0xpbWl0ID0gX3RleHRMaW5lc0xpbWl0O1xuICAgIH1cbiAgfVxuICBwcml2YXRlIF90ZXh0TGluZXNMaW1pdDogbnVtYmVyO1xuXG4gIC8qKiBQb3J0YWxPdXRsZXQgKi9cbiAgcHJpdmF0ZSBfb3ZlcmxheVJlZjogT3ZlcmxheVJlZiB8IG51bGwgPSBudWxsO1xuXG4gIC8qKiBIb2xkcyBzdWJzY3JpcHRpb24gdG8gc3RyZWFtIG9mIG92ZXJsYXkgY2xvc2luZyBldmVudHMgKi9cbiAgcHJpdmF0ZSBfY2xvc2luZ0FjdGlvbnNTdWJzY3JpcHRpb24gPSBTdWJzY3JpcHRpb24uRU1QVFk7XG5cbiAgLyoqIEhvbGRzIGluaXRpYWwgdGV4dCAqL1xuICBwcml2YXRlIGluaXRpYWxUZXh0OiBzdHJpbmc7XG5cbiAgLyoqIFN1YnNjcmlwdGlvbiB0byB3aW5kb3cgcmVzaXplIHN0cmVhbSAqL1xuICB3aW5kb3dSZXNpemUkOiBTdWJzY3JpcHRpb247XG5cbiAgLyoqIEFwcHJveGltYXRlZCBjaGFyYWN0ZXIgd2lkdGggb2YgdGhlIGhvc3QgdGV4dCAqL1xuICBwcml2YXRlIGFwcHJveGltYXRlZENoYXJhY3RlcldpZHRoOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBfb3ZlcmxheTogT3ZlcmxheSxcbiAgICBwcml2YXRlIF9pbmplY3RvcjogSW5qZWN0b3IsXG4gICAgcHJpdmF0ZSBfZWxlbWVudDogRWxlbWVudFJlZixcbiAgICBwcml2YXRlIF92aWV3cG9ydFJ1bGVyOiBWaWV3cG9ydFJ1bGVyLFxuICAgIHByaXZhdGUgX3ZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWZcbiAgKSB7fVxuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMuaW5pdGlhbFRleHQgPSB0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuaW5uZXJUZXh0LnRyaW0oKTtcblxuICAgIC8vIENsb25lIGVsZW1lbnQgdG8gZmFjaWxpdGF0ZSBjYWxjdWxhdGlvbnNcbiAgICBjb25zdCBob3N0Q2xvbmVFbCA9IHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudC5jbG9uZU5vZGUoKSBhcyBIVE1MRWxlbWVudDtcblxuICAgIC8vIEFkZCAxIGNoYXJhY3RlciB0byBjYWxjdWxhdGUgY2hhcmFjdGVyIHdpZHRoXG4gICAgaG9zdENsb25lRWwuaW5uZXJIVE1MID0gJ3gnO1xuXG4gICAgLy8gUmVuZGVyIHRoZSBjbG9uZSB0byBnZXQgY2hhcmFjdGVyIHdpZHRoXG4gICAgdGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LnBhcmVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoaG9zdENsb25lRWwpO1xuXG4gICAgLy8gU2V0IHRoZSBjbG9uZSB0byBpbmxpbmUgdG8gcHJldmVudCBjYXNlcyB3aGVyZSB0aGUgY2xvbmVcbiAgICAvLyBleHBhbmRzIHRvIDEwMCUgd2lkdGggb2YgdGhlIGNvbnRhaW5lclxuICAgIGhvc3RDbG9uZUVsLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTogaW5saW5lJyk7XG5cbiAgICAvLyBUaGVzZSBhcmUgY2xvc2UgYXBwcm94aW1hdGlvbnMgdGhhdCBhcmUgdXNlZCB0byBiZXR0ZXIgZ3Vlc3NcbiAgICAvLyBob3cgbWFueSBjaGFyYWN0ZXJzIGZpdCBpbiBYIG51bWJlciBvZiBsaW5lc1xuICAgIHRoaXMuYXBwcm94aW1hdGVkQ2hhcmFjdGVyV2lkdGggPSBob3N0Q2xvbmVFbC5vZmZzZXRXaWR0aDtcblxuICAgIC8vIFJlbW92ZSBjbG9uZSBhZnRlciBjYWxjdWxhdGlvbnNcbiAgICBob3N0Q2xvbmVFbC5yZW1vdmUoKTtcbiAgfVxuXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICB0aGlzLndpbmRvd1Jlc2l6ZSQgPSB0aGlzLl92aWV3cG9ydFJ1bGVyXG4gICAgICAuY2hhbmdlKDApXG4gICAgICAucGlwZShzdGFydFdpdGgoJ1N0YXJ0JykpXG4gICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMudXBkYXRlVUkoKSk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgdGhpcy5fb3ZlcmxheVJlZi5kaXNwb3NlKCk7XG4gICAgfVxuICAgIHRoaXMuX2Nsb3NpbmdBY3Rpb25zU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgdGhpcy53aW5kb3dSZXNpemUkLnVuc3Vic2NyaWJlKCk7XG4gIH1cblxuICAvKiogQ29uZmlndXJlcyBhbmQgY3JlYXRlcyB0aGUgQ0RLIG92ZXJsYXkgKi9cbiAgcHJpdmF0ZSBfY3JlYXRlT3ZlcmxheSgpIHtcbiAgICBjb25zdCBvdmVybGF5UG9zaXRpb25zOiBDb25uZWN0ZWRQb3NpdGlvbiA9IHtcbiAgICAgIG9yaWdpblg6ICdzdGFydCcsXG4gICAgICBvcmlnaW5ZOiAnYm90dG9tJyxcbiAgICAgIG92ZXJsYXlYOiAnc3RhcnQnLFxuICAgICAgb3ZlcmxheVk6ICd0b3AnXG4gICAgfTtcbiAgICBjb25zdCBjb25maWcgPSBuZXcgT3ZlcmxheUNvbmZpZyh7XG4gICAgICBwb3NpdGlvblN0cmF0ZWd5OiB0aGlzLl9vdmVybGF5XG4gICAgICAgIC5wb3NpdGlvbigpXG4gICAgICAgIC5mbGV4aWJsZUNvbm5lY3RlZFRvKHRoaXMuX2VsZW1lbnQpXG4gICAgICAgIC53aXRoTG9ja2VkUG9zaXRpb24oKVxuICAgICAgICAud2l0aFBvc2l0aW9ucyhbb3ZlcmxheVBvc2l0aW9uc10pXG4gICAgICAgIC53aXRoVHJhbnNmb3JtT3JpZ2luT24oJy5zZHMtb3ZlcmxheScpLFxuICAgICAgaGFzQmFja2Ryb3A6IHRydWUsXG4gICAgICBiYWNrZHJvcENsYXNzOiAnY2RrLW92ZXJsYXktdHJhbnNwYXJlbnQtYmFja2Ryb3AnLFxuICAgICAgc2Nyb2xsU3RyYXRlZ3k6IHRoaXMuX292ZXJsYXkuc2Nyb2xsU3RyYXRlZ2llcy5jbG9zZSgpXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuX292ZXJsYXkuY3JlYXRlKGNvbmZpZyk7XG4gIH1cblxuICAvKiogQXR0YWNoIGEgQ29tcG9uZW50UG9ydGFsIHRvIHRoZSBvdmVybGF5ICoqL1xuICBwcml2YXRlIF9hdHRhY2hDb250YWluZXIob3ZlcmxheTogT3ZlcmxheVJlZikge1xuICAgIGNvbnN0IGluamVjdG9yID0gbmV3IFBvcnRhbEluamVjdG9yKFxuICAgICAgdGhpcy5faW5qZWN0b3IsXG4gICAgICBuZXcgV2Vha01hcChbW1NEU19UUlVOQ0FURURfVEVYVF9EQVRBLCB7IHRleHQ6IHRoaXMuaW5pdGlhbFRleHQgfV1dKVxuICAgICk7XG4gICAgY29uc3QgY29udGFpbmVyUG9ydGFsID0gbmV3IENvbXBvbmVudFBvcnRhbChcbiAgICAgIFNkc1RydW5jYXRlZFRleHRDb250YWluZXJDb21wb25lbnQsXG4gICAgICB0aGlzLl92aWV3Q29udGFpbmVyUmVmLFxuICAgICAgaW5qZWN0b3JcbiAgICApO1xuICAgIGNvbnN0IGNvbnRhaW5lclJlZiA9IG92ZXJsYXkuYXR0YWNoKGNvbnRhaW5lclBvcnRhbCk7XG5cbiAgICByZXR1cm4gY29udGFpbmVyUmVmLmluc3RhbmNlO1xuICB9XG5cbiAgLyoqIFJldHVybnMgYSBzdHJlYW0gdGhhdCBlbWl0cyB3aGVuZXZlciBhbiBhY3Rpb24gdGhhdCBzaG91bGQgY2xvc2UgdGhlIG92ZXJsYXkgb2NjdXJzLiAqL1xuICBwcml2YXRlIF9vdmVybGF5Q2xvc2luZ0FjdGlvbnMoKSB7XG4gICAgY29uc3QgYmFja2Ryb3AgPSB0aGlzLl9vdmVybGF5UmVmLmJhY2tkcm9wQ2xpY2soKTtcbiAgICBjb25zdCBkZXRhY2htZW50cyA9IHRoaXMuX292ZXJsYXlSZWYuZGV0YWNobWVudHMoKTtcbiAgICByZXR1cm4gbWVyZ2UoYmFja2Ryb3AsIGRldGFjaG1lbnRzKTtcbiAgfVxuXG4gIC8qKiBXaWR0aCBvZiBob3N0IGVsZW1lbnQgKi9cbiAgcHJpdmF0ZSBfZ2V0SG9zdFdpZHRoKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgfVxuXG4gIC8qKiBBcHByb3hpbWF0ZWQgbnVtYmVyIG9mIGNoYXJhY3RlcnMgdGhhdCBhcmUgdmlzaWJsZSBpbiB0aGUgY29udGFpbmVyICovXG4gIHByaXZhdGUgX2dldFZpc2libGVDaGFyYWN0ZXJzKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoXG4gICAgICAodGhpcy5fZ2V0SG9zdFdpZHRoKCkgLyB0aGlzLmFwcHJveGltYXRlZENoYXJhY3RlcldpZHRoKSAqXG4gICAgICAgIHRoaXMudGV4dExpbmVzTGltaXRcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBfaXNOb3RMb25nRW5vdWdoKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9nZXRWaXNpYmxlQ2hhcmFjdGVycygpID4gdGhpcy5pbml0aWFsVGV4dC5sZW5ndGg7XG4gIH1cblxuICBASG9zdExpc3RlbmVyKCdjbGljaycpXG4gIG9wZW5PdmVybGF5KCk6IHZvaWQge1xuICAgIC8vIEV4aXQgaWYgYWxsIHRleHQgY2FuIGJlIHZpc2libGUgaW4gY29udGFpbmVyXG4gICAgaWYgKHRoaXMuX2lzTm90TG9uZ0Vub3VnaCgpKSByZXR1cm47XG5cbiAgICB0aGlzLl9vdmVybGF5UmVmID0gdGhpcy5fY3JlYXRlT3ZlcmxheSgpO1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuX2F0dGFjaENvbnRhaW5lcih0aGlzLl9vdmVybGF5UmVmKTtcbiAgICB0aGlzLl9jbG9zaW5nQWN0aW9uc1N1YnNjcmlwdGlvbiA9IHRoaXMuX292ZXJsYXlDbG9zaW5nQWN0aW9ucygpLnN1YnNjcmliZShcbiAgICAgICgpID0+IHRoaXMuY2xvc2VPdmVybGF5KClcbiAgICApO1xuICAgIC8vIFdhaXQgZm9yIHRoZSBuZXh0IGV2ZW50IGxvb3AgdGljayB0byBzdGFydCB0aGUgYW5pbWF0aW9uXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjb250YWluZXIuc3RhcnRBbmltYXRpb24oKTtcbiAgICB9KTtcbiAgfVxuXG4gIHVwZGF0ZVVJKCkge1xuICAgIC8vIEV4aXQgaWYgYWxsIHRleHQgY2FuIGJlIHZpc2libGUgaW4gY29udGFpbmVyXG4gICAgaWYgKHRoaXMuX2lzTm90TG9uZ0Vub3VnaCgpKSByZXR1cm47XG5cbiAgICBjb25zdCB3b3JkQ3V0ID0gZmFsc2U7XG4gICAgY29uc3QgZWxsaXBzaXMgPSAnLi4uJztcbiAgICBjb25zdCBsaW1pdCA9IHRoaXMuX2dldFZpc2libGVDaGFyYWN0ZXJzKCkgLSBlbGxpcHNpcy5sZW5ndGg7XG5cbiAgICBsZXQgdmlzaWJsZVRleHQgPSB0aGlzLmluaXRpYWxUZXh0LnNsaWNlKDAsIGxpbWl0KTtcblxuICAgIGlmICghd29yZEN1dCkge1xuICAgICAgY29uc3QgaXNFbmRvZldvcmQgPSB0aGlzLmluaXRpYWxUZXh0LnN1YnN0cihsaW1pdCwgbGltaXQgKyAxKSA9PT0gJyAnO1xuICAgICAgaWYgKCFpc0VuZG9mV29yZCkge1xuICAgICAgICBjb25zdCBwcmV2aW91c1dvcmQgPSB2aXNpYmxlVGV4dC5sYXN0SW5kZXhPZignICcpO1xuICAgICAgICB2aXNpYmxlVGV4dCA9IHZpc2libGVUZXh0LnNsaWNlKDAsIHByZXZpb3VzV29yZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LmlubmVyVGV4dCA9IHZpc2libGVUZXh0ICsgZWxsaXBzaXM7XG4gIH1cblxuICBjbG9zZU92ZXJsYXkoKSB7XG4gICAgdGhpcy5fY2xvc2luZ0FjdGlvbnNTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB0aGlzLl9vdmVybGF5UmVmLmRldGFjaCgpO1xuICB9XG59XG4iXX0=