/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, Output, EventEmitter, ElementRef } from '@angular/core';
import { ViewportRuler } from '@angular/cdk/overlay';
import { startWith } from 'rxjs/operators';
/**
 * Directive that triggers a callback whenever the width of
 * its associated element has changed.
 */
export class SdsObserveWidthDirective {
    /**
     * @param {?} _elementRef
     * @param {?} viewportRuler
     */
    constructor(_elementRef, viewportRuler) {
        this._elementRef = _elementRef;
        this.viewportRuler = viewportRuler;
        /**
         * Event emitted for each change in the element's width.
         */
        this.elementWidth = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.windowResize$ = this.viewportRuler
            .change(0)
            .pipe(startWith(this._getElementWidth()))
            .subscribe((/**
         * @return {?}
         */
        () => this._emitEvent()));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.windowResize$.unsubscribe();
    }
    /**
     * @return {?}
     */
    _emitEvent() {
        /** @type {?} */
        const width = this._getElementWidth();
        this.elementWidth.emit(width);
    }
    /**
     * @return {?}
     */
    _getElementWidth() {
        return this._elementRef.nativeElement.offsetWidth;
    }
}
SdsObserveWidthDirective.decorators = [
    { type: Directive, args: [{ selector: '[sdsObserveWidth]' },] }
];
/** @nocollapse */
SdsObserveWidthDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ViewportRuler }
];
SdsObserveWidthDirective.propDecorators = {
    elementWidth: [{ type: Output, args: ['sdsObserveWidth',] }]
};
if (false) {
    /**
     * Event emitted for each change in the element's width.
     * @type {?}
     */
    SdsObserveWidthDirective.prototype.elementWidth;
    /**
     * Subscription to window resize stream
     * @type {?}
     */
    SdsObserveWidthDirective.prototype.windowResize$;
    /**
     * @type {?}
     * @private
     */
    SdsObserveWidthDirective.prototype._elementRef;
    /**
     * @type {?}
     * @private
     */
    SdsObserveWidthDirective.prototype.viewportRuler;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2JzZXJ2ZS13aWR0aC5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AZ3NhLXNhbS9jb21wb25lbnRzLyIsInNvdXJjZXMiOlsibGliL29ic2VydmVycy9vYnNlcnZlLXdpZHRoLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUNMLFNBQVMsRUFDVCxNQUFNLEVBQ04sWUFBWSxFQUNaLFVBQVUsRUFHWCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDckQsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7OztBQVEzQyxNQUFNLE9BQU8sd0JBQXdCOzs7OztJQU9uQyxZQUNVLFdBQW9DLEVBQ3BDLGFBQTRCO1FBRDVCLGdCQUFXLEdBQVgsV0FBVyxDQUF5QjtRQUNwQyxrQkFBYSxHQUFiLGFBQWEsQ0FBZTs7OztRQVBYLGlCQUFZLEdBQUcsSUFBSSxZQUFZLEVBQVUsQ0FBQztJQVFsRSxDQUFDOzs7O0lBRUosUUFBUTtRQUNOLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLGFBQWE7YUFDcEMsTUFBTSxDQUFDLENBQUMsQ0FBQzthQUNULElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUMsQ0FBQzthQUN4QyxTQUFTOzs7UUFBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLEVBQUMsQ0FBQztJQUN4QyxDQUFDOzs7O0lBRUQsV0FBVztRQUNULElBQUksQ0FBQyxhQUFhLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDbkMsQ0FBQzs7OztJQUVELFVBQVU7O2NBQ0YsS0FBSyxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsRUFBRTtRQUNyQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNoQyxDQUFDOzs7O0lBRUQsZ0JBQWdCO1FBQ2QsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLGFBQWEsQ0FBQyxXQUFXLENBQUM7SUFDcEQsQ0FBQzs7O1lBL0JGLFNBQVMsU0FBQyxFQUFFLFFBQVEsRUFBRSxtQkFBbUIsRUFBRTs7OztZQVoxQyxVQUFVO1lBSUgsYUFBYTs7OzJCQVduQixNQUFNLFNBQUMsaUJBQWlCOzs7Ozs7O0lBQXpCLGdEQUFxRTs7Ozs7SUFHckUsaURBQTRCOzs7OztJQUcxQiwrQ0FBNEM7Ozs7O0lBQzVDLGlEQUFvQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIERpcmVjdGl2ZSxcbiAgT3V0cHV0LFxuICBFdmVudEVtaXR0ZXIsXG4gIEVsZW1lbnRSZWYsXG4gIE9uSW5pdCxcbiAgT25EZXN0cm95XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVmlld3BvcnRSdWxlciB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9vdmVybGF5JztcbmltcG9ydCB7IHN0YXJ0V2l0aCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG4vKipcbiAqIERpcmVjdGl2ZSB0aGF0IHRyaWdnZXJzIGEgY2FsbGJhY2sgd2hlbmV2ZXIgdGhlIHdpZHRoIG9mXG4gKiBpdHMgYXNzb2NpYXRlZCBlbGVtZW50IGhhcyBjaGFuZ2VkLlxuICovXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbc2RzT2JzZXJ2ZVdpZHRoXScgfSlcbmV4cG9ydCBjbGFzcyBTZHNPYnNlcnZlV2lkdGhEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG4gIC8qKiBFdmVudCBlbWl0dGVkIGZvciBlYWNoIGNoYW5nZSBpbiB0aGUgZWxlbWVudCdzIHdpZHRoLiAqL1xuICBAT3V0cHV0KCdzZHNPYnNlcnZlV2lkdGgnKSBlbGVtZW50V2lkdGggPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oKTtcblxuICAvKiogU3Vic2NyaXB0aW9uIHRvIHdpbmRvdyByZXNpemUgc3RyZWFtICovXG4gIHdpbmRvd1Jlc2l6ZSQ6IFN1YnNjcmlwdGlvbjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PixcbiAgICBwcml2YXRlIHZpZXdwb3J0UnVsZXI6IFZpZXdwb3J0UnVsZXJcbiAgKSB7fVxuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMud2luZG93UmVzaXplJCA9IHRoaXMudmlld3BvcnRSdWxlclxuICAgICAgLmNoYW5nZSgwKVxuICAgICAgLnBpcGUoc3RhcnRXaXRoKHRoaXMuX2dldEVsZW1lbnRXaWR0aCgpKSlcbiAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5fZW1pdEV2ZW50KCkpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy53aW5kb3dSZXNpemUkLnVuc3Vic2NyaWJlKCk7XG4gIH1cblxuICBfZW1pdEV2ZW50KCkge1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy5fZ2V0RWxlbWVudFdpZHRoKCk7XG4gICAgdGhpcy5lbGVtZW50V2lkdGguZW1pdCh3aWR0aCk7XG4gIH1cblxuICBfZ2V0RWxlbWVudFdpZHRoKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgfVxufVxuIl19