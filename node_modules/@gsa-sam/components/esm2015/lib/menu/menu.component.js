/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ChangeDetectionStrategy, Component, ElementRef, EventEmitter, InjectionToken, Input, Output, TemplateRef, ViewChild, ViewEncapsulation } from '@angular/core';
import { ESCAPE, DOWN_ARROW, UP_ARROW, HOME, END, hasModifierKey } from '@angular/cdk/keycodes';
import { FocusKeyManager } from '@angular/cdk/a11y';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { Subscription } from 'rxjs';
import { sdsMenuAnimations } from './menu-animations';
/**
 * Injection token used to provide the parent menu to menu items.
 * @type {?}
 */
export const SDS_MENU_TOKEN = new InjectionToken('SDS_MENU_TOKEN');
/**
 * Menu Interface
 * @record
 * @template T
 */
export function SdsMenuInterface() { }
if (false) {
    /** @type {?} */
    SdsMenuInterface.prototype.xPosition;
    /** @type {?} */
    SdsMenuInterface.prototype.yPosition;
    /** @type {?} */
    SdsMenuInterface.prototype.overlapTrigger;
    /** @type {?} */
    SdsMenuInterface.prototype.templateRef;
    /** @type {?} */
    SdsMenuInterface.prototype.closed;
    /** @type {?|undefined} */
    SdsMenuInterface.prototype.parentMenu;
    /** @type {?|undefined} */
    SdsMenuInterface.prototype.size;
    /** @type {?} */
    SdsMenuInterface.prototype.focusFirstItem;
    /** @type {?|undefined} */
    SdsMenuInterface.prototype.setPositionClasses;
    /** @type {?|undefined} */
    SdsMenuInterface.prototype.addItem;
    /** @type {?|undefined} */
    SdsMenuInterface.prototype.insertItem;
    /** @type {?|undefined} */
    SdsMenuInterface.prototype.removeItem;
}
export class SdsMenuComponent {
    /**
     * @param {?} _elementRef
     */
    constructor(_elementRef) {
        this._elementRef = _elementRef;
        /**
         * After | Before the menu triger element
         */
        this._xPosition = 'after';
        /**
         * Above | Below the menu triger element
         */
        this._yPosition = 'below';
        /**
         * Menu items inside the current menu.
         */
        this._items = [];
        /**
         * Subscription to tab events on the menu panel
         */
        this._tabSubscription = Subscription.EMPTY;
        /**
         * Config object to be passed into the menu's ngClass
         */
        this._classList = {};
        /**
         * Current state of the panel animation.
         */
        this._panelAnimationState = 'void';
        this._overlapTrigger = false;
        /**
         * Event emitted when the menu is closed.
         */
        this.closed = new EventEmitter();
    }
    /**
     * Position of the menu in the X axis.
     * @return {?}
     */
    get xPosition() {
        return this._xPosition;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set xPosition(value) {
        this._xPosition = value;
        this.setPositionClasses();
    }
    /**
     * Position of the menu in the Y axis.
     * @return {?}
     */
    get yPosition() {
        return this._yPosition;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set yPosition(value) {
        this._yPosition = value;
        this.setPositionClasses();
    }
    /**
     * Whether menu panel overlaps trigger element
     * @return {?}
     */
    get overlapTrigger() {
        return this._overlapTrigger;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set overlapTrigger(value) {
        this._overlapTrigger = coerceBooleanProperty(value);
    }
    /**
     * Transfer classes from the sds-menu to the overlay container
     * @param {?} classes
     * @return {?}
     */
    set panelClass(classes) {
        /** @type {?} */
        const previousPanelClass = this._previousPanelClass;
        // Remove previous classes from current set of classes
        if (previousPanelClass && previousPanelClass.length) {
            previousPanelClass.split(' ').forEach((/**
             * @param {?} className
             * @return {?}
             */
            (className) => {
                this._classList[className] = false;
            }));
        }
        this._previousPanelClass = classes;
        // Adds new classes to current set of classes
        if (classes && classes.length) {
            classes.split(' ').forEach((/**
             * @param {?} className
             * @return {?}
             */
            (className) => {
                this._classList[className] = true;
            }));
            // Remove all classes from <sds-menu>
            this._elementRef.nativeElement.className = '';
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setPositionClasses();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this._keyManager = new FocusKeyManager(this._items).withWrap();
        this._tabSubscription = this._keyManager.tabOut.subscribe((/**
         * @return {?}
         */
        () => this.closed.emit('tab')));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._tabSubscription.unsubscribe();
        this.closed.complete();
    }
    /**
     * Focus the first item in the menu
     * @param {?=} origin
     * @return {?}
     */
    focusFirstItem(origin = 'program') {
        this._keyManager.setFocusOrigin(origin).setFirstItemActive();
    }
    /**
     * Adds classes to the menu panel based on its position
     * @param {?=} posX
     * @param {?=} posY
     * @return {?}
     */
    setPositionClasses(posX = this.xPosition, posY = this.yPosition) {
        /** @type {?} */
        const classes = this._classList;
        classes['sds-menu-before'] = posX === 'before';
        classes['sds-menu-after'] = posX === 'after';
        classes['sds-menu-above'] = posY === 'above';
        classes['sds-menu-below'] = posY === 'below';
    }
    /**
     * Adds a menu item with the menu.
     * @param {?} item
     * @return {?}
     */
    addItem(item) {
        if (this._items.indexOf(item) === -1) {
            this._items.push(item);
        }
    }
    /**
     * Inserts a menu item at an index
     * @param {?} item
     * @param {?} index
     * @return {?}
     */
    insertItem(item, index) {
        if (this._items.indexOf(item) === -1 && index < this._items.length) {
            this._items.splice(index, 0, item);
        }
    }
    /**
     * Removes an item from the menu.
     * @param {?} item
     * @return {?}
     */
    removeItem(item) {
        /** @type {?} */
        const index = this._items.indexOf(item);
        if (this._items.indexOf(item) > -1) {
            this._items.splice(index, 1);
        }
    }
    /**
     * Handle a keyboard event from the menu
     * @param {?} event
     * @return {?}
     */
    _handleKeydown(event) {
        // tslint:disable-next-line: deprecation
        /** @type {?} */
        const keyCode = event.keyCode;
        /** @type {?} */
        const manager = this._keyManager;
        switch (keyCode) {
            case ESCAPE:
                this.closed.emit('keydown');
                break;
            case HOME:
            case END:
                if (!hasModifierKey(event)) {
                    keyCode === HOME
                        ? manager.setFirstItemActive()
                        : manager.setLastItemActive();
                    event.preventDefault();
                }
                break;
            default:
                if (keyCode === UP_ARROW || keyCode === DOWN_ARROW) {
                    manager.setFocusOrigin('keyboard');
                }
                manager.onKeydown(event);
        }
    }
    /**
     * Starts the enter animation.
     * @return {?}
     */
    _startAnimation() {
        this._panelAnimationState = 'enter';
    }
    /**
     * Callback that is invoked when the panel animation completes.
     * @param {?} event
     * @return {?}
     */
    _onAnimationDone(event) { }
    /**
     * Resets the panel animation to its initial state.
     * @return {?}
     */
    _resetAnimation() {
        this._panelAnimationState = 'void';
    }
    /**
     * @param {?} event
     * @return {?}
     */
    _onAnimationStart(event) {
        // Scroll the content element to the top as soon as the animation starts.
        if (event.toState === 'enter' && this._keyManager.activeItemIndex === 0) {
            event.element.scrollTop = 0;
        }
    }
}
SdsMenuComponent.decorators = [
    { type: Component, args: [{
                selector: 'sds-menu',
                exportAs: 'sdsMenu',
                template: "<ng-template>\n  <div\n    class=\"sds-overlay minw-menu maxw-mobile radius-overlay\"\n    [ngClass]=\"_classList\"\n    (keydown)=\"_handleKeydown($event)\"\n    (click)=\"closed.emit('click')\"\n    [@transformMenu]=\"_panelAnimationState\"\n    (@transformMenu.start)=\"_onAnimationStart($event)\"\n    (@transformMenu.done)=\"_onAnimationDone($event)\"\n    tabindex=\"-1\"\n    role=\"menu\"\n  >\n    <div class=\"sds-menu\" [class.sds-menu--small]=\"size === 'sm'\">\n      <ng-content></ng-content>\n    </div>\n  </div>\n</ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                animations: [sdsMenuAnimations.transformMenu],
                providers: [
                    { provide: SDS_MENU_TOKEN, useExisting: SdsMenuComponent }
                ]
            }] }
];
/** @nocollapse */
SdsMenuComponent.ctorParameters = () => [
    { type: ElementRef }
];
SdsMenuComponent.propDecorators = {
    templateRef: [{ type: ViewChild, args: [TemplateRef,] }],
    size: [{ type: Input }],
    xPosition: [{ type: Input }],
    yPosition: [{ type: Input }],
    overlapTrigger: [{ type: Input }],
    panelClass: [{ type: Input, args: ['class',] }],
    closed: [{ type: Output }]
};
if (false) {
    /**
     * After | Before the menu triger element
     * @type {?}
     * @private
     */
    SdsMenuComponent.prototype._xPosition;
    /**
     * Above | Below the menu triger element
     * @type {?}
     * @private
     */
    SdsMenuComponent.prototype._yPosition;
    /**
     * Manage browser focus
     * @type {?}
     * @private
     */
    SdsMenuComponent.prototype._keyManager;
    /**
     * Menu items inside the current menu.
     * @type {?}
     * @private
     */
    SdsMenuComponent.prototype._items;
    /**
     * Subscription to tab events on the menu panel
     * @type {?}
     * @private
     */
    SdsMenuComponent.prototype._tabSubscription;
    /**
     * Stores <sds-menu> classes
     * @type {?}
     * @private
     */
    SdsMenuComponent.prototype._previousPanelClass;
    /**
     * Config object to be passed into the menu's ngClass
     * @type {?}
     */
    SdsMenuComponent.prototype._classList;
    /**
     * Current state of the panel animation.
     * @type {?}
     */
    SdsMenuComponent.prototype._panelAnimationState;
    /**
     * Grab the component template
     * @type {?}
     */
    SdsMenuComponent.prototype.templateRef;
    /**
     * Size of menu component.
     * Affects the font-size of the menu items and
     * the size of the close button in the menu header
     * @type {?}
     */
    SdsMenuComponent.prototype.size;
    /**
     * @type {?}
     * @private
     */
    SdsMenuComponent.prototype._overlapTrigger;
    /**
     * Event emitted when the menu is closed.
     * @type {?}
     */
    SdsMenuComponent.prototype.closed;
    /**
     * @type {?}
     * @private
     */
    SdsMenuComponent.prototype._elementRef;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWVudS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AZ3NhLXNhbS9jb21wb25lbnRzLyIsInNvdXJjZXMiOlsibGliL21lbnUvbWVudS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFFTCx1QkFBdUIsRUFDdkIsU0FBUyxFQUNULFVBQVUsRUFDVixZQUFZLEVBQ1osY0FBYyxFQUNkLEtBQUssRUFFTCxNQUFNLEVBQ04sV0FBVyxFQUNYLFNBQVMsRUFDVCxpQkFBaUIsRUFFbEIsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUNMLE1BQU0sRUFDTixVQUFVLEVBQ1YsUUFBUSxFQUNSLElBQUksRUFDSixHQUFHLEVBQ0gsY0FBYyxFQUNmLE1BQU0sdUJBQXVCLENBQUM7QUFDL0IsT0FBTyxFQUFFLGVBQWUsRUFBZSxNQUFNLG1CQUFtQixDQUFDO0FBQ2pFLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQzlELE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDcEMsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sbUJBQW1CLENBQUM7Ozs7O0FBWXRELE1BQU0sT0FBTyxjQUFjLEdBQUcsSUFBSSxjQUFjLENBQzlDLGdCQUFnQixDQUNqQjs7Ozs7O0FBR0Qsc0NBYUM7OztJQVpDLHFDQUF5Qjs7SUFDekIscUNBQXlCOztJQUN6QiwwQ0FBd0I7O0lBQ3hCLHVDQUE4Qjs7SUFDOUIsa0NBQXlEOztJQUN6RCxzQ0FBOEI7O0lBQzlCLGdDQUFpQjs7SUFDakIsMENBQStDOztJQUMvQyw4Q0FBa0U7O0lBQ2xFLG1DQUE0Qjs7SUFDNUIsc0NBQThDOztJQUM5QyxzQ0FBK0I7O0FBY2pDLE1BQU0sT0FBTyxnQkFBZ0I7Ozs7SUFpRzNCLFlBQW9CLFdBQW9DO1FBQXBDLGdCQUFXLEdBQVgsV0FBVyxDQUF5Qjs7OztRQTFGaEQsZUFBVSxHQUFrQixPQUFPLENBQUM7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Q3pFLElBQUksS0FBSyxDQUFDLE9BQU8sS0FBSyxPQUFPLElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxlQUFlLEtBQUssQ0FBQyxFQUFFO1lBQ3ZFLEtBQUssQ0FBQyxPQUFPLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQztTQUM3QjtJQUNILENBQUM7OztZQXJORixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLFVBQVU7Z0JBQ3BCLFFBQVEsRUFBRSxTQUFTO2dCQUNuQiw4aUJBQWtDO2dCQUNsQyxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTtnQkFDL0MsYUFBYSxFQUFFLGlCQUFpQixDQUFDLElBQUk7Z0JBQ3JDLFVBQVUsRUFBRSxDQUFDLGlCQUFpQixDQUFDLGFBQWEsQ0FBQztnQkFDN0MsU0FBUyxFQUFFO29CQUNULEVBQUUsT0FBTyxFQUFFLGNBQWMsRUFBRSxXQUFXLEVBQUUsZ0JBQWdCLEVBQUU7aUJBQzNEO2FBQ0Y7Ozs7WUFqRUMsVUFBVTs7OzBCQWlHVCxTQUFTLFNBQUMsV0FBVzttQkFPckIsS0FBSzt3QkFHTCxLQUFLO3dCQVVMLEtBQUs7NkJBVUwsS0FBSzt5QkFVTCxLQUFLLFNBQUMsT0FBTztxQkF3QmIsTUFBTTs7Ozs7Ozs7SUF4RlAsc0NBQTRDOzs7Ozs7SUFHNUMsc0NBQTRDOzs7Ozs7SUFHNUMsdUNBQTJEOzs7Ozs7SUFHM0Qsa0NBQTRDOzs7Ozs7SUFHNUMsNENBQThDOzs7Ozs7SUFHOUMsK0NBQW9DOzs7OztJQUdwQyxzQ0FBNEM7Ozs7O0lBRzVDLGdEQUFnRDs7Ozs7SUFHaEQsdUNBQXNEOzs7Ozs7O0lBT3RELGdDQUF5Qjs7Ozs7SUE4QnpCLDJDQUFnQzs7Ozs7SUEyQmhDLGtDQUEwRTs7Ozs7SUFFOUQsdUNBQTRDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENvbXBvbmVudCxcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBJbmplY3Rpb25Ub2tlbixcbiAgSW5wdXQsXG4gIE9uRGVzdHJveSxcbiAgT3V0cHV0LFxuICBUZW1wbGF0ZVJlZixcbiAgVmlld0NoaWxkLFxuICBWaWV3RW5jYXBzdWxhdGlvbixcbiAgT25Jbml0XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQW5pbWF0aW9uRXZlbnQgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7XG4gIEVTQ0FQRSxcbiAgRE9XTl9BUlJPVyxcbiAgVVBfQVJST1csXG4gIEhPTUUsXG4gIEVORCxcbiAgaGFzTW9kaWZpZXJLZXlcbn0gZnJvbSAnQGFuZ3VsYXIvY2RrL2tleWNvZGVzJztcbmltcG9ydCB7IEZvY3VzS2V5TWFuYWdlciwgRm9jdXNPcmlnaW4gfSBmcm9tICdAYW5ndWxhci9jZGsvYTExeSc7XG5pbXBvcnQgeyBjb2VyY2VCb29sZWFuUHJvcGVydHkgfSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBzZHNNZW51QW5pbWF0aW9ucyB9IGZyb20gJy4vbWVudS1hbmltYXRpb25zJztcbmltcG9ydCB7IFNkc01lbnVJdGVtQ29tcG9uZW50IH0gZnJvbSAnLi9tZW51LWl0ZW0uY29tcG9uZW50JztcblxuLyoqIE1lbnUgUG9zaXRpb25zICovXG5leHBvcnQgdHlwZSBNZW51UG9zaXRpb25YID0gJ2JlZm9yZScgfCAnYWZ0ZXInO1xuZXhwb3J0IHR5cGUgTWVudVBvc2l0aW9uWSA9ICdhYm92ZScgfCAnYmVsb3cnO1xuXG4vKiogTWVudSBhdmFpbGFibGUgc2l6ZXMgKi9cbi8vIHNtID0gJ3NtYWxsJ1xuZXhwb3J0IHR5cGUgTWVudVNpemVzID0gJ3NtJztcblxuLyoqIEluamVjdGlvbiB0b2tlbiB1c2VkIHRvIHByb3ZpZGUgdGhlIHBhcmVudCBtZW51IHRvIG1lbnUgaXRlbXMuICovXG5leHBvcnQgY29uc3QgU0RTX01FTlVfVE9LRU4gPSBuZXcgSW5qZWN0aW9uVG9rZW48U2RzTWVudUludGVyZmFjZT4oXG4gICdTRFNfTUVOVV9UT0tFTidcbik7XG5cbi8qKiBNZW51IEludGVyZmFjZSAqL1xuZXhwb3J0IGludGVyZmFjZSBTZHNNZW51SW50ZXJmYWNlPFQgPSBhbnk+IHtcbiAgeFBvc2l0aW9uOiBNZW51UG9zaXRpb25YO1xuICB5UG9zaXRpb246IE1lbnVQb3NpdGlvblk7XG4gIG92ZXJsYXBUcmlnZ2VyOiBib29sZWFuO1xuICB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8YW55PjtcbiAgY2xvc2VkOiBFdmVudEVtaXR0ZXI8dm9pZCB8ICdjbGljaycgfCAna2V5ZG93bicgfCAndGFiJz47XG4gIHBhcmVudE1lbnU/OiBTZHNNZW51SW50ZXJmYWNlO1xuICBzaXplPzogTWVudVNpemVzO1xuICBmb2N1c0ZpcnN0SXRlbTogKG9yaWdpbj86IEZvY3VzT3JpZ2luKSA9PiB2b2lkO1xuICBzZXRQb3NpdGlvbkNsYXNzZXM/OiAoeDogTWVudVBvc2l0aW9uWCwgeTogTWVudVBvc2l0aW9uWSkgPT4gdm9pZDtcbiAgYWRkSXRlbT86IChpdGVtOiBUKSA9PiB2b2lkO1xuICBpbnNlcnRJdGVtPzogKGl0ZW06IFQsIGluZGV4OiBudW1iZXIpID0+IHZvaWQ7XG4gIHJlbW92ZUl0ZW0/OiAoaXRlbTogVCkgPT4gdm9pZDtcbn1cblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnc2RzLW1lbnUnLFxuICBleHBvcnRBczogJ3Nkc01lbnUnLFxuICB0ZW1wbGF0ZVVybDogJ21lbnUuY29tcG9uZW50Lmh0bWwnLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgYW5pbWF0aW9uczogW3Nkc01lbnVBbmltYXRpb25zLnRyYW5zZm9ybU1lbnVdLFxuICBwcm92aWRlcnM6IFtcbiAgICB7IHByb3ZpZGU6IFNEU19NRU5VX1RPS0VOLCB1c2VFeGlzdGluZzogU2RzTWVudUNvbXBvbmVudCB9XG4gIF1cbn0pXG5leHBvcnQgY2xhc3MgU2RzTWVudUNvbXBvbmVudFxuICBpbXBsZW1lbnRzXG4gICAgT25Jbml0LFxuICAgIEFmdGVyQ29udGVudEluaXQsXG4gICAgT25EZXN0cm95LFxuICAgIFNkc01lbnVJbnRlcmZhY2U8U2RzTWVudUl0ZW1Db21wb25lbnQ+IHtcbiAgLyoqIEFmdGVyIHwgQmVmb3JlIHRoZSBtZW51IHRyaWdlciBlbGVtZW50ICovXG4gIHByaXZhdGUgX3hQb3NpdGlvbjogTWVudVBvc2l0aW9uWCA9ICdhZnRlcic7XG5cbiAgLyoqIEFib3ZlIHwgQmVsb3cgdGhlIG1lbnUgdHJpZ2VyIGVsZW1lbnQgKi9cbiAgcHJpdmF0ZSBfeVBvc2l0aW9uOiBNZW51UG9zaXRpb25ZID0gJ2JlbG93JztcblxuICAvKiogTWFuYWdlIGJyb3dzZXIgZm9jdXMgKi9cbiAgcHJpdmF0ZSBfa2V5TWFuYWdlcjogRm9jdXNLZXlNYW5hZ2VyPFNkc01lbnVJdGVtQ29tcG9uZW50PjtcblxuICAvKiogTWVudSBpdGVtcyBpbnNpZGUgdGhlIGN1cnJlbnQgbWVudS4gKi9cbiAgcHJpdmF0ZSBfaXRlbXM6IFNkc01lbnVJdGVtQ29tcG9uZW50W10gPSBbXTtcblxuICAvKiogU3Vic2NyaXB0aW9uIHRvIHRhYiBldmVudHMgb24gdGhlIG1lbnUgcGFuZWwgKi9cbiAgcHJpdmF0ZSBfdGFiU3Vic2NyaXB0aW9uID0gU3Vic2NyaXB0aW9uLkVNUFRZO1xuXG4gIC8qKiBTdG9yZXMgPHNkcy1tZW51PiBjbGFzc2VzICovXG4gIHByaXZhdGUgX3ByZXZpb3VzUGFuZWxDbGFzczogc3RyaW5nO1xuXG4gIC8qKiBDb25maWcgb2JqZWN0IHRvIGJlIHBhc3NlZCBpbnRvIHRoZSBtZW51J3MgbmdDbGFzcyAqL1xuICBfY2xhc3NMaXN0OiB7IFtrZXk6IHN0cmluZ106IGJvb2xlYW4gfSA9IHt9O1xuXG4gIC8qKiBDdXJyZW50IHN0YXRlIG9mIHRoZSBwYW5lbCBhbmltYXRpb24uICovXG4gIF9wYW5lbEFuaW1hdGlvblN0YXRlOiAndm9pZCcgfCAnZW50ZXInID0gJ3ZvaWQnO1xuXG4gIC8qKiBHcmFiIHRoZSBjb21wb25lbnQgdGVtcGxhdGUgKi9cbiAgQFZpZXdDaGlsZChUZW1wbGF0ZVJlZikgdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgLyoqXG4gICAqIFNpemUgb2YgbWVudSBjb21wb25lbnQuXG4gICAqIEFmZmVjdHMgdGhlIGZvbnQtc2l6ZSBvZiB0aGUgbWVudSBpdGVtcyBhbmRcbiAgICogdGhlIHNpemUgb2YgdGhlIGNsb3NlIGJ1dHRvbiBpbiB0aGUgbWVudSBoZWFkZXJcbiAgICovXG4gIEBJbnB1dCgpIHNpemU6IE1lbnVTaXplcztcblxuICAvKiogUG9zaXRpb24gb2YgdGhlIG1lbnUgaW4gdGhlIFggYXhpcy4gKi9cbiAgQElucHV0KClcbiAgZ2V0IHhQb3NpdGlvbigpOiBNZW51UG9zaXRpb25YIHtcbiAgICByZXR1cm4gdGhpcy5feFBvc2l0aW9uO1xuICB9XG4gIHNldCB4UG9zaXRpb24odmFsdWU6IE1lbnVQb3NpdGlvblgpIHtcbiAgICB0aGlzLl94UG9zaXRpb24gPSB2YWx1ZTtcbiAgICB0aGlzLnNldFBvc2l0aW9uQ2xhc3NlcygpO1xuICB9XG5cbiAgLyoqIFBvc2l0aW9uIG9mIHRoZSBtZW51IGluIHRoZSBZIGF4aXMuICovXG4gIEBJbnB1dCgpXG4gIGdldCB5UG9zaXRpb24oKTogTWVudVBvc2l0aW9uWSB7XG4gICAgcmV0dXJuIHRoaXMuX3lQb3NpdGlvbjtcbiAgfVxuICBzZXQgeVBvc2l0aW9uKHZhbHVlOiBNZW51UG9zaXRpb25ZKSB7XG4gICAgdGhpcy5feVBvc2l0aW9uID0gdmFsdWU7XG4gICAgdGhpcy5zZXRQb3NpdGlvbkNsYXNzZXMoKTtcbiAgfVxuXG4gIC8qKiBXaGV0aGVyIG1lbnUgcGFuZWwgb3ZlcmxhcHMgdHJpZ2dlciBlbGVtZW50ICovXG4gIEBJbnB1dCgpXG4gIGdldCBvdmVybGFwVHJpZ2dlcigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fb3ZlcmxhcFRyaWdnZXI7XG4gIH1cbiAgc2V0IG92ZXJsYXBUcmlnZ2VyKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5fb3ZlcmxhcFRyaWdnZXIgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICB9XG4gIHByaXZhdGUgX292ZXJsYXBUcmlnZ2VyID0gZmFsc2U7XG5cbiAgLyoqIFRyYW5zZmVyIGNsYXNzZXMgZnJvbSB0aGUgc2RzLW1lbnUgdG8gdGhlIG92ZXJsYXkgY29udGFpbmVyICovXG4gIEBJbnB1dCgnY2xhc3MnKVxuICBzZXQgcGFuZWxDbGFzcyhjbGFzc2VzOiBzdHJpbmcpIHtcbiAgICBjb25zdCBwcmV2aW91c1BhbmVsQ2xhc3MgPSB0aGlzLl9wcmV2aW91c1BhbmVsQ2xhc3M7XG4gICAgLy8gUmVtb3ZlIHByZXZpb3VzIGNsYXNzZXMgZnJvbSBjdXJyZW50IHNldCBvZiBjbGFzc2VzXG4gICAgaWYgKHByZXZpb3VzUGFuZWxDbGFzcyAmJiBwcmV2aW91c1BhbmVsQ2xhc3MubGVuZ3RoKSB7XG4gICAgICBwcmV2aW91c1BhbmVsQ2xhc3Muc3BsaXQoJyAnKS5mb3JFYWNoKChjbGFzc05hbWU6IHN0cmluZykgPT4ge1xuICAgICAgICB0aGlzLl9jbGFzc0xpc3RbY2xhc3NOYW1lXSA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5fcHJldmlvdXNQYW5lbENsYXNzID0gY2xhc3NlcztcblxuICAgIC8vIEFkZHMgbmV3IGNsYXNzZXMgdG8gY3VycmVudCBzZXQgb2YgY2xhc3Nlc1xuICAgIGlmIChjbGFzc2VzICYmIGNsYXNzZXMubGVuZ3RoKSB7XG4gICAgICBjbGFzc2VzLnNwbGl0KCcgJykuZm9yRWFjaCgoY2xhc3NOYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgICAgdGhpcy5fY2xhc3NMaXN0W2NsYXNzTmFtZV0gPSB0cnVlO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFJlbW92ZSBhbGwgY2xhc3NlcyBmcm9tIDxzZHMtbWVudT5cbiAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jbGFzc05hbWUgPSAnJztcbiAgICB9XG4gIH1cblxuICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBtZW51IGlzIGNsb3NlZC4gKi9cbiAgQE91dHB1dCgpIGNsb3NlZCA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZCB8ICdjbGljaycgfCAna2V5ZG93bicgfCAndGFiJz4oKTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmPEhUTUxFbGVtZW50Pikge31cblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLnNldFBvc2l0aW9uQ2xhc3NlcygpO1xuICB9XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIHRoaXMuX2tleU1hbmFnZXIgPSBuZXcgRm9jdXNLZXlNYW5hZ2VyPFNkc01lbnVJdGVtQ29tcG9uZW50PihcbiAgICAgIHRoaXMuX2l0ZW1zXG4gICAgKS53aXRoV3JhcCgpO1xuICAgIHRoaXMuX3RhYlN1YnNjcmlwdGlvbiA9IHRoaXMuX2tleU1hbmFnZXIudGFiT3V0LnN1YnNjcmliZSgoKSA9PlxuICAgICAgdGhpcy5jbG9zZWQuZW1pdCgndGFiJylcbiAgICApO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5fdGFiU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgdGhpcy5jbG9zZWQuY29tcGxldGUoKTtcbiAgfVxuXG4gIC8qKiBGb2N1cyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbWVudSAqL1xuICBmb2N1c0ZpcnN0SXRlbShvcmlnaW46IEZvY3VzT3JpZ2luID0gJ3Byb2dyYW0nKTogdm9pZCB7XG4gICAgdGhpcy5fa2V5TWFuYWdlci5zZXRGb2N1c09yaWdpbihvcmlnaW4pLnNldEZpcnN0SXRlbUFjdGl2ZSgpO1xuICB9XG5cbiAgLyoqIEFkZHMgY2xhc3NlcyB0byB0aGUgbWVudSBwYW5lbCBiYXNlZCBvbiBpdHMgcG9zaXRpb24gKi9cbiAgc2V0UG9zaXRpb25DbGFzc2VzKFxuICAgIHBvc1g6IE1lbnVQb3NpdGlvblggPSB0aGlzLnhQb3NpdGlvbixcbiAgICBwb3NZOiBNZW51UG9zaXRpb25ZID0gdGhpcy55UG9zaXRpb25cbiAgKSB7XG4gICAgY29uc3QgY2xhc3NlcyA9IHRoaXMuX2NsYXNzTGlzdDtcbiAgICBjbGFzc2VzWydzZHMtbWVudS1iZWZvcmUnXSA9IHBvc1ggPT09ICdiZWZvcmUnO1xuICAgIGNsYXNzZXNbJ3Nkcy1tZW51LWFmdGVyJ10gPSBwb3NYID09PSAnYWZ0ZXInO1xuICAgIGNsYXNzZXNbJ3Nkcy1tZW51LWFib3ZlJ10gPSBwb3NZID09PSAnYWJvdmUnO1xuICAgIGNsYXNzZXNbJ3Nkcy1tZW51LWJlbG93J10gPSBwb3NZID09PSAnYmVsb3cnO1xuICB9XG5cbiAgLyoqIEFkZHMgYSBtZW51IGl0ZW0gd2l0aCB0aGUgbWVudS4gKi9cbiAgYWRkSXRlbShpdGVtOiBTZHNNZW51SXRlbUNvbXBvbmVudCkge1xuICAgIGlmICh0aGlzLl9pdGVtcy5pbmRleE9mKGl0ZW0pID09PSAtMSkge1xuICAgICAgdGhpcy5faXRlbXMucHVzaChpdGVtKTtcbiAgICB9XG4gIH1cblxuICAvKiogSW5zZXJ0cyBhIG1lbnUgaXRlbSBhdCBhbiBpbmRleCAqL1xuICBpbnNlcnRJdGVtKGl0ZW06IFNkc01lbnVJdGVtQ29tcG9uZW50LCBpbmRleDogbnVtYmVyKSB7XG4gICAgaWYgKHRoaXMuX2l0ZW1zLmluZGV4T2YoaXRlbSkgPT09IC0xICYmIGluZGV4IDwgdGhpcy5faXRlbXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9pdGVtcy5zcGxpY2UoaW5kZXgsIDAsIGl0ZW0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSB0aGUgbWVudS4gKi9cbiAgcmVtb3ZlSXRlbShpdGVtOiBTZHNNZW51SXRlbUNvbXBvbmVudCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAodGhpcy5faXRlbXMuaW5kZXhPZihpdGVtKSA+IC0xKSB7XG4gICAgICB0aGlzLl9pdGVtcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBIYW5kbGUgYSBrZXlib2FyZCBldmVudCBmcm9tIHRoZSBtZW51ICovXG4gIF9oYW5kbGVLZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBkZXByZWNhdGlvblxuICAgIGNvbnN0IGtleUNvZGUgPSBldmVudC5rZXlDb2RlO1xuICAgIGNvbnN0IG1hbmFnZXIgPSB0aGlzLl9rZXlNYW5hZ2VyO1xuXG4gICAgc3dpdGNoIChrZXlDb2RlKSB7XG4gICAgICBjYXNlIEVTQ0FQRTpcbiAgICAgICAgdGhpcy5jbG9zZWQuZW1pdCgna2V5ZG93bicpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSE9NRTpcbiAgICAgIGNhc2UgRU5EOlxuICAgICAgICBpZiAoIWhhc01vZGlmaWVyS2V5KGV2ZW50KSkge1xuICAgICAgICAgIGtleUNvZGUgPT09IEhPTUVcbiAgICAgICAgICAgID8gbWFuYWdlci5zZXRGaXJzdEl0ZW1BY3RpdmUoKVxuICAgICAgICAgICAgOiBtYW5hZ2VyLnNldExhc3RJdGVtQWN0aXZlKCk7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChrZXlDb2RlID09PSBVUF9BUlJPVyB8fCBrZXlDb2RlID09PSBET1dOX0FSUk9XKSB7XG4gICAgICAgICAgbWFuYWdlci5zZXRGb2N1c09yaWdpbigna2V5Ym9hcmQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hbmFnZXIub25LZXlkb3duKGV2ZW50KTtcbiAgICB9XG4gIH1cblxuICAvKiogU3RhcnRzIHRoZSBlbnRlciBhbmltYXRpb24uICovXG4gIF9zdGFydEFuaW1hdGlvbigpIHtcbiAgICB0aGlzLl9wYW5lbEFuaW1hdGlvblN0YXRlID0gJ2VudGVyJztcbiAgfVxuXG4gIC8qKiBDYWxsYmFjayB0aGF0IGlzIGludm9rZWQgd2hlbiB0aGUgcGFuZWwgYW5pbWF0aW9uIGNvbXBsZXRlcy4gKi9cbiAgX29uQW5pbWF0aW9uRG9uZShldmVudDogQW5pbWF0aW9uRXZlbnQpIHt9XG5cbiAgLyoqIFJlc2V0cyB0aGUgcGFuZWwgYW5pbWF0aW9uIHRvIGl0cyBpbml0aWFsIHN0YXRlLiAqL1xuICBfcmVzZXRBbmltYXRpb24oKSB7XG4gICAgdGhpcy5fcGFuZWxBbmltYXRpb25TdGF0ZSA9ICd2b2lkJztcbiAgfVxuXG4gIF9vbkFuaW1hdGlvblN0YXJ0KGV2ZW50OiBBbmltYXRpb25FdmVudCkge1xuICAgIC8vIFNjcm9sbCB0aGUgY29udGVudCBlbGVtZW50IHRvIHRoZSB0b3AgYXMgc29vbiBhcyB0aGUgYW5pbWF0aW9uIHN0YXJ0cy5cbiAgICBpZiAoZXZlbnQudG9TdGF0ZSA9PT0gJ2VudGVyJyAmJiB0aGlzLl9rZXlNYW5hZ2VyLmFjdGl2ZUl0ZW1JbmRleCA9PT0gMCkge1xuICAgICAgZXZlbnQuZWxlbWVudC5zY3JvbGxUb3AgPSAwO1xuICAgIH1cbiAgfVxufVxuIl19