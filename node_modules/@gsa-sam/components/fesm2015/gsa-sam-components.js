import { CdkAccordionItem, CdkAccordion } from '@angular/cdk/accordion';
import { UniqueSelectionDispatcher } from '@angular/cdk/collections';
import { ANIMATION_MODULE_TYPE } from '@angular/platform-browser/animations';
import { RouterModule } from '@angular/router';
import { normalizePassiveListenerOptions } from '@angular/cdk/platform';
import { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';
import { Directionality } from '@angular/cdk/bidi';
import { animate, state, style, transition, trigger, query, group } from '@angular/animations';
import { ENTER, SPACE, hasModifierKey, HOME, END, ESCAPE, DOWN_ARROW, UP_ARROW } from '@angular/cdk/keycodes';
import { Subject, merge, Subscription, defer, of } from 'rxjs';
import { filter, startWith, take, distinctUntilChanged } from 'rxjs/operators';
import { Overlay, OverlayConfig, OverlayModule, ViewportRuler, OverlayContainer } from '@angular/cdk/overlay';
import { TemplatePortal, PortalModule, PortalInjector, ComponentPortal, BasePortalOutlet, CdkPortalOutlet } from '@angular/cdk/portal';
import { FontAwesomeModule, FaIconComponent } from '@fortawesome/angular-fontawesome';
import { InjectionToken, Directive, TemplateRef, ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, EventEmitter, ElementRef, Inject, Optional, Output, SkipSelf, ViewContainerRef, ViewEncapsulation, ViewChild, Host, Input, ContentChildren, NgModule, Renderer2, HostListener, forwardRef, HostBinding, Injector, Injectable, ComponentFactoryResolver } from '@angular/core';
import { FocusMonitor, FocusKeyManager, A11yModule, isFakeMousedownFromScreenReader, FocusTrapFactory } from '@angular/cdk/a11y';
import { DOCUMENT, CommonModule, Location } from '@angular/common';
import { FormsModule, NG_VALUE_ACCESSOR } from '@angular/forms';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Token used to provide a `SdsAccordion` to `SdsAccordionItem`.
 * Used primarily to avoid circular imports between `SdsAccordion` and `SdsAccordionItem`.
 * @type {?}
 */
const SDS_ACCORDION = new InjectionToken('SDS_ACCORDION');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Time and timing curve for accordion item animations.
 * @type {?}
 */
const ACCORDION_ITEM_ANIMATION_TIMING = '225ms cubic-bezier(0.4,0.0,0.2,1)';
/** @type {?} */
const sdsExpansionAnimations = {
    /**
     * Animation that expands and collapses the accordion item content.
     */
    bodyExpansion: trigger('bodyExpansion', [
        state('collapsed, void', style({ height: '0px', visibility: 'hidden' })),
        state('expanded', style({ height: '*', visibility: 'visible' })),
        transition('expanded <=> collapsed, void => collapsed', animate(ACCORDION_ITEM_ANIMATION_TIMING)),
    ])
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Accordion Item content that will be rendered lazily
 * after the accordion item is opened for the first time.
 */
class SdsAccordionItemContentDirective {
    /**
     * @param {?} _template
     */
    constructor(_template) {
        this._template = _template;
    }
}
SdsAccordionItemContentDirective.decorators = [
    { type: Directive, args: [{
                selector: 'ng-template[sdsAccordionItemContent]'
            },] }
];
/** @nocollapse */
SdsAccordionItemContentDirective.ctorParameters = () => [
    { type: TemplateRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Counter for generating unique element ids.
 * @type {?}
 */
let uniqueId = 0;
class SdsAccordionItemComponent extends CdkAccordionItem {
    /**
     * @param {?} accordion
     * @param {?} _changeDetectorRef
     * @param {?} _uniqueSelectionDispatcher
     * @param {?} _viewContainerRef
     * @param {?} _document
     * @param {?} _animationMode
     */
    constructor(accordion, _changeDetectorRef, _uniqueSelectionDispatcher, _viewContainerRef, _document, _animationMode) {
        super(accordion, _changeDetectorRef, _uniqueSelectionDispatcher);
        this._viewContainerRef = _viewContainerRef;
        this._animationMode = _animationMode;
        /**
         * An event emitted after the body's expansion animation happens.
         */
        this.afterExpand = new EventEmitter();
        /**
         * An event emitted after the body's collapse animation happens.
         */
        this.afterCollapse = new EventEmitter();
        /**
         * Stream that emits for changes in `\@Input` properties.
         */
        this._inputChanges = new Subject();
        /**
         * ID for the associated header element. Used for a11y labelling.
         */
        this._headerId = `sds-accordion-item-header-${uniqueId++}`;
        /**
         * Stream of body animation done events.
         */
        this._bodyAnimationDone = new Subject();
        this.accordion = accordion;
        this._document = _document;
        // We need a Subject with distinctUntilChanged, because the `done` event
        // fires twice on some browsers. See https://github.com/angular/angular/issues/24084
        this._bodyAnimationDone.pipe(distinctUntilChanged((/**
         * @param {?} x
         * @param {?} y
         * @return {?}
         */
        (x, y) => {
            return x.fromState === y.fromState && x.toState === y.toState;
        }))).subscribe((/**
         * @param {?} event
         * @return {?}
         */
        event => {
            if (event.fromState !== 'void') {
                if (event.toState === 'expanded') {
                    this.afterExpand.emit();
                }
                else if (event.toState === 'collapsed') {
                    this.afterCollapse.emit();
                }
            }
        }));
    }
    /**
     * Gets the expanded state string.
     * @return {?}
     */
    _getExpandedState() {
        return this.expanded ? 'expanded' : 'collapsed';
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this._lazyContent) {
            // Render the content as soon as the accordion item becomes open.
            this.opened.pipe(startWith((/** @type {?} */ (null))), filter((/**
             * @return {?}
             */
            () => this.expanded && !this._portal)), take(1)).subscribe((/**
             * @return {?}
             */
            () => {
                this._portal = new TemplatePortal(this._lazyContent._template, this._viewContainerRef);
            }));
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this._inputChanges.next(changes);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        super.ngOnDestroy();
        this._bodyAnimationDone.complete();
        this._inputChanges.complete();
    }
    /**
     * Checks whether the accordion item's content contains the currently-focused element.
     * @return {?}
     */
    _containsFocus() {
        if (this._body) {
            /** @type {?} */
            const focusedElement = this._document.activeElement;
            /** @type {?} */
            const bodyElement = this._body.nativeElement;
            return focusedElement === bodyElement || bodyElement.contains(focusedElement);
        }
        return false;
    }
}
SdsAccordionItemComponent.decorators = [
    { type: Component, args: [{
                selector: "sds-accordion-item",
                exportAs: "sdsAccordionItem",
                template: "<ng-content select=\"sds-accordion-item-header\"></ng-content>\n<div\n  class=\"sam-accordion__panel\"\n  role=\"region\"\n  [@bodyExpansion]=\"_getExpandedState()\"\n  (@bodyExpansion.done)=\"_bodyAnimationDone.next($event)\"\n  [attr.aria-labelledby]=\"_headerId\"\n  [id]=\"id\"\n  #body\n>\n  <div class=\"sds-accordion__panel-body\">\n    <ng-content></ng-content>\n    <ng-template [cdkPortalOutlet]=\"_portal\"></ng-template>\n  </div>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                inputs: ['disabled', 'expanded'],
                outputs: ['opened', 'closed', 'expandedChange'],
                animations: [sdsExpansionAnimations.bodyExpansion],
                host: {
                    'class': 'sds-accordion__item',
                    '[class.sds-accordion__item--expanded]': 'expanded',
                    '[class._sds-animation-noopable]': '_animationMode === "NoopAnimations"'
                }
            }] }
];
/** @nocollapse */
SdsAccordionItemComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: SkipSelf }, { type: Inject, args: [SDS_ACCORDION,] }] },
    { type: ChangeDetectorRef },
    { type: UniqueSelectionDispatcher },
    { type: ViewContainerRef },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [ANIMATION_MODULE_TYPE,] }] }
];
SdsAccordionItemComponent.propDecorators = {
    afterExpand: [{ type: Output }],
    afterCollapse: [{ type: Output }],
    _lazyContent: [{ type: ContentChild, args: [SdsAccordionItemContentDirective,] }],
    _body: [{ type: ViewChild, args: ['body',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SdsAccordionItemHeaderComponent {
    /**
     * @param {?} accordionItem
     * @param {?} _element
     * @param {?} _focusMonitor
     * @param {?} _changeDetectorRef
     */
    constructor(accordionItem, _element, _focusMonitor, _changeDetectorRef) {
        this.accordionItem = accordionItem;
        this._element = _element;
        this._focusMonitor = _focusMonitor;
        this._changeDetectorRef = _changeDetectorRef;
        this._parentChangeSubscription = Subscription.EMPTY;
        // Since the toggle state depends on an @Input on the accordion item, we
        // need to subscribe and trigger change detection manually.
        this._parentChangeSubscription = merge(accordionItem.opened, accordionItem.closed, accordionItem._inputChanges.pipe(filter((/**
         * @param {?} changes
         * @return {?}
         */
        changes => !!(changes["disabled"]))))).subscribe((/**
         * @return {?}
         */
        () => this._changeDetectorRef.markForCheck()));
        _focusMonitor.monitor(_element).subscribe((/**
         * @param {?} origin
         * @return {?}
         */
        origin => {
            if (origin && accordionItem.accordion) {
                accordionItem.accordion._handleHeaderFocus(this);
            }
        }));
    }
    /**
     * Whether the associated accordion item is disabled.
     * Implemented as a part of `FocusableOption`.
     * @return {?}
     */
    get disabled() {
        return this.accordionItem.disabled;
    }
    /**
     * Toggles the expanded state of the accordion item.
     * @return {?}
     */
    _toggle() {
        this.accordionItem.toggle();
    }
    /**
     * Gets whether the accordion item is expanded.
     * @return {?}
     */
    _isExpanded() {
        return this.accordionItem.expanded;
    }
    /**
     * Gets the accordion item id.
     * @return {?}
     */
    _getAccordionItemId() {
        return this.accordionItem.id;
    }
    /**
     * Handle keydown event calling to toggle() if appropriate.
     * @param {?} event
     * @return {?}
     */
    _keydown(event) {
        switch (event.keyCode) {
            // Toggle for space and enter keys.
            case SPACE:
            case ENTER:
                if (!hasModifierKey(event)) {
                    event.preventDefault();
                    this._toggle();
                }
                break;
            default:
                if (this.accordionItem.accordion) {
                    this.accordionItem.accordion._handleHeaderKeydown(event);
                }
                return;
        }
    }
    /**
     * Focuses the item header. Implemented as a part of `FocusableOption`.
     * \@docs-private
     * @param {?=} origin Origin of the action that triggered the focus.
     * @return {?}
     */
    focus(origin = "program") {
        this._focusMonitor.focusVia(this._element, origin);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._parentChangeSubscription.unsubscribe();
        this._focusMonitor.stopMonitoring(this._element);
    }
}
SdsAccordionItemHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: "sds-accordion-item-header",
                template: "<span class=\"sds-accordion__title\" role=\"heading\">\n  <span class=\"sds-accordion__title-text\">\n    <ng-content></ng-content>\n  </span>\n  <span class=\"sds-accordion__icon\"></span>\n</span>\n",
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    class: "sds-accordion__trigger",
                    role: "button",
                    "[attr.id]": "accordionItem._headerId",
                    "[attr.tabindex]": "disabled ? -1 : 0",
                    "[attr.aria-controls]": "_getAccordionItemId()",
                    "[attr.aria-expanded]": "_isExpanded()",
                    "[attr.aria-disabled]": "accordionItem.disabled",
                    "(click)": "_toggle()",
                    "(keydown)": "_keydown($event)"
                },
                styles: [""]
            }] }
];
/** @nocollapse */
SdsAccordionItemHeaderComponent.ctorParameters = () => [
    { type: SdsAccordionItemComponent, decorators: [{ type: Host }] },
    { type: ElementRef },
    { type: FocusMonitor },
    { type: ChangeDetectorRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SdsAccordionDirective extends CdkAccordion {
    constructor() {
        super(...arguments);
        this.displayMode = "default";
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this._keyManager = new FocusKeyManager(this._headers).withWrap();
    }
    /**
     * Handles keyboard events coming in from the item headers.
     * @param {?} event
     * @return {?}
     */
    _handleHeaderKeydown(event) {
        const { keyCode } = event;
        if (keyCode === HOME) {
            this._keyManager.setFirstItemActive();
            event.preventDefault();
        }
        else if (keyCode === END) {
            this._keyManager.setLastItemActive();
            event.preventDefault();
        }
        else {
            this._keyManager.onKeydown(event);
        }
    }
    /**
     * @param {?} header
     * @return {?}
     */
    _handleHeaderFocus(header) {
        this._keyManager.updateActiveItem(header);
    }
}
SdsAccordionDirective.decorators = [
    { type: Directive, args: [{
                selector: "sds-accordion",
                exportAs: "sdsAccordion",
                inputs: ["multi"],
                providers: [
                    {
                        provide: SDS_ACCORDION,
                        useExisting: SdsAccordionDirective
                    }
                ],
                host: {
                    'class': 'sds-accordion',
                    '[class.sds-accordion--basic]': 'displayMode === "basic"',
                }
            },] }
];
SdsAccordionDirective.propDecorators = {
    _headers: [{ type: ContentChildren, args: [SdsAccordionItemHeaderComponent, { descendants: true },] }],
    displayMode: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SdsAccordionModule {
}
SdsAccordionModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, PortalModule],
                exports: [
                    SdsAccordionDirective,
                    SdsAccordionItemComponent,
                    SdsAccordionItemHeaderComponent,
                    SdsAccordionItemContentDirective
                ],
                declarations: [
                    SdsAccordionDirective,
                    SdsAccordionItemComponent,
                    SdsAccordionItemHeaderComponent,
                    SdsAccordionItemContentDirective
                ],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SdsPageComponent {
    constructor() { }
    /**
     * @return {?}
     */
    ngOnInit() { }
}
SdsPageComponent.decorators = [
    { type: Component, args: [{
                selector: 'sds-page',
                template: `
    <div class="grid-container"><ng-content></ng-content></div>
  `
            }] }
];
/** @nocollapse */
SdsPageComponent.ctorParameters = () => [];
class SdsPageOptionsComponent {
    constructor() { }
    /**
     * @return {?}
     */
    ngOnInit() { }
}
SdsPageOptionsComponent.decorators = [
    { type: Component, args: [{
                selector: 'sds-page-options',
                template: `
    <div class="grid-row position-relative"><ng-content></ng-content></div>
  `
            }] }
];
/** @nocollapse */
SdsPageOptionsComponent.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SdsPageModule {
}
SdsPageModule.decorators = [
    { type: NgModule, args: [{
                imports: [],
                exports: [SdsPageComponent, SdsPageOptionsComponent],
                declarations: [SdsPageComponent, SdsPageOptionsComponent],
                providers: [],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Time and timing curve for accordion item animations.
 * @type {?}
 */
const TOOLBAR_ANIMATION_TIMING = '225ms cubic-bezier(0.4,0.0,0.2,1)';
/** @type {?} */
const sdsToolbarAnimations = {
    /**
     * Animation that expands and collapses the accordion item content.
     */
    bodyExpansion: trigger('bodyExpansion', [
        state('collapsed, void', style({ width: '0px', height: '0px', opacity: '0', visibility: 'hidden' })),
        state('expanded', style({ width: '{{expandedWidth}}', height: '*', opacity: '1', visibility: 'visible' }), {
            params: { expandedWidth: '300px' }
        }),
        transition('expanded <=> collapsed, void => collapsed', animate(TOOLBAR_ANIMATION_TIMING)),
    ])
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Counter for generating unique element ids.
 * @type {?}
 */
let uniqueId$1 = 0;
class SdsToolbarComponent {
    constructor() {
        /**
         * The unique Toolbar id.
         */
        this.id = uniqueId$1++;
        /**
         * ID for the header element. Used for a11y labelling.
         */
        this._headerId = `sds-toolbar-header-${this.id}`;
        /**
         * ID for the content element. Used for a11y labelling.
         */
        this._contentId = `sds-toolbar-content-${this.id}`;
        /**
         * Emits whenever the expanded state of the toolbar changes.
         */
        this.expandedChange = new EventEmitter();
        this._expanded = false;
        this._disabled = false;
        /**
         * Width of the toolbar when is expanded.
         */
        this.expandedWidth = "300px";
        // Elements that surround the toolbar need to make space for the expanded toolbar.
        // Adding 20 more pixes to provide padding
        this.expandedSpace = "20px";
    }
    /**
     * Whether the toolbar is expanded.
     * @return {?}
     */
    get expanded() {
        return this._expanded;
    }
    /**
     * @param {?} expanded
     * @return {?}
     */
    set expanded(expanded) {
        expanded = coerceBooleanProperty(expanded);
        // Only emit events and update the internal value if the value changes.
        if (this._expanded !== expanded) {
            this._expanded = expanded;
            this.expandedChange.emit(expanded);
        }
    }
    /**
     * Whether the toolbar is disabled.
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * @param {?} disabled
     * @return {?}
     */
    set disabled(disabled) {
        this._disabled = coerceBooleanProperty(disabled);
    }
    /**
     * Toggles the expanded state of the toolbar.
     * @return {?}
     */
    toggle() {
        this.expanded = !this.expanded;
    }
    /**
     * Gets the expanded state string.
     * @return {?}
     */
    _getExpandedState() {
        return this.expanded ? "expanded" : "collapsed";
    }
}
SdsToolbarComponent.decorators = [
    { type: Component, args: [{
                selector: "sds-toolbar",
                exportAs: "sdsToolbar",
                template: "<sds-toolbar-header></sds-toolbar-header>\n<div\n  class=\"sds-toolbar__content\"\n  role=\"region\"\n  [@bodyExpansion]=\"{\n    value: _getExpandedState(),\n    params: { expandedWidth: expandedWidth }\n  }\"\n  [attr.aria-labelledby]=\"_headerId\"\n  [id]=\"_contentId\"\n>\n  <ng-content></ng-content>\n</div>\n",
                animations: [sdsToolbarAnimations.bodyExpansion],
                host: {
                    class: "sds-toolbar",
                    "[class.sds-toolbar--expanded]": "expanded"
                }
            }] }
];
/** @nocollapse */
SdsToolbarComponent.ctorParameters = () => [];
SdsToolbarComponent.propDecorators = {
    expandedChange: [{ type: Output }],
    expanded: [{ type: Input }],
    disabled: [{ type: Input }],
    expandedWidth: [{ type: Input }],
    expandedSpace: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SdsToolbarHeaderComponent {
    /**
     * @param {?} toolbar
     */
    constructor(toolbar) {
        this.toolbar = toolbar;
    }
    /**
     * Toggles the expanded state of the toolbar.
     * @return {?}
     */
    _toggle() {
        this.toolbar.toggle();
    }
    /**
     * Gets whether the toolbar is expanded.
     * @return {?}
     */
    get _isExpanded() {
        return this.toolbar.expanded;
    }
    /**
     * Whether the toolbar is disabled.
     * @return {?}
     */
    get _disabled() {
        return this.toolbar.disabled;
    }
}
SdsToolbarHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: "sds-toolbar-header",
                template: "<button\n  class=\"sds-toolbar__toogle-btn\"\n  [attr.id]=\"toolbar._headerId\"\n  [attr.tabindex]=\"_disabled ? -1 : 0\"\n  [attr.aria-controls]=\"toolbar._contentId\"\n  [attr.aria-expanded]=\"_isExpanded\"\n  [attr.aria-disabled]=\"_disabled\"\n  (click)=\"_toggle()\"\n>\n  <div class=\"sds-toolbar__toggle\">\n    <span class=\"usa-sr-only\">Open/Close Toolbar</span>\n  </div>\n</button>\n",
                host: {
                    class: "sds-toolbar__header"
                }
            }] }
];
/** @nocollapse */
SdsToolbarHeaderComponent.ctorParameters = () => [
    { type: SdsToolbarComponent, decorators: [{ type: Host }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SdsToolbarExpandDirective {
    /**
     * @param {?} renderer
     * @param {?} _element
     */
    constructor(renderer, _element) {
        this.renderer = renderer;
        this._element = _element;
    }
    /**
     * References the toolbar instance that the element its associated with.
     * @return {?}
     */
    get toolbar() {
        return this._toolbar;
    }
    /**
     * @param {?} toolbar
     * @return {?}
     */
    set toolbar(toolbar) {
        if (toolbar === this._toolbar) {
            return;
        }
        this._toolbar = toolbar;
        /** Sets toolbar expanded width */
        this._expandedWidth = this._toolbar.expandedSpace;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setStyle(this.toolbar.expanded);
        this.toolbar.expandedChange.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        value => {
            this.setStyle(value);
        }));
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    setStyle(value) {
        if (value) {
            this.renderer.setStyle(this._element.nativeElement, "margin-left", `${this._expandedWidth}`);
        }
        else {
            this.renderer.removeStyle(this._element.nativeElement, "margin-left");
        }
    }
}
SdsToolbarExpandDirective.decorators = [
    { type: Directive, args: [{
                selector: "[sdsToolbarExpand]"
            },] }
];
/** @nocollapse */
SdsToolbarExpandDirective.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
SdsToolbarExpandDirective.propDecorators = {
    toolbar: [{ type: Input, args: ["sdsToolbarExpand",] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SdsToolbarModule {
}
SdsToolbarModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [SdsToolbarComponent, SdsToolbarExpandDirective],
                declarations: [
                    SdsToolbarComponent,
                    SdsToolbarHeaderComponent,
                    SdsToolbarExpandDirective
                ],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const NavigationMode = {
    INTERNAL: 0, EXTERNAL: 1, EVENT: 2, LABEL: 3,
};
NavigationMode[NavigationMode.INTERNAL] = 'INTERNAL';
NavigationMode[NavigationMode.EXTERNAL] = 'EXTERNAL';
NavigationMode[NavigationMode.EVENT] = 'EVENT';
NavigationMode[NavigationMode.LABEL] = 'LABEL';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NavigationHelper {
    /**
     * checks if link is internal
     * @param {?} link
     * @return {?}
     */
    isLinkInternal(link) {
        return link.mode === NavigationMode.INTERNAL;
    }
    /**
     * checks if link is external
     * @param {?} link
     * @return {?}
     */
    isLinkExternal(link) {
        return link.mode === NavigationMode.EXTERNAL;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SdsHeaderComponent {
    constructor() {
        this.mobileNavActive = false;
        /**
         * Navigation helper
         */
        this.navigationHelper = new NavigationHelper();
        /**
         * determines if the top banner is shown
         */
        this.showTopBanner = true;
        this.topBannerDescription = '';
        /**
         * event for event based
         */
        this.linkEvent = new EventEmitter();
    }
    /**
     * Takes in a text string and removes all white space characters and returns the new string
     * @param {?} text
     * @return {?}
     */
    removeWhiteSpace(text) {
        return text.replace(/ /g, '');
    }
    /**
     * seeif any secondary link has a counter
     * @return {?}
     */
    hasCounter() {
        /** @type {?} */
        let hasCounter = false;
        if (this.model) {
            if (this.model.secondaryLinks) {
                this.model.secondaryLinks.forEach((/**
                 * @param {?} item
                 * @return {?}
                 */
                function (item) {
                    if (item.hasCounter) {
                        hasCounter = true;
                    }
                }));
            }
        }
        return hasCounter;
    }
    /**
     * Deselects previous seletion
     * @param {?} id
     * @return {?}
     */
    select(id) {
        this.deselect();
        /** @type {?} */
        let item = this.find(id);
        if (item) {
            item.selected = true;
        }
    }
    /**
     * Deselects all the items in the header model
     * @return {?}
     */
    deselect() {
        if (this.model) {
            if (this.model.home) {
                this.model.home.selected = false;
            }
            if (this.model.navigationLinks) {
                this.model.navigationLinks.forEach((/**
                 * @param {?} item
                 * @return {?}
                 */
                function (item) {
                    item.selected = false;
                    if (item.children) {
                        item.children.forEach((/**
                         * @param {?} child
                         * @return {?}
                         */
                        function (child) {
                            child.selected = false;
                        }));
                    }
                }));
            }
            if (this.model.secondaryLinks) {
                this.model.secondaryLinks.forEach((/**
                 * @param {?} item
                 * @return {?}
                 */
                function (item) {
                    item.selected = false;
                }));
            }
        }
    }
    /**
     * Finds the navigation element by id in the header model
     * @param {?} id of the navigation item
     * @return {?}
     */
    find(id) {
        /** @type {?} */
        let toReturn = null;
        if (this.model) {
            if (this.model.home) {
                if (this.model.home.id === id) {
                    toReturn = this.model.home;
                }
            }
            toReturn = this.findNavigationLinks(id, toReturn);
            if (this.model.secondaryLinks) {
                this.model.secondaryLinks.forEach((/**
                 * @param {?} item
                 * @return {?}
                 */
                function (item) {
                    if (item.id === id) {
                        toReturn = item;
                    }
                }));
            }
        }
        return toReturn;
    }
    /**
     * Searchs the items in the navigation links
     * @private
     * @param {?} id
     * @param {?} toReturn
     * @return {?}
     */
    findNavigationLinks(id, toReturn) {
        if (this.model.navigationLinks) {
            this.model.navigationLinks.forEach((/**
             * @param {?} item
             * @return {?}
             */
            function (item) {
                if (item.id === id) {
                    toReturn = item;
                }
                if (item.children) {
                    item.children.forEach((/**
                     * @param {?} child
                     * @return {?}
                     */
                    function (child) {
                        if (child.id === id) {
                            toReturn = child;
                        }
                    }));
                }
            }));
        }
        return toReturn;
    }
    /**
     * Link clicked and emits the link data into an event
     * @param {?} link
     * @return {?}
     */
    linkClickEvent(link) {
        this.linkEvent.emit(link);
        return false;
    }
    // When the mobile nav is active, and the close box isn't visible,
    // we know the user's viewport has been resized to be larger.
    // Let's make the page state consistent by deactivating the mobile nav.
    /**
     * @param {?} event
     * @return {?}
     */
    onBrowserResize(event) {
        if (this.mobileNavActive &&
            this.closeNavBtn.nativeElement.getBoundingClientRect().width === 0) {
            this.mobileNavActive = false;
        }
    }
    /**
     * @return {?}
     */
    openMobileNav() {
        this.mobileNavActive = true;
    }
    /**
     * @return {?}
     */
    closeMobileNav() {
        this.mobileNavActive = false;
        // The mobile nav was just deactivated, and focus was on the close
        // button, which is no longer visible. We don't want the focus to
        // disappear into the void, so focus on the menu button if it's
        // visible (this may have been what the user was just focused on,
        // if they triggered the mobile nav by mistake).
        this.openNavBtn.nativeElement.focus();
    }
    // The mobile nav was just activated, so focus on the close button,
    /**
     * @return {?}
     */
    navAnimationEnd() {
        this.closeNavBtn.nativeElement.focus();
    }
}
SdsHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'sds-header',
                template: "<sds-top-banner *ngIf=\"showTopBanner\" \n[description]=\"topBannerDescription\"\n></sds-top-banner>\n<div\n  class=\"usa-overlay\"\n  [class.is-visible]=\"mobileNavActive\"\n  (click)=\"closeMobileNav()\"\n></div>\n<header class=\"usa-header usa-header--extended\">\n  <div class=\"usa-navbar\">\n    <div class=\"usa-logo\" id=\"extended-logo\">\n      <ng-container\n        [ngTemplateOutlet]=\"\n          navigationHelper.isLinkInternal(model.home)\n            ? homeLinkRouteTemplate\n            : homeLinkHREFTemplate\n        \"\n        [ngTemplateOutletContext]=\"{ $implicit: model.home }\"\n      ></ng-container>\n    </div>\n    <button #usaNavOpen class=\"usa-menu-btn\" (click)=\"openMobileNav()\">\n      <fa-layers [fixedWidth]=\"true\" size=\"3x\">\n        <fa-icon\n          [icon]=\"['fas', 'square']\"\n          [classes]=\"['text-primary']\"\n        ></fa-icon>\n        <fa-icon\n          [icon]=\"['sds', 'bars']\"\n          [classes]=\"['icon-bars']\"\n          transform=\"shrink-6\"\n        ></fa-icon>\n        <fa-layers-counter\n          *ngIf=\"hasCounter()\"\n          [classes]=\"['icon-layers-counter']\"\n        ></fa-layers-counter>\n      </fa-layers>\n      <span class=\"usa-sr-only\">Menu</span>\n    </button>\n  </div>\n  <nav\n    aria-label=\"Primary navigation\"\n    class=\"usa-nav\"\n    (keydown.esc)=\"closeMobileNav()\"\n    (animationend)=\"navAnimationEnd()\"\n    [class.is-visible]=\"mobileNavActive\"\n    [cdkTrapFocus]=\"mobileNavActive\"\n  >\n    <div class=\"usa-nav__inner\">\n      <button #usaNavClose class=\"usa-nav__close\" (click)=\"closeMobileNav()\">\n        <fa-layers [fixedWidth]=\"true\" size=\"lg\">\n          <fa-icon\n            [icon]=\"['fas', 'circle']\"\n            [inverse]=\"true\"\n            transform=\"grow-2\"\n          ></fa-icon>\n          <fa-icon [icon]=\"['fas', 'times']\" transform=\"shrink-6\"></fa-icon>\n        </fa-layers>\n        <span class=\"usa-sr-only\">Close</span>\n      </button>\n      <ul class=\"usa-nav__primary usa-accordion\">\n        <li\n          *ngFor=\"let link of model.navigationLinks\"\n          class=\"usa-nav__primary-item\"\n        >\n          <ng-container\n            [ngTemplateOutlet]=\"link.route ? linkTemplate : dropDownTemplate\"\n            [ngTemplateOutletContext]=\"{ $implicit: link }\"\n          ></ng-container>\n        </li>\n      </ul>\n      <div class=\"usa-nav__secondary\">\n        <ul class=\"usa-nav__secondary-links\">\n          <li\n            *ngFor=\"let link of model.secondaryLinks\"\n            class=\"usa-nav__secondary-item\"\n          >\n            <ng-container\n              [ngTemplateOutlet]=\"\n                navigationHelper.isLinkInternal(link)\n                  ? secondaryRouteLinkTemplate\n                  : navigationHelper.isLinkExternal(link)\n                  ? secondaryHREFLinkTemplate\n                  : secondaryEVENTLinkTemplate\n              \"\n              [ngTemplateOutletContext]=\"{ $implicit: link }\"\n            ></ng-container>\n          </li>\n        </ul>\n      </div>\n    </div>\n  </nav>\n</header>\n<ng-template #homeLinkRouteTemplate let-home>\n  <a [routerLink]=\"home.route\" title=\"Home\" aria-label=\"Home\">\n    <img class=\"sds-header__logo\" [src]=\"home.logo\" [alt]=\"home.text\" />\n  </a>\n</ng-template>\n\n<ng-template #homeLinkHREFTemplate let-home>\n  <a [attr.href]=\"home.route\" title=\"Home\" aria-label=\"Home\">\n    <img class=\"sds-header__logo\" [src]=\"home.logo\" [alt]=\"home.text\" />\n  </a>\n</ng-template>\n\n<ng-template #secondaryRouteLinkTemplate let-link>\n  <a\n    [attr.id]=\"link.id\"\n    [routerLink]=\"[link.route]\"\n    [attr.class]=\"link.selected ? 'usa-current' : ''\"\n  >\n    <ng-container\n      [ngTemplateOutlet]=\"iconLinkTemplate\"\n      [ngTemplateOutletContext]=\"{ $implicit: link }\"\n    >\n    </ng-container>\n  </a>\n</ng-template>\n\n<ng-template #secondaryHREFLinkTemplate let-link>\n  <a\n    [attr.id]=\"link.id\"\n    [attr.href]=\"[link.route]\"\n    [attr.class]=\"link.selected ? 'usa-current' : ''\"\n  >\n    <ng-container\n      [ngTemplateOutlet]=\"iconLinkTemplate\"\n      [ngTemplateOutletContext]=\"{ $implicit: link }\"\n    >\n    </ng-container>\n  </a>\n</ng-template>\n\n<ng-template #secondaryEVENTLinkTemplate let-link>\n  <a\n    [attr.id]=\"link.id\"\n    (click)=\"linkClickEvent(link)\"\n    href=\"javascript:void(0)\"\n    [attr.class]=\"link.selected ? 'usa-current' : ''\"\n  >\n    <ng-container\n      [ngTemplateOutlet]=\"iconLinkTemplate\"\n      [ngTemplateOutletContext]=\"{ $implicit: link }\"\n    >\n    </ng-container>\n  </a>\n</ng-template>\n\n<ng-template #iconLinkTemplate let-link>\n  <fa-layers [fixedWidth]=\"true\">\n    <fa-icon [icon]=\"[link.imageClassPrefix, link.imageClass]\"></fa-icon>\n    <fa-layers-counter\n      *ngIf=\"link.hasCounter\"\n      [classes]=\"['icon-layers-counter']\"\n    ></fa-layers-counter>\n  </fa-layers>\n  <span class=\"sds-nav__secondary-item-text\">{{ link.text }}</span>\n</ng-template>\n\n<ng-template #linkTemplate let-link>\n  <ng-container\n    [ngTemplateOutlet]=\"\n      navigationHelper.isLinkInternal(link)\n        ? linkRouteTemplate\n        : navigationHelper.isLinkExternal(link)\n        ? linkHREFTemplate\n        : linkEventTemplate\n    \"\n    [ngTemplateOutletContext]=\"{ $implicit: link }\"\n  ></ng-container>\n</ng-template>\n\n<ng-template #linkRouteTemplate let-link>\n  <a\n    [attr.id]=\"link.id\"\n    [attr.class]=\"link.selected ? 'usa-nav__link usa-current' : 'usa-nav__link'\"\n    [routerLink]=\"[link.route]\"\n    ><span>{{ link.text }}</span></a\n  >\n</ng-template>\n\n<ng-template #linkHREFTemplate let-link>\n  <a\n    [attr.id]=\"link.id\"\n    [attr.class]=\"link.selected ? 'usa-nav__link usa-current' : 'usa-nav__link'\"\n    [attr.href]=\"[link.route]\"\n    ><span>{{ link.text }}</span></a\n  >\n</ng-template>\n\n<ng-template #linkEventTemplate let-link>\n  <a\n    [attr.id]=\"link.id\"\n    [attr.class]=\"link.selected ? 'usa-nav__link usa-current' : 'usa-nav__link'\"\n    href=\"javascript:void(0)\"\n    (click)=\"linkClickEvent(link)\"\n    ><span>{{ link.text }}</span></a\n  >\n</ng-template>\n\n<ng-template #dropDownTemplate let-link>\n  <button\n    [attr.id]=\"link.id\"\n    [attr.class]=\"\n      link.selected\n        ? 'usa-accordion__button usa-nav__link usa-current'\n        : 'usa-accordion__button usa-nav__link'\n    \"\n    aria-expanded=\"false\"\n    [attr.aria-controls]=\"removeWhiteSpace(link.text) + '-section'\"\n  >\n    <span>{{ link.text }}</span>\n  </button>\n  <ul\n    [attr.id]=\"removeWhiteSpace(link.text) + '-section'\"\n    class=\"usa-nav__submenu\"\n    hidden\n  >\n    <li *ngFor=\"let childLink of link.children\" class=\"usa-nav__submenu-item\">\n      <ng-container\n        [ngTemplateOutlet]=\"\n          navigationHelper.isLinkInternal(childLink)\n            ? dropDownRouteLinkTemplate\n            : navigationHelper.isLinkExternal(childLink)\n            ? dropDownHREFLinkTemplate\n            : dropDownEVENTLinkTemplate\n        \"\n        [ngTemplateOutletContext]=\"{ $implicit: childLink }\"\n      ></ng-container>\n    </li>\n  </ul>\n</ng-template>\n\n<ng-template #dropDownRouteLinkTemplate let-childLink>\n  <a [routerLink]=\"[childLink.route]\">{{ childLink.text }}</a>\n</ng-template>\n\n<ng-template #dropDownHREFLinkTemplate let-childLink>\n  <a [attr.href]=\"[childLink.route]\">{{ childLink.text }}</a>\n</ng-template>\n\n<ng-template #dropDownEVENTLinkTemplate let-childLink>\n  <a href=\"javascript:void(0)\" (click)=\"linkClickEvent(childLink)\">{{\n    childLink.text\n  }}</a>\n</ng-template>\n",
                styles: [""]
            }] }
];
SdsHeaderComponent.propDecorators = {
    openNavBtn: [{ type: ViewChild, args: ['usaNavOpen',] }],
    closeNavBtn: [{ type: ViewChild, args: ['usaNavClose',] }],
    showTopBanner: [{ type: Input }],
    model: [{ type: Input }],
    topBannerDescription: [{ type: Input }],
    linkEvent: [{ type: Output }],
    onBrowserResize: [{ type: HostListener, args: ['window:resize', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SdsTopBannerComponent {
    constructor() {
        this.showDetail = false;
        this.description = '';
    }
    /**
     * @return {?}
     */
    toggleDetails() {
        this.showDetail = !this.showDetail;
    }
    /**
     * @return {?}
     */
    closeDetail() {
        if (this.showDetail) {
            this.showDetail = false;
        }
    }
}
SdsTopBannerComponent.decorators = [
    { type: Component, args: [{
                selector: 'sds-top-banner',
                template: "<div class=\"usa-banner\">\n  <div class=\"usa-accordion\">\n    <header\n      class=\"usa-banner__header\"\n      [class.sam-banner__header--expanded]=\"showDetail\"\n    >\n      <div class=\"usa-banner__inner\">\n        <div class=\"grid-col-auto\">\n          <span class=\"usa-banner__header-flag\"></span>\n        </div>\n        <div class=\"grid-col-fill tablet:grid-col-auto\">\n          <p class=\"usa-banner__header-text\">\n            An official website of the United States government\n          </p>\n          <p class=\"usa-banner__header-action\" aria-hidden=\"true\">\n            Here\u2019s how you know\n          </p>\n        </div>\n        <button\n          class=\"usa-accordion__button usa-banner__button\"\n          (click)=\"toggleDetails()\"\n          (blur)=\"closeDetail()\"\n          [attr.aria-expanded]=\"showDetail\"\n          aria-controls=\"gov-banner\"\n        >\n          <span class=\"usa-banner__button-text\">Here\u2019s how you know</span>\n        </button>\n        <div class=\"usa-banner__header-description\">\n          <em>{{ description }}</em>\n        </div>\n      </div>\n    </header>\n    <div\n      class=\"usa-banner__content usa-accordion__content\"\n      id=\"gov-banner\"\n      [hidden]=\"!showDetail\"\n    >\n      <div class=\"grid-row grid-gap-lg\">\n        <div class=\"usa-banner__guidance tablet:grid-col-6\">\n          <span class=\"usa-banner__icon usa-media-block__img\"></span>\n          <div class=\"usa-media-block__body\">\n            <p>\n              <strong>The .gov means it\u2019s official.</strong> <br />\n              Federal government websites often end in .gov or .mil. Before\n              sharing sensitive information, make sure you\u2019re on a federal\n              government site.\n            </p>\n          </div>\n        </div>\n        <div class=\"usa-banner__guidance tablet:grid-col-6\">\n          <span class=\"usa-banner__icon usa-media-block__img\"></span>\n          <div class=\"usa-media-block__body\">\n            <p>\n              <strong>The site is secure.</strong> <br />\n              The <strong>https://</strong> ensures that you are connecting to\n              the official website and that any information you provide is\n              encrypted and transmitted securely.\n            </p>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n",
                styles: [""]
            }] }
];
SdsTopBannerComponent.propDecorators = {
    description: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SdsHeaderModule {
}
SdsHeaderModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule, FormsModule, RouterModule, FontAwesomeModule, A11yModule
                ],
                declarations: [SdsHeaderComponent, SdsTopBannerComponent],
                exports: [SdsHeaderComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FooterModel {
}
class FooterLinkSection {
}
class FooterLink {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SdsFooterComponent {
    constructor() {
        /**
         * Navigation helper
         */
        this.navigationHelper = new NavigationHelper();
        this.isCollapsedContent = true;
        /**
         * event for event based
         */
        this.linkEvent = new EventEmitter();
    }
    /**
     * Link clicked and emits the link data into an event
     * @param {?} link
     * @return {?}
     */
    linkClickEvent(link) {
        this.linkEvent.emit(link);
        return false;
    }
}
SdsFooterComponent.decorators = [
    { type: Component, args: [{
                selector: 'sds-footer',
                template: "<footer class=\"usa-footer usa-footer--big\" role=\"contentinfo\">\n\n  <div class=\"sds-feedback\">\n    <button type=\"button\" class=\"sds-feedback__button\" [attr.aria-expanded]=\"!isCollapsedContent\" aria-controls=\"collapseID\" (click)=\"isCollapsedContent = !isCollapsedContent\">\n      <fa-layers [fixedWidth]=\"true\" size=\"2x\">\n        <fa-icon [icon]=\"['fas', 'circle']\" [sdsCollapse]=\"isCollapsedContent\" class=\"text-base-light margin-auto\"></fa-icon>\n        <fa-icon [icon]=\"['sds', 'arrow-up']\" [sdsCollapse]=\"isCollapsedContent\" transform=\"shrink-6\"></fa-icon>\n        <fa-icon [icon]=\"['fas', 'circle']\" [sdsCollapse]=\"!isCollapsedContent\" class=\"text-primary margin-auto\"></fa-icon>\n        <fa-icon [icon]=\"['sds', 'arrow-down']\" [sdsCollapse]=\"!isCollapsedContent\" transform=\"shrink-6\"></fa-icon>\n      </fa-layers>\n      <span class=\"sds-feedback__title\">Feedback</span>\n    </button>\n    <div id=\"collapseID\" [sdsCollapse]=\"isCollapsedContent\" class=\"sds-feedback__response\">\n      <div class=\"tablet:width-tablet-lg padding-4 margin-auto\">\n        <span class=\"sds-feedback__response-title\">One Question </span>\n        <span class=\"sds-feedback__response-title-thin\"> Survey</span>\n        <p class=\"sds-feedback__response-text\">What changes or improvements would you suggest?</p>\n        <input class=\"sds-feedback__input\" type=\"text\">\n        <button class=\"usa-button usa-button--secondary margin-y-2 float-right\">Submit</button>\n      </div>\n    </div>\n  </div>\n\n  <div class=\"usa-footer__primary-section\">\n    <div class=\"grid-container\">\n      <div class=\"grid-row grid-gap\">\n        <div class=\"mobile-lg:grid-col-12 tablet:grid-col-4\">\n          <div\n            class=\"usa-footer__logo grid-row mobile-lg:grid-gap-1 margin-top-3\"\n          >\n            <div\n              class=\"mobile-lg:grid-col-3 mobile-lg:grid-offset-3 tablet:grid-offset-none tablet:grid-col-auto\"\n            >\n              <img\n                *ngIf=\"model.footerLogo\"\n                class=\"usa-footer__logo-img\"\n                [attr.src]=\"model.footerLogo.imageSourcePath\"\n                [attr.alt]=\"model.footerLogo.imageAltText\"\n              />\n              <a\n                *ngIf=\"!model.footerLogo\"\n                class=\"usa-footer__logo-text\"\n                target=\"_blank\"\n                href=\"http://gsa.gov\"\n              >\n                GSA.gov\n              </a>\n            </div>\n            <div class=\"mobile-lg:grid-col-4 tablet:grid-col-auto\">\n              <span class=\"usa-footer__logo-heading\">\n                {{\n                  model.footerLogo?.text || 'General Services Administration'\n                }}\n              </span>\n            </div>\n          </div>\n        </div>\n        <div class=\"mobile-lg:grid-col-12 tablet:grid-col-8\">\n          <nav class=\"usa-footer__nav\">\n            <div class=\"grid-row grid-gap-4\">\n              <div\n                class=\"mobile-lg:grid-col-12 desktop:grid-col-4\"\n                *ngFor=\"let section of model.linkSections\"\n              >\n                <section\n                  class=\"usa-footer__primary-content usa-footer__primary-content--collapsible\"\n                >\n                  <span class=\"usa-footer__primary-link\">{{\n                    section.text\n                  }}</span>\n                  <ul class=\"usa-list usa-list--unstyled\">\n                    <li\n                      class=\"usa-footer__secondary-link\"\n                      *ngFor=\"let link of section.links\"\n                    >\n                      <ng-container\n                        [ngTemplateOutlet]=\"\n                          navigationHelper.isLinkInternal(link)\n                            ? footerRouteLinkTemplate\n                            : navigationHelper.isLinkExternal(link)\n                            ? footerHREFLinkTemplate\n                            : footerEVENTLinkTemplate\n                        \"\n                        [ngTemplateOutletContext]=\"{ $implicit: link }\"\n                      ></ng-container>\n                    </li>\n                  </ul>\n                </section>\n              </div>\n            </div>\n          </nav>\n        </div>\n      </div>\n    </div>\n  </div>\n  <div class=\"usa-footer__secondary-section\">\n    <div class=\"grid-container\">\n      <div class=\"grid-row\">\n        <div class=\"grid-col-12\">\n          <p class=\"font-body-2xs line-height-sans-4 margin-top-0\">\n            This is a U.S. General Services Administration Federal Government\n            computer system that is\n            <strong>\"FOR OFFICIAL USE ONLY.\"</strong> This system is subject to\n            monitoring. Individuals found performing unauthorized activities are\n            subject to disciplinary action including criminal prosecution.\n          </p>\n        </div>\n      </div>\n    </div>\n  </div>\n</footer>\n\n<ng-template #footerRouteLinkTemplate let-link>\n  <a [routerLink]=\"[link.route]\">{{ link.text }}</a>\n</ng-template>\n\n<ng-template #footerHREFLinkTemplate let-link>\n  <a [attr.href]=\"[link.route]\">{{ link.text }}</a>\n</ng-template>\n\n<ng-template #footerEVENTLinkTemplate let-link>\n  <a href=\"javascript:void(0)\" (click)=\"linkClickEvent(link)\">{{\n    link.text\n  }}</a>\n</ng-template>\n",
                styles: [""]
            }] }
];
SdsFooterComponent.propDecorators = {
    model: [{ type: Input }],
    isCollapsedContent: [{ type: Input }],
    linkEvent: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CollapseDirective {
    constructor() {
        this.collapsed = true;
    }
}
CollapseDirective.decorators = [
    { type: Directive, args: [{
                selector: '[sdsCollapse]',
                exportAs: 'sdsCollapse',
                host: { '[class.display-none]': 'collapsed' }
            },] }
];
/** @nocollapse */
CollapseDirective.ctorParameters = () => [];
CollapseDirective.propDecorators = {
    collapsed: [{ type: Input, args: ['sdsCollapse',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SdsCollapseModule {
}
SdsCollapseModule.decorators = [
    { type: NgModule, args: [{
                declarations: [CollapseDirective],
                imports: [
                    CommonModule
                ],
                exports: [CollapseDirective]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SdsFooterModule {
}
SdsFooterModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule, FormsModule, RouterModule, SdsCollapseModule, FontAwesomeModule
                ],
                declarations: [SdsFooterComponent],
                exports: [SdsFooterComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PaginationModel {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PaginationComponent {
    /**
     * @param {?} change
     */
    constructor(change) {
        this.change = change;
        /**
         * Output of the page model object
         */
        this.pageChange = new EventEmitter();
        /**
         * Pagination model
         */
        this.page = new PaginationModel();
        /**
         * debounce time for current page input
         */
        this.debounceTime = 500;
        /**
         * Drop down options for page size
         */
        this.options = [
            { label: '25', value: 25 },
            { label: '50', value: 50 },
            { label: '100', value: 100 }
        ];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.maintainPreviousValue();
    }
    /**
     * Stores the previous number. Used when focus out if field empty
     * @private
     * @return {?}
     */
    maintainPreviousValue() {
        this.previousNumber = this.page.pageNumber.valueOf();
    }
    /**
     * previous page lowers page number by one within range
     * @return {?}
     */
    previousPage() {
        if (this.page.pageNumber > 1) {
            this.page.pageNumber--;
            this.maintainPreviousValue();
            this.pageChange.emit(this.page);
        }
    }
    /**
     * next page increase page number by one within range
     * @return {?}
     */
    nextPage() {
        if (this.page.pageNumber < this.page.totalPages) {
            this.page.pageNumber++;
            this.maintainPreviousValue();
            this.pageChange.emit(this.page);
        }
    }
    /**
     * current page changes sets new value if within range
     * @param {?=} newValue
     * @return {?}
     */
    valuechange(newValue) {
        window.clearTimeout(this.timeoutNumber);
        this.timeoutNumber = window.setTimeout((/**
         * @return {?}
         */
        () => {
            if (newValue || newValue === 0) {
                newValue = this.handleInputOutsideBounds(newValue);
                if (newValue >= 1 && newValue <= this.page.totalPages) {
                    this.page.pageNumber = newValue;
                    this.maintainPreviousValue();
                    this.pageChange.emit(this.page);
                    this.change.detectChanges();
                }
            }
            else {
                if (this.page.pageNumber) {
                    this.maintainPreviousValue();
                }
            }
        }), this.debounceTime);
    }
    /**
     * adjusts the value if not within the page limit above or below
     * @private
     * @param {?=} newValue handles
     * @return {?}
     */
    handleInputOutsideBounds(newValue) {
        if (newValue < 1) {
            newValue = 1;
            this.currentPageField.nativeElement.value = newValue;
        }
        else if (newValue > this.page.totalPages) {
            newValue = this.page.totalPages;
            this.currentPageField.nativeElement.value = newValue;
        }
        return newValue;
    }
    /**
     * current page focus out will replace with previous valid if empty
     * @return {?}
     */
    currentPageFocusOut() {
        if (this.currentPageField.nativeElement.value === '') {
            this.currentPageField.nativeElement.value = this.page.pageNumber = this.previousNumber;
            this.change.detectChanges();
        }
    }
    /**
     * page size selection change
     * @return {?}
     */
    onSelectChange() {
        this.page.pageNumber = 1;
        this.pageChange.emit(this.page);
    }
}
PaginationComponent.decorators = [
    { type: Component, args: [{
                selector: 'sds-pagination',
                template: "<div class=\"sds-pagination\">\n  <div class=\"sds-pagination__controls\">\n    <button [attr.id]=\"paginationConfiguration.id +'-previousPage'\" (click)=\"previousPage()\">Previous Page</button>\n    <label class=\"usa-label font-sans-3xs margin-top-1 text-italic text-base usa-sr-only\"\n      [attr.for]=\"paginationConfiguration.id + '-currentPage'\">Current Page</label>\n    <input [attr.id]=\"paginationConfiguration.id +'-currentPage'\"\n      class=\"usa-input height-3 width-4 line-height-05 font-sans-3xs text-center border-base-light\" #currentPage\n      (ngModelChange)=\"valuechange($event)\" [(ngModel)]=\"page.pageNumber\" type=\"number\" min=\"1\"\n      [(attr.max)]=\"page.totalPages\" (focusout)=\"currentPageFocusOut()\" aria-label=\"current page\" />\n    <span class=\"sds-pagination__total\">\n      of <strong>{{ page.totalPages }}</strong>\n    </span>\n    <button [attr.id]=\"paginationConfiguration.id +'-nextPage'\" (click)=\"nextPage()\">Next Page</button>\n  </div>\n  <div class=\"sds-pagination__results\">\n    <label class=\"usa-label font-sans-3xs text-italic text-base\"\n      [attr.for]=\"paginationConfiguration.id + '-select'\">Results per page</label>\n    <select class=\"usa-select usa-select--small border-base-light\" [attr.id]=\"paginationConfiguration.id + '-select'\"\n      (change)=\"onSelectChange()\" [(ngModel)]=\"page.pageSize\">\n      <option *ngFor=\"let item of options\" [ngValue]=\"item.value\">\n        {{ item.label }}\n      </option>\n    </select>\n  </div>\n</div>\n",
                styles: ["input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}input[type=number]{-moz-appearance:textfield}"]
            }] }
];
/** @nocollapse */
PaginationComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
PaginationComponent.propDecorators = {
    currentPageField: [{ type: ViewChild, args: ['currentPage',] }],
    pageChange: [{ type: Output }],
    page: [{ type: Input }],
    paginationConfiguration: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PaginationModule {
}
PaginationModule.decorators = [
    { type: NgModule, args: [{
                declarations: [PaginationComponent],
                imports: [
                    CommonModule, FormsModule
                ],
                exports: [PaginationComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SDSSelectedItemModel {
    /**
     * @param {?=} items
     */
    constructor(items) {
        this.items = items ? [...items] : [];
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SDSSelectedItemModelHelper {
    /**
     *  adds an item to the collection
     * if selected mode is single it removes any existing items
     * also checks to see if that item already exists
     * keyfield is used to determine uniqueness of the item added
     * @param {?} itemToAdd
     * @param {?} keyField
     * @param {?} selectionMode
     * @param {?} items
     * @return {?}
     */
    static addItem(itemToAdd, keyField, selectionMode, items) {
        if (!SDSSelectedItemModelHelper.contatinsItem(itemToAdd[keyField], keyField, items)) {
            if (selectionMode === SelectionMode.SINGLE) {
                SDSSelectedItemModelHelper.clearItems(items);
            }
            items.push(itemToAdd);
        }
    }
    /**
     * adds an array of items to the list and will not add duplicate items
     * keyfield is used to determine uniqueness of the item added
     * @param {?} toAddItems
     * @param {?} keyField
     * @param {?} selectionMode
     * @param {?} items
     * @return {?}
     */
    static addItems(toAddItems, keyField, selectionMode, items) {
        for (let i = 0; i < toAddItems.length; i++) {
            SDSSelectedItemModelHelper.addItem(toAddItems[i], keyField, selectionMode, items);
        }
    }
    /**
     * removes the item from the list
     * keyfield is used to determine uniqueness of the item added
     * @param {?} item
     * @param {?} keyField
     * @param {?} items
     * @return {?}
     */
    static removeItem(item, keyField, items) {
        if (SDSSelectedItemModelHelper.contatinsItem(item[keyField], keyField, items)) {
            items.splice(items.indexOf(item), 1);
        }
    }
    /**
     * checks to see if a particular item exists by the provied key
     * keyfield is used to determine uniqueness of the item added
     * @param {?} key
     * @param {?} keyField
     * @param {?} items
     * @return {?}
     */
    static contatinsItem(key, keyField, items) {
        /** @type {?} */
        let item = items.find((/**
         * @param {?} o
         * @return {?}
         */
        o => o[keyField] === key));
        return item !== null && item !== undefined;
    }
    /**
     * Clears the list of items
     * @param {?} items
     * @return {?}
     */
    static clearItems(items) {
        while (items.length > 0) {
            items.pop();
        }
    }
    /**
     * updates an array of items to the list and will not add duplicate items
     * keyfield is used to determine uniqueness of the item added
     * @param {?} selectedItems
     * @param {?} keyField
     * @param {?} selectionMode
     * @param {?} items
     * @return {?}
     */
    static replaceItems(selectedItems, keyField, selectionMode, items) {
        //Clears Old List
        SDSSelectedItemModelHelper.clearItems(items);
        //Adds new List
        SDSSelectedItemModelHelper.addItems(selectedItems, keyField, selectionMode, items);
    }
}
/** @enum {number} */
const SelectionMode = {
    SINGLE: 0, MULTIPLE: 1,
};
SelectionMode[SelectionMode.SINGLE] = 'SINGLE';
SelectionMode[SelectionMode.MULTIPLE] = 'MULTIPLE';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SDSAutocompletelConfiguration {
    /**
     * sets the default debounce time to 250 milliseconds
     */
    constructor() {
        /**
         * Mode of the model either allows a single item or multiple items
         */
        this.selectionMode = SelectionMode.SINGLE;
        /**
         * Allows option to allow user text not in the standard results
         */
        this.isFreeTextEnabled = false;
        /**
         * Text appeneded ad the end of free text
         */
        this.freeTextSubtext = 'search';
        /**
         * Focus into autocomplete search
         */
        this.focusInSearch = true;
        /**
         * The aria-label for the auto-complete
         */
        this.ariaLabelText = 'Auto Complete';
        /**
         * To enable the tag mode
         */
        this.isTagModeEnabled = false;
        /**
         * To make input readonly
         */
        this.inputReadOnly = false;
        this.debounceTime = 250;
        this.minimumCharacterCountSearch = 0;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const Autocomplete_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef((/**
     * @return {?}
     */
    () => SDSAutocompleteComponent)),
    multi: true
};
class SDSAutocompleteComponent {
    /**
     * @param {?} cd
     */
    constructor(cd) {
        this.cd = cd;
        /**
         * Stored Event for ControlValueAccessor
         */
        this.onTouched = (/**
         * @return {?}
         */
        () => { });
        /**
         * Stored Event for ControlValueAccessor
         */
        this.onChange = (/**
         * @param {?} _
         * @return {?}
         */
        (_) => { });
    }
    // ControlValueAccessor (and Formly) is trying to update the value of the FormControl (our custom component) programatically
    // If there is a value we will just overwrite items
    // If there is no value we reset the items array to be empty
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value instanceof SDSSelectedItemModel && value.items && value.items.length && this.model.items !== value.items) {
            this.model.items = [...value.items];
            this.cd.markForCheck();
        }
        else if (value && value.length && this.model.items !== value) {
            this.model.items = value;
            this.cd.markForCheck();
        }
        else {
            if (!this.model || !(this.model instanceof SDSSelectedItemModel)) {
                this.model = new SDSSelectedItemModel();
            }
            this.model.items = value && value.items ? value.items : [];
            this.cd.markForCheck();
        }
    }
    // Method that is fired when the child component event notifies us that the items array has been modified within the child component
    /**
     * @param {?} $event
     * @return {?}
     */
    updateItems($event) {
        this.updateModel();
    }
    // Helper method that gets a new instance of the model and notifies ControlValueAccessor that we have a new model for this FormControl (our custom component)
    /**
     * @return {?}
     */
    updateModel() {
        /** @type {?} */
        const model = this.getModel();
        this.onChange(model);
    }
    // Helper method to return a new instance of an array that contains our items
    /**
     * @return {?}
     */
    getModel() {
        return [...this.model.items];
    }
    // ControlValueAccessor hook that lets us call this._onChange(var) to let the form know our variable has changed (in this case model)
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    // ControlValueAccessor hook (not used)
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * @return {?}
     */
    isSingleMode() {
        if (this.configuration) {
            return this.configuration.selectionMode === SelectionMode.SINGLE;
        }
        else {
            return false;
        }
    }
}
SDSAutocompleteComponent.decorators = [
    { type: Component, args: [{
                selector: 'sds-autocomplete',
                template: "<sds-search-autocomplete [disabled]=\"disabled\" (ngModelChange)=\"updateItems($event)\" #autocomplete\n    [service]=\"service\" [(ngModel)]=\"model\" [configuration]=\"configuration\" [itemTemplate]=\"suggestionTemplate\">\n</sds-search-autocomplete>\n<sds-selected-result (ngModelChange)=\"updateItems($event)\" [disabled]=\"disabled\" *ngIf=\"!isSingleMode()\"\n    [(ngModel)]=\"model\" [configuration]=\"configuration\" [itemTemplate]=\"selectedItemTemplate\"></sds-selected-result>\n",
                providers: [Autocomplete_VALUE_ACCESSOR],
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [""]
            }] }
];
/** @nocollapse */
SDSAutocompleteComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
SDSAutocompleteComponent.propDecorators = {
    suggestionTemplate: [{ type: Input }],
    selectedItemTemplate: [{ type: Input }],
    configuration: [{ type: Input }],
    service: [{ type: Input }],
    onTouched: [{ type: HostListener, args: ['focusout',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SDSSelectedResultConfiguration {
    constructor() {
        /**
         * Mode of the model either allows a single item or multiple items
         */
        this.selectionMode = SelectionMode.SINGLE;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const SDS_SelectedResult_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef((/**
     * @return {?}
     */
    () => SDSSelectedResultComponent)),
    multi: true
};
class SDSSelectedResultComponent {
    constructor() {
        /**
         * Stored Event for ControlValueAccessor
         */
        this.onTouchedCallback = (/**
         * @return {?}
         */
        () => null);
        /**
         * Stored Event for ControlValueAccessor
         */
        this.propogateChange = (/**
         * @param {?} _
         * @return {?}
         */
        (_) => null);
    }
    /**
     * Removes item from the model
     * @param {?} item
     * @return {?}
     */
    removeItem(item) {
        if (!this.disabled) {
            SDSSelectedItemModelHelper.removeItem(item, this.configuration.primaryKeyField, this.model.items);
            this.propogateChange(this.model);
            this.onTouchedCallback();
        }
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    writeValue(obj) {
        if (obj instanceof SDSSelectedItemModel) {
            this.model = (/** @type {?} */ (obj));
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.propogateChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * Gets the string value from the specifed properties of an object
     * @param {?} object
     * @param {?} propertyFields comma seperated list with periods depth of object
     * @return {?}
     */
    getObjectValue(object, propertyFields) {
        /** @type {?} */
        let value = '';
        /** @type {?} */
        let current = object;
        /** @type {?} */
        let fieldSplit = propertyFields.split(',');
        for (let i = 0; i < fieldSplit.length; i++) {
            /** @type {?} */
            let fieldValue = fieldSplit[i];
            /** @type {?} */
            let fieldPartSplit = fieldValue.split('.');
            for (let j = 0; j < fieldPartSplit.length; j++) {
                /** @type {?} */
                let fieldCheckValue = fieldPartSplit[j];
                if (current) {
                    current = current[fieldCheckValue];
                }
            }
            if (current) {
                value += current.toString() + ' ';
            }
            current = object;
        }
        return value.trim();
    }
}
SDSSelectedResultComponent.decorators = [
    { type: Component, args: [{
                selector: 'sds-selected-result',
                template: "<ul  *ngIf=\"model\" [attr.aria-label]=\"configuration.labelText +' results'\" class=\"usa-list usa-list--unstyled sds-autocomplete-selected\" aria-relevant=\"additions\" role=\"listbox\" aria-live=\"polite\">\n    <li role=\"option\" *ngFor=\"let result of model.items; let i = index\">\n        <div [attr.class]=\" disabled ? 'sds-tag sds-tag--chip sds-autocomplete-selected__item sds-autocomplete-selected__item--disabled' :'sds-tag sds-tag--chip sds-autocomplete-selected__item'\">\n            <ng-container *ngIf=\"itemTemplate\" [ngTemplateOutlet]=\"itemTemplate\" [ngTemplateOutletContext]=\"{$implicit:result}\">\n            </ng-container>\n            <ng-container *ngIf=\"!itemTemplate\">\n                <span class=\"display-block text-semibold\"> {{ getObjectValue(result, configuration.primaryTextField) }}\n                </span>\n                <ng-container *ngIf=\"configuration.secondaryTextField && result[configuration.secondaryTextField] \">\n                    {{ result[configuration.secondaryTextField] }}\n                </ng-container>\n            </ng-container>\n            <button [attr.aria-label]=\"'Remove Item ' + getObjectValue(result, configuration.primaryTextField)\" [class.text-base]=\"disabled\" aria-hidden=\"false\" class=\"sds-tag__close  position-absolute right-1 top-2px\" (click)=\"removeItem(result)\" (keyup.enter)=\"removeItem(result)\">\n        <fa-icon [icon]=\"['fas', 'times']\" size=\"sm\"></fa-icon>\n      </button>\n        </div>\n    </li>\n</ul>",
                providers: [SDS_SelectedResult_VALUE_ACCESSOR],
                styles: [""]
            }] }
];
SDSSelectedResultComponent.propDecorators = {
    itemTemplate: [{ type: Input }],
    configuration: [{ type: Input }],
    disabled: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SdsSelectedResultsModule {
}
SdsSelectedResultsModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule, RouterModule, FontAwesomeModule],
                declarations: [SDSSelectedResultComponent],
                exports: [SDSSelectedResultComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class KeyHelper {
    /**
     * @param {...?} keys
     */
    constructor(...keys) {
        this._allowedKeys = [];
        this._currentlySupported = [
            'enter', 'up', 'down', 'left', 'right', 'tab', 'esc', 'space',
            'shift', 'backspace', '1', '2', '3', '4', '5', '6', '7', '8',
            '9', '0', 'delete'
        ];
        this._setAllowedKeys(...keys);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    isAllowed(event) {
        /** @type {?} */
        const val = this._allowedKeys
            .reduce((/**
         * @param {?} val
         * @param {?} key
         * @return {?}
         */
        (val, key) => {
            return KeyHelper.is(key, event) || val;
        }), false);
        return val;
    }
    /**
     * @private
     * @param {...?} keys
     * @return {?}
     */
    _setAllowedKeys(...keys) {
        keys.forEach((/**
         * @param {?} key
         * @return {?}
         */
        key => {
            if (this._currentlySupported.indexOf(key) !== -1) {
                this._allowedKeys.push(key);
            }
            else {
                /** @type {?} */
                const ok = this._allowedToString();
                /** @type {?} */
                const msg = `Only supports ${ok} at this time`;
                throw new TypeError(msg);
            }
        }));
    }
    /**
     * @private
     * @return {?}
     */
    _allowedToString() {
        return this._allowedKeys.join(', ');
    }
    /**
     * @param {?} event
     * @return {?}
     */
    static getKeyCode(event) {
        if (!event) {
            return undefined;
        }
        else if (event.key) {
            return event.key;
        }
        else if (event.code) {
            return event.code;
        }
        else if (event.keyIdentifier) {
            return event.keyIdentifier;
        }
        else {
            return undefined;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    static getNumberFromKey(event) {
        /** @type {?} */
        const tests = [
            KeyHelper._zero, KeyHelper._one, KeyHelper._two,
            KeyHelper._three, KeyHelper._four, KeyHelper._five,
            KeyHelper._six, KeyHelper._seven, KeyHelper._eight,
            KeyHelper._nine
        ];
        return tests.reduce((/**
         * @param {?} val
         * @param {?} test
         * @return {?}
         */
        (val, test) => {
            return val !== undefined
                ? val
                : test(event);
        }), undefined);
    }
    /**
     * @param {?} validKeyParam
     * @param {?} event
     * @return {?}
     */
    static is(validKeyParam, event) {
        /** @type {?} */
        let lowercased = validKeyParam.toLowerCase();
        switch (lowercased) {
            case 'enter':
                return this._isEnter(event);
            case 'up':
                return this._isArrowUp(event);
            case 'down':
                return this._isArrowDown(event);
            case 'left':
                return this._isArrowLeft(event);
            case 'right':
                return this._isArrowRight(event);
            case 'tab':
                return this._isTab(event);
            case 'esc':
                return this._isEscape(event);
            case 'space':
                return this._isSpace(event);
            case 'shift':
                return this._isShift(event);
            case 'backspace':
                return this._isBackspace(event);
            case 'delete':
                return this._isDelete(event);
            case '0':
                return this._isExpectedNumber(0, event);
            case '1':
                return this._isExpectedNumber(1, event);
            case '2':
                return this._isExpectedNumber(2, event);
            case '3':
                return this._isExpectedNumber(3, event);
            case '4':
                return this._isExpectedNumber(4, event);
            case '5':
                return this._isExpectedNumber(5, event);
            case '6':
                return this._isExpectedNumber(6, event);
            case '7':
                return this._isExpectedNumber(7, event);
            case '8':
                return this._isExpectedNumber(8, event);
            case '9':
                return this._isExpectedNumber(9, event);
            default:
                return false;
        }
    }
    /**
     * @private
     * @param {?} e
     * @return {?}
     */
    static _isEnter(e) {
        if (e.code === 'Enter'
            || e.key === 'Enter'
            || e.keyIdentifier === 'Enter'
            || e.which === 13
            || e.charCode === 13
            || e.keyCode === 13) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @private
     * @param {?} e
     * @return {?}
     */
    static _isArrowUp(e) {
        if (e.code === 'ArrowUp'
            || e.key === 'ArrowUp'
            || e.key === 'Up'
            || e.keyIdentifier === 'Up'
            || e.which === 38
            || e.keyCode === 38) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @private
     * @param {?} e
     * @return {?}
     */
    static _isArrowDown(e) {
        if (e.code === 'ArrowDown'
            || e.key === 'ArrowDown'
            || e.key === 'Down'
            || e.keyIdentifier === 'Down'
            || e.which === 40
            || e.keyCode === 40) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @private
     * @param {?} e
     * @return {?}
     */
    static _isArrowLeft(e) {
        if (e.code === 'ArrowLeft'
            || e.key === 'ArrowLeft'
            || e.key === 'Left'
            || e.keyIdentifier === 'Left'
            || e.which === 37
            || e.keyCode === 37) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @private
     * @param {?} e
     * @return {?}
     */
    static _isArrowRight(e) {
        if (e.code === 'ArrowRight'
            || e.key === 'ArrowRight'
            || e.key === 'Right'
            || e.keyIdentifier === 'Right'
            || e.which === 39
            || e.keyCode === 39) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @private
     * @param {?} e
     * @return {?}
     */
    static _isTab(e) {
        if (e.code === 'Tab'
            || e.key === 'Tab'
            || e.keyIdentifier === 'U+0009'
            || e.which === 9
            || e.keyCode === 9) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @private
     * @param {?} e
     * @return {?}
     */
    static _isEscape(e) {
        if (e.code === 'Escape'
            || e.key === 'Escape'
            || e.key === 'Esc'
            || e.keyIdentifier === 'U+001B'
            || e.which === 27
            || e.keyCode === 27) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @private
     * @param {?} e
     * @return {?}
     */
    static _isSpace(e) {
        if (e.code === 'Space'
            || e.key === ' '
            || e.key === 'Spacebar'
            || e.keyIdentifier === 'U+0020'
            || e.which === 32
            || e.keyCode === 32) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @private
     * @param {?} e
     * @return {?}
     */
    static _isShift(e) {
        if (e.code === 'ShiftLeft'
            || e.code === 'ShiftRight'
            || e.key === 'Shift'
            || e.keyIdentifier === 'Shift'
            || e.which === 16
            || e.keyCode === 16) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @private
     * @param {?} e
     * @return {?}
     */
    static _isBackspace(e) {
        if (e.code === 'Backspace'
            || e.key === 'Backspace'
            || e.keyIdentifier === 'U+0008'
            || e.which === 8
            || e.keyCode === 8) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @private
     * @param {?} e
     * @return {?}
     */
    static _isDelete(e) {
        if (e.code === 'Delete'
            || e.key === 'Delete'
            || e.keyIdentifier === 'U+007F'
            || e.which === 46
            || e.keyCode === 46) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @private
     * @param {?} e
     * @return {?}
     */
    static _zero(e) {
        if (e.code === 'Digit0'
            || e.code === 'Numpad0'
            || e.key === 0
            || e.keyCode === 48
            || e.keyCode === 96
            || e.keyIdentifier === 'U+0030'
            || e.which === 48) {
            return 0;
        }
        else {
            return undefined;
        }
    }
    /**
     * @private
     * @param {?} e
     * @return {?}
     */
    static _one(e) {
        if (e.code === 'Digit1'
            || e.code === 'Numpad1'
            || e.key === 1
            || e.keyCode === 49
            || e.keyCode === 97
            || e.keyIdentifier === 'U+0031'
            || e.which === 49) {
            return 1;
        }
        else {
            return undefined;
        }
    }
    /**
     * @private
     * @param {?} e
     * @return {?}
     */
    static _two(e) {
        if (e.code === 'Digit2'
            || e.code === 'Numpad2'
            || e.key === 2
            || e.keyCode === 50
            || e.keyCode === 98
            || e.keyIdentifier === 'U+0032'
            || e.which === 50) {
            return 2;
        }
        else {
            return undefined;
        }
    }
    /**
     * @private
     * @param {?} e
     * @return {?}
     */
    static _three(e) {
        if (e.code === 'Digit3'
            || e.code === 'Numpad3'
            || e.key === 3
            || e.keyCode === 51
            || e.keyCode === 99
            || e.keyIdentifier === 'U+0033'
            || e.which === 51) {
            return 3;
        }
        else {
            return undefined;
        }
    }
    /**
     * @private
     * @param {?} e
     * @return {?}
     */
    static _four(e) {
        if (e.code === 'Digit4'
            || e.code === 'Numpad4'
            || e.key === 4
            || e.keyCode === 52
            || e.keyCode === 100
            || e.keyIdentifier === 'U+0034'
            || e.which === 52) {
            return 4;
        }
        else {
            return undefined;
        }
    }
    /**
     * @private
     * @param {?} e
     * @return {?}
     */
    static _five(e) {
        if (e.code === 'Digit5'
            || e.code === 'Numpad5'
            || e.key === 5
            || e.keyCode === 53
            || e.keyCode === 101
            || e.keyIdentifier === 'U+0035'
            || e.which === 53) {
            return 5;
        }
        else {
            return undefined;
        }
    }
    /**
     * @private
     * @param {?} e
     * @return {?}
     */
    static _six(e) {
        if (e.code === 'Digit6'
            || e.code === 'Numpad6'
            || e.key === 6
            || e.keyCode === 54
            || e.keyCode === 102
            || e.keyIdentifier === 'U+0036'
            || e.which === 54) {
            return 6;
        }
        else {
            return undefined;
        }
    }
    /**
     * @private
     * @param {?} e
     * @return {?}
     */
    static _seven(e) {
        if (e.code === 'Digit7'
            || e.code === 'Numpad7'
            || e.key === 7
            || e.keyCode === 55
            || e.keyCode === 103
            || e.keyIdentifier === 'U+0037'
            || e.which === 55) {
            return 7;
        }
        else {
            return undefined;
        }
    }
    /**
     * @private
     * @param {?} e
     * @return {?}
     */
    static _eight(e) {
        if (e.code === 'Digit8'
            || e.code === 'Numpad8'
            || e.key === 8
            || e.keyCode === 56
            || e.keyCode === 104
            || e.keyIdentifier === 'U+0038'
            || e.which === 56) {
            return 8;
        }
        else {
            return undefined;
        }
    }
    /**
     * @private
     * @param {?} e
     * @return {?}
     */
    static _nine(e) {
        if (e.code === 'Digit9'
            || e.code === 'Numpad9'
            || e.key === 9
            || e.keyCode === 57
            || e.keyCode === 105
            || e.keyIdentifier === 'U+0039'
            || e.which === 57) {
            return 9;
        }
        else {
            return undefined;
        }
    }
    /**
     * @private
     * @param {?} expected
     * @param {?} event
     * @return {?}
     */
    static _isExpectedNumber(expected, event) {
        return expected === KeyHelper.getNumberFromKey(event);
    }
}
/** @enum {string} */
const KEYS = {
    'ENTER': 'enter',
    'UP': 'up',
    'DOWN': 'down',
    'LEFT': 'left',
    'RIGHT': 'right',
    'TAB': 'tab',
    'ESC': 'esc',
    'SPACE': 'space',
    'SHIFT': 'shift',
    'BACKSPACE': 'backspace',
    'ONE': '1',
    'TWO': '2',
    'THREE': '3',
    'FOUR': '4',
    'FIVE': '5',
    'SIX': '6',
    'SEVEN': '7',
    'EIGHT': '8',
    'NINE': '9',
    'ZERO': '0',
    'DELETE': 'delete',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const Autocomplete_Autocomplete_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef((/**
     * @return {?}
     */
    () => SDSAutocompleteSearchComponent)),
    multi: true
};
class SDSAutocompleteSearchComponent {
    /**
     * @param {?} _changeDetectorRef
     */
    constructor(_changeDetectorRef) {
        this._changeDetectorRef = _changeDetectorRef;
        /**
         * selected index
         */
        this.highlightedIndex = 0;
        /**
         * value of the input field
         */
        this.inputValue = '';
        /**
         * Proprty being set on the object is highlighted
         */
        this.HighlightedPropertyName = 'highlighted';
        this.showLoad = true;
        /**
         * Search string
         */
        this.searchString = null;
        /**
         * To make input readonly
         */
        this.inputReadOnly = false;
        /**
         * Used to store selected items
         */
        this.items = [];
        /**
         * Stored Event for ControlValueAccessor
         */
        this.onTouchedCallback = (/**
         * @return {?}
         */
        () => null);
        /**
         * Stored Event for ControlValueAccessor
         */
        this.propogateChange = (/**
         * @param {?} _
         * @return {?}
         */
        (_) => null);
        this.resultsAvailableMessage = ' results available. Use up and down arrows\
  to scroll through results. Hit enter to select.';
        this.index = 0;
        /**
         * Determines if the dropdown should be shown
         */
        this.showResults = false;
    }
    /**
     * Gets the string value from the specifed properties of an object
     * @param {?} object
     * @param {?} propertyFields comma seperated list with periods depth of object
     * @return {?}
     */
    getObjectValue(object, propertyFields) {
        /** @type {?} */
        let value = '';
        /** @type {?} */
        let current = object;
        /** @type {?} */
        let fieldSplit = propertyFields.split(',');
        for (let i = 0; i < fieldSplit.length; i++) {
            /** @type {?} */
            let fieldValue = fieldSplit[i];
            /** @type {?} */
            let fieldPartSplit = fieldValue.split('.');
            for (let j = 0; j < fieldPartSplit.length; j++) {
                /** @type {?} */
                let fieldCheckValue = fieldPartSplit[j];
                if (current) {
                    current = current[fieldCheckValue];
                }
            }
            if (current) {
                value += current.toString() + ' ';
            }
            current = object;
        }
        return value.trim();
    }
    /**
     * Clears the input fields and value
     * @return {?}
     */
    clearInput() {
        this.inputValue = '';
        this.onTouchedCallback();
        this.clearAndHideResults();
    }
    /**
     *
     * @param {?} event
     * @return {?}
     */
    checkForFocus(event) {
        this.focusRemoved();
        this.showResults = false;
    }
    /**
     *
     * @private
     * @return {?}
     */
    focusRemoved() {
        if (this.configuration) {
            if (this.configuration.selectionMode === SelectionMode.SINGLE) {
                if (this.model.items.length > 0) {
                    if (this.inputValue.length === 0) {
                        SDSSelectedItemModelHelper.clearItems(this.model.items);
                        this.propogateChange(this.model);
                    }
                    else {
                        this.inputValue = this.getObjectValue(this.model.items[0], this.configuration.primaryTextField);
                    }
                }
            }
            else {
                this.inputValue = '';
            }
        }
        else {
            this.inputValue = '';
        }
    }
    /**
     * @param {?} ev
     * @return {?}
     */
    onkeypress(ev) {
        return this.configuration.inputReadOnly ? false : true;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    textChange(event) {
        if (!this.configuration.isTagModeEnabled) {
            // ie 11 placeholders will incorrectly trigger input events (known bug)
            // if input isn't active element then don't do anything
            if (event.target != document.activeElement) {
                event.preventDefault();
                return;
            }
            /** @type {?} */
            const searchString = event.target.value || '';
            this.getResults(searchString);
        }
    }
    /**
     * Event method used when focus is gained to the input
     * @return {?}
     */
    inputFocusHandler() {
        if (!this.configuration.isTagModeEnabled) {
            if (this.configuration.focusInSearch) {
                this.getResults(this.inputValue || '');
            }
            this.onTouchedCallback();
        }
    }
    /**
     * Key event
     * @param {?} event
     * @return {?}
     */
    onKeydown(event) {
        if (KeyHelper.is(KEYS.TAB, event)) {
            return;
        }
        else if (KeyHelper.is(KEYS.BACKSPACE, event)) {
            if (this.configuration.inputReadOnly) {
                event.preventDefault();
            }
        }
        else if (KeyHelper.is(KEYS.DOWN, event)) {
            this.onArrowDown();
        }
        else if (KeyHelper.is(KEYS.UP, event)) {
            event.preventDefault();
            this.onArrowUp();
        }
        else if (KeyHelper.is(KEYS.ENTER, event) && this.highlightedIndex >= 0) {
            if (this.configuration.isTagModeEnabled) {
                /** @type {?} */
                const val = this.createFreeTextItem();
                this.selectItem(val);
            }
            else {
                this.selectItem(this.highlightedItem);
            }
        }
        else if (KeyHelper.is(KEYS.ENTER, event) && this.highlightedIndex < 0) {
            /** @type {?} */
            const val = this.createFreeTextItem();
            this.selectItem(val);
        }
        else if (KeyHelper.is(KEYS.ESC, event)) {
            if (this.showResults) {
                this.clearAndHideResults();
                if (event.stopPropagation) {
                    event.stopPropagation();
                }
            }
        }
    }
    /**
     * selects the item adding it to the model and closes the results
     * @param {?} item
     * @return {?}
     */
    selectItem(item) {
        SDSSelectedItemModelHelper.addItem(item, this.configuration.primaryKeyField, this.configuration.selectionMode, this.items);
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.model.items = [...this.items];
            this.propogateChange(this.model);
        }), 0);
        /** @type {?} */
        let message = this.getObjectValue(item, this.configuration.primaryTextField);
        this.inputValue = message;
        this.focusRemoved();
        this.showResults = false;
    }
    /**
     *  clears the results and closes result drop down
     * @private
     * @return {?}
     */
    clearAndHideResults() {
        this.results = [];
        this.showResults = false;
        this.focusRemoved();
    }
    /**
     *  handles the arrow up key event
     * @private
     * @return {?}
     */
    onArrowUp() {
        if (this.results && this.results.length > 0) {
            if (this.highlightedIndex >= 0) {
                this.highlightedIndex--;
                this.setHighlightedItem(this.results[this.highlightedIndex]);
                this.scrollSelectedItemIntoView();
            }
        }
    }
    /**
     *  handles the arrow down key event
     * @private
     * @return {?}
     */
    onArrowDown() {
        if (this.results && this.results.length > 0) {
            if (this.highlightedIndex < this.results.length - 1) {
                this.highlightedIndex++;
                this.setHighlightedItem(this.results[this.highlightedIndex]);
                this.scrollSelectedItemIntoView();
            }
        }
    }
    /**
     * @return {?}
     */
    showFreeText() {
        if (this.configuration.isFreeTextEnabled) {
            if (this.inputValue) {
                if (this.inputValue.length !== 0) {
                    /** @type {?} */
                    let foundItem = false;
                    if (this.results) {
                        for (var i = 0; i < this.results.length && !foundItem; i++) {
                            /** @type {?} */
                            let item = this.results[i];
                            foundItem =
                                item[this.configuration.primaryTextField] === this.inputValue;
                        }
                    }
                    if (this.model.items.length > 0 && !foundItem) {
                        for (var i = 0; i < this.model.items.length && !foundItem; i++) {
                            /** @type {?} */
                            let item = this.model.items[i];
                            foundItem =
                                item[this.configuration.primaryTextField] === this.inputValue;
                        }
                    }
                    return !foundItem;
                }
                else {
                    return false;
                }
            }
            else {
                return false;
            }
        }
        else {
            return this.configuration.isFreeTextEnabled;
        }
    }
    /**
     * @private
     * @return {?}
     */
    createFreeTextItem() {
        /** @type {?} */
        let item = { type: 'custom' };
        item[this.configuration.primaryTextField] = this.inputValue;
        item[this.configuration.primaryKeyField] = this.inputValue;
        return item;
    }
    /**
     *  gets the inital results
     * @private
     * @param {?} searchString
     * @return {?}
     */
    getResults(searchString) {
        if (searchString.length >= this.configuration.minimumCharacterCountSearch) {
            if (!this.matchPastSearchString(searchString) ||
                (this.matchPastSearchString(searchString) && !this.showResults) ||
                this.matchPastSearchString('')) {
                this.searchString = searchString;
                window.clearTimeout(this.timeoutNumber);
                this.timeoutNumber = window.setTimeout((/**
                 * @return {?}
                 */
                () => {
                    this.showLoad = true;
                    this.service.getDataByText(0, searchString).subscribe((/**
                     * @param {?} result
                     * @return {?}
                     */
                    result => {
                        this.results = result.items;
                        this.showLoad = false;
                        this.maxResults = result.totalItems;
                        this.highlightedIndex = this.configuration.isFreeTextEnabled
                            ? -1
                            : 0;
                        if (!this.configuration.isFreeTextEnabled) {
                            this.setHighlightedItem(this.results[this.highlightedIndex]);
                        }
                        this.showResults = true;
                        this.addScreenReaderMessage(this.maxResults + ' ' + this.resultsAvailableMessage);
                        this._changeDetectorRef.markForCheck();
                    }));
                }), this.configuration.debounceTime);
            }
        }
    }
    /**
     * Checks if the new search string matches the old search string
     * @private
     * @param {?} searchString
     * @return {?}
     */
    matchPastSearchString(searchString) {
        return this.searchString === searchString;
    }
    /**
     * highlights the index being hovered
     * @param {?} index
     * @return {?}
     */
    listItemHover(index) {
        this.highlightedIndex = index;
        this.setHighlightedItem(this.results[this.highlightedIndex]);
    }
    /**
     * Scroll Event Handler (Calculates if mpre items should be asked for from service on scrolling down)
     * @return {?}
     */
    onScroll() {
        if (this.maxResults > this.results.length) {
            /** @type {?} */
            let scrollAreaHeight = this.resultsListElement.nativeElement.offsetHeight;
            /** @type {?} */
            let scrollTopPos = this.resultsListElement.nativeElement.scrollTop;
            /** @type {?} */
            let scrollAreaMaxHeight = this.resultsListElement.nativeElement
                .scrollHeight;
            if (scrollTopPos + scrollAreaHeight * 2 >= scrollAreaMaxHeight) {
                this.getAdditionalResults();
            }
        }
    }
    /**
     * gets more results based when scrolling and adds the items
     * @private
     * @return {?}
     */
    getAdditionalResults() {
        this.showLoad = true;
        this.service
            .getDataByText(this.results.length, this.searchString)
            .subscribe((/**
         * @param {?} result
         * @return {?}
         */
        result => {
            for (let i = 0; i < result.items.length; i++) {
                this.addResult(result.items[i]);
            }
            this.showLoad = false;
            this.maxResults = result.totalItems;
        }));
    }
    /**
     * adds a single item to the list
     * @private
     * @param {?} item
     * @return {?}
     */
    addResult(item) {
        //add check to make sure item does not exist
        this.results.push(item);
    }
    /**
     * When paging up and down with arrow key it sets the highlighted item into view
     * @private
     * @return {?}
     */
    scrollSelectedItemIntoView() {
        if (this.highlightedIndex >= 0) {
            /** @type {?} */
            const selectedChild = this.resultsListElement.nativeElement.children[this.highlightedIndex];
            selectedChild.scrollIntoView({
                behavior: 'smooth',
                block: 'nearest',
                inline: 'start'
            });
        }
    }
    /**
     * Sets the highlighted item by keyboard or mouseover
     * @private
     * @param {?} item
     * @return {?}
     */
    setHighlightedItem(item) {
        if (this.results && this.results.length > 0) {
            if (this.highlightedItem) {
                this.highlightedItem[this.HighlightedPropertyName] = false;
            }
            /** @type {?} */
            let message = '';
            if (item) {
                this.highlightedItem = item;
                this.highlightedItem[this.HighlightedPropertyName] = true;
                message = item[this.configuration.primaryTextField];
                if (this.configuration.secondaryTextField &&
                    item[this.configuration.secondaryTextField]) {
                    message += ': ' + item[this.configuration.secondaryTextField];
                }
            }
            else {
                this.highlightedItem = undefined;
                message = 'No item selected';
            }
            this.addScreenReaderMessage(message);
        }
    }
    /**
     * Adds message to be read by screen reader
     * @private
     * @param {?} message
     * @return {?}
     */
    addScreenReaderMessage(message) {
        this.srOnlyText = message;
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    writeValue(obj) {
        if (obj instanceof SDSSelectedItemModel) {
            this.model = (/** @type {?} */ (obj));
            this._changeDetectorRef.markForCheck();
            if (this.model.items.length === 0) {
                this.inputValue = '';
            }
            else {
                if (this.configuration.selectionMode === SelectionMode.SINGLE) {
                    this.inputValue = this.getObjectValue(this.model.items[0], this.configuration.primaryTextField);
                }
            }
        }
    }
    /**
     * @return {?}
     */
    getClass() {
        return this.configuration.inputReadOnly &&
            this.configuration.selectionMode === SelectionMode.MULTIPLE
            ? 'hide-cursor'
            : '';
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.propogateChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
}
SDSAutocompleteSearchComponent.decorators = [
    { type: Component, args: [{
                selector: 'sds-search-autocomplete',
                template: "<div sds-click-outside (clickOutside)=\"checkForFocus($event)\" sds-tab-outside (tabOutside)=\"checkForFocus($event)\">\n  <div class=\"maxw-mobile-lg position-relative\">\n    <div role=\"combobox\" [attr.id]=\"configuration.id+'-container'\" [attr.aria-expanded]=\"showResults\" [attr.aria-owns]=\"showResults? configuration.id+ '-listbox' : undefined\"\n      aria-haspopup=\"listbox\">\n      <input [disabled]=\"disabled\" (keypress)=\"onkeypress($event)\" (input)=\"textChange($event)\" class=\"usa-input padding-right-3\"\n        [ngClass]=\"getClass()\" #input [attr.aria-label]=\"configuration.ariaLabelText\" [attr.id]=\"configuration.id\" type=\"text\"\n        (focus)=\"inputFocusHandler()\" (keydown)=\"onKeydown($event)\" [(ngModel)]=\"inputValue\" aria-autocomplete=\"list\"\n        [attr.placeholder]=\"configuration.autocompletePlaceHolderText\" [attr.aria-activedescendant]=\"showResults? configuration.id+'-resultItem-'+highlightedIndex :''\"\n        [attr.aria-controls]=\"showResults? configuration.id+ '-listbox' : undefined\" autocomplete=\"off\">\n    </div>\n    <ul #resultsList *ngIf=\"showResults\" [attr.id]=\"configuration.id+ '-listbox'\" role=\"listbox\" class=\"usa-list usa-list--unstyled sds-autocomplete\"\n      (scroll)=\"onScroll()\">\n      <ng-container *ngIf=\"(results && results.length > 0)\">\n        <li [attr.id]=\"configuration.id+'-resultItem-'+i\" role=\"option\" *ngFor=\"let result of results; let i = index\"\n          (mouseenter)=\"listItemHover(i)\" [class]=\"result['highlighted'] ? 'sds-autocomplete__item sds-autocomplete__item--selected' : 'sds-autocomplete__item' \"\n          (click)=\"selectItem(result)\">\n          <ng-container *ngIf=\"itemTemplate\" [ngTemplateOutlet]=\"itemTemplate\" [ngTemplateOutletContext]=\"{$implicit:result}\">\n          </ng-container>\n\n          <ng-container *ngIf=\"!itemTemplate\">\n            <span class=\"display-block text-semibold\">\n              {{ getObjectValue(result, configuration.primaryTextField) }}\n              <span *ngIf=\"result.type === 'custom'\">\n                - {{configuration.freeTextSubtext}}\n              </span>\n            </span>\n            <ng-container *ngIf=\"configuration.secondaryTextField &&  result[configuration.secondaryTextField] \">\n              <span class=\"description\">{{ result[configuration.secondaryTextField] }}</span>\n            </ng-container>\n          </ng-container>\n        </li>\n      </ng-container>\n      <ng-container *ngIf=\"(!results || results.length == 0)\">\n        <li class=\"emptyResults margin-1\">No results found</li>\n      </ng-container>\n      <ng-container *ngIf=\"showLoad\">\n        <li class=\"autoLoading\">\n          <div class=\"lightToGrayBackgroundGradiate\">\n\n          </div>\n          <div class=\"grayToLightBackgroundGradiate\">\n\n          </div>\n        </li>\n        <li class=\"autoLoading\">\n          <div class=\"lightToGrayBackgroundGradiate\">\n\n          </div>\n          <div class=\"grayToLightBackgroundGradiate\">\n\n          </div>\n        </li>\n      </ng-container>\n    </ul>\n\n    <ng-container *ngIf=\"!input.disabled\">\n      <span class=\"position-absolute right-105 top-1 cursor-pointer\">\n        <span *ngIf=\"(inputValue && !disabled)\" tabindex=\"0\" role=\"button\" aria-label=\"Clear input\" aria-hidden=\"false\"\n          (click)=\"clearInput()\" (keyup.enter)=\"clearInput()\">\n          <fa-icon [icon]=\"['fas', 'times']\" size=\"xs\"></fa-icon>\n        </span>\n        <span *ngIf=\"!configuration.isTagModeEnabled\" tabindex=\"1\" role=\"button\" aria-label=\"Clear input\" aria-hidden=\"false\"\n          class=\"margin-left-1\">\n          <fa-icon *ngIf=\"(!showResults && !disabled)\" (click)=\"inputFocusHandler()\" [icon]=\"['fas', 'caret-down']\"\n            size=\"sm\"></fa-icon>\n          <fa-icon *ngIf=\"(showResults && !disabled)\" (click)=\"checkForFocus($event)\" [icon]=\"['fas', 'caret-up']\" size=\"sm\"></fa-icon>\n        </span>\n      </span>\n    </ng-container>\n    <ul class=\"usa-sr-only\" aria-live=\"assertive\">\n      <li>{{srOnlyText}}</li>\n    </ul>\n  </div>",
                providers: [Autocomplete_Autocomplete_VALUE_ACCESSOR],
                styles: [".grayToLightBackgroundGradiate{background:linear-gradient(to right,#c4c4c4,#f7f7f7);background-size:400% 400%;height:10px;padding:2.5px 0;text-align:center;color:#888;font-size:15px;font-weight:700;margin:7px 10px 0;-webkit-animation:5s infinite gradiantShiftGray;animation:5s infinite gradiantShiftGray}@-webkit-keyframes gradiantShiftGray{0%,100%{background-position:0 50%}50%{background-position:100% 50%}}@keyframes gradiantShiftGray{0%,100%{background-position:0 50%}50%{background-position:100% 50%}}.lightToGrayBackgroundGradiate{background:linear-gradient(to right,#f7f7f7,#c4c4c4);background-size:400% 400%;height:15px;padding:2.5px 0;text-align:center;color:#888;font-size:15px;font-weight:700;margin:10px 10px 0;-webkit-animation:5s infinite gradiantShift;animation:5s infinite gradiantShift}@-webkit-keyframes gradiantShift{0%,100%{background-position:0 50%}50%{background-position:100% 50%}}@keyframes gradiantShift{0%,100%{background-position:0 50%}50%{background-position:100% 50%}}.autoLoading{height:60px}.hide-cursor{color:transparent;text-shadow:0 0 0}"]
            }] }
];
/** @nocollapse */
SDSAutocompleteSearchComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
SDSAutocompleteSearchComponent.propDecorators = {
    resultsListElement: [{ type: ViewChild, args: ['resultsList',] }],
    input: [{ type: ViewChild, args: ['input',] }],
    itemTemplate: [{ type: Input }],
    configuration: [{ type: Input }],
    service: [{ type: Input }],
    inputReadOnly: [{ type: Input }],
    disabled: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * The <sam-click-outside> directive can detect whether a click is made inside
 * the target
 */
class SDSClickOutsideDirective {
    /**
     * @param {?} _elementRef
     */
    constructor(_elementRef) {
        this._elementRef = _elementRef;
        /**
         * Event emitted when clicked outside the target
         */
        this.clickOutside = new EventEmitter();
    }
    /**
     * @param {?} targetElement
     * @return {?}
     */
    onClick(targetElement) {
        /** @type {?} */
        const clickedInside = this._elementRef.nativeElement.contains(targetElement);
        if (!clickedInside) {
            this.clickOutside.emit(undefined);
        }
    }
}
SDSClickOutsideDirective.decorators = [
    { type: Directive, args: [{
                selector: '[sds-click-outside]'
            },] }
];
/** @nocollapse */
SDSClickOutsideDirective.ctorParameters = () => [
    { type: ElementRef }
];
SDSClickOutsideDirective.propDecorators = {
    clickOutside: [{ type: Output }],
    onClick: [{ type: HostListener, args: ['document:click', ['$event.target'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SDSClickOutsideModule {
}
SDSClickOutsideModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule, FormsModule
                ],
                declarations: [SDSClickOutsideDirective],
                exports: [SDSClickOutsideDirective]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SDSTabOutsideDirective {
    /**
     * @param {?} _elementRef
     */
    constructor(_elementRef) {
        this._elementRef = _elementRef;
        /**
         * Emitter for tabOutside event
         */
        this.tabOutside = new EventEmitter();
    }
    /**
     * @param {?} target
     * @return {?}
     */
    hasFocusChanged(target) {
        /** @type {?} */
        const isInsideHost = this._elementRef.nativeElement.contains(target);
        if (!isInsideHost) {
            this.tabOutside.emit(undefined);
        }
    }
}
SDSTabOutsideDirective.decorators = [
    { type: Directive, args: [{
                selector: '[sds-tab-outside]'
            },] }
];
/** @nocollapse */
SDSTabOutsideDirective.ctorParameters = () => [
    { type: ElementRef }
];
SDSTabOutsideDirective.propDecorators = {
    tabOutside: [{ type: Output }],
    hasFocusChanged: [{ type: HostListener, args: ['document:keyup', ['$event.target'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SdsTabOutsideModule {
}
SdsTabOutsideModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule, FormsModule
                ],
                declarations: [SDSTabOutsideDirective],
                exports: [SDSTabOutsideDirective]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SdsAutocompleteSearchModule {
}
SdsAutocompleteSearchModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    SDSClickOutsideModule,
                    SdsTabOutsideModule,
                    FontAwesomeModule
                ],
                declarations: [SDSAutocompleteSearchComponent],
                exports: [SDSAutocompleteSearchComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SdsAutocompleteModule {
}
SdsAutocompleteModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule, FormsModule, RouterModule, SdsSelectedResultsModule, SdsAutocompleteSearchModule
                ],
                declarations: [SDSAutocompleteComponent],
                exports: [SDSAutocompleteComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SDSHiercarchicalServiceSearchItem {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SideNavigationModel {
}
class NavigationLink {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SdsSideNavigationComponent {
    constructor() {
        /**
         * Navigation helper
         */
        this.navigationHelper = new NavigationHelper();
        /**
         * event for event based
         */
        this.linkEvent = new EventEmitter();
    }
    /**
     * Takes the navigation item and returns the template to be used
     * @param {?} item navigation item
     * @return {?}
     */
    getItemTemplate(item) {
        /** @type {?} */
        let template = null;
        switch (item.mode) {
            case NavigationMode.EVENT:
                template = this.sideNavEVENTLinkTemplate;
                break;
            case NavigationMode.EXTERNAL:
                template = this.sideNavHREFLinkTemplate;
                break;
            case NavigationMode.INTERNAL:
                template = this.sideNavRouteLinkTemplate;
                break;
            case NavigationMode.LABEL:
                template = this.sideNavLabelLinkTemplate;
                break;
            default:
                template = null;
                break;
        }
        return template;
    }
    /**
     * Selects new item and parents and deselects previous
     * @param {?} id
     * @return {?}
     */
    select(id) {
        this.deselect();
        for (let i = 0; i < this.model.navigationLinks.length; i++) {
            /** @type {?} */
            let item = this.model.navigationLinks[i];
            this.selectItem(id, item, null);
        }
    }
    /**
     * Selects item if matches passed in id and will select parent
     * @private
     * @param {?} id
     * @param {?} item
     * @param {?} parent
     * @return {?}
     */
    selectItem(id, item, parent) {
        if (item.id === id) {
            item.selected = true;
            if (parent) {
                parent.selected = true;
            }
        }
        else {
            if (item.children) {
                for (let i = 0; i < item.children.length; i++) {
                    /** @type {?} */
                    let childItem = item.children[i];
                    this.selectItem(id, childItem, item);
                }
                if (item.selected) {
                    if (parent) {
                        parent.selected = true;
                    }
                }
            }
        }
    }
    /**
     * Deselects all the items in the side navigation model
     * @return {?}
     */
    deselect() {
        if (this.model) {
            if (this.model.navigationLinks) {
                for (let i = 0; i < this.model.navigationLinks.length; i++) {
                    this.deselectItem(this.model.navigationLinks[i]);
                }
            }
        }
    }
    /**
     * checks if item is selected and if selcted will check children and will unselect
     * @private
     * @param {?} item
     * @return {?}
     */
    deselectItem(item) {
        if (item.selected) {
            item.selected = false;
            if (item.children) {
                for (let i = 0; i < item.children.length; i++) {
                    this.deselectItem(item.children[i]);
                }
            }
        }
    }
    /**
     * Link clicked and emits the link data into an event
     * @param {?} link
     * @return {?}
     */
    linkClickEvent(link) {
        this.linkEvent.emit(link);
        return false;
    }
    /**
     * creates url from provided route and query params
     * @param {?} item
     * @return {?}
     */
    urlBuilder(item) {
        /** @type {?} */
        let url = item.route;
        /** @type {?} */
        let queryParams = this.queryStringBuilder(item);
        if (queryParams) {
            if (url.indexOf('?') === -1) {
                url += '?' + queryParams;
            }
            else if (url.indexOf('?') === url.length - 1) {
                url += queryParams;
            }
            else {
                url += '&' + queryParams;
            }
        }
        return url;
    }
    /**
     * creates query string
     * @private
     * @param {?} item
     * @return {?}
     */
    queryStringBuilder(item) {
        /** @type {?} */
        const ret = [];
        for (let d in item.queryParams) {
            ret.push(encodeURIComponent(d) + '=' + encodeURIComponent(item.queryParams[d]));
        }
        return ret.join('&');
    }
}
SdsSideNavigationComponent.decorators = [
    { type: Component, args: [{
                selector: 'sds-side-navigation',
                template: "<nav>\n    <ul class=\"usa-sidenav\">\n        <li *ngFor=\"let link of model.navigationLinks\" class=\"sidenav__item\">\n            <ng-container [ngTemplateOutlet]=\"sideNavLinkTemplate\" [ngTemplateOutletContext]=\"{$implicit:link}\">\n            </ng-container>\n        </li>\n    </ul>\n</nav>\n\n<ng-template #sideNavLinkTemplate let-link>\n    <ng-container [ngTemplateOutlet]=\"getItemTemplate(link)\" [ngTemplateOutletContext]=\"{$implicit:link}\">\n    </ng-container>\n    <ul *ngIf=\"link.children\" class=\"usa-sidenav__sublist\">\n        <li *ngFor=\"let link of link.children\" class=\"sidenav__item\">\n            <ng-container [ngTemplateOutlet]=\"sideNavLinkTemplate\" [ngTemplateOutletContext]=\"{$implicit:link}\">\n            </ng-container>\n        </li>\n    </ul>\n</ng-template>\n\n<ng-template #sideNavRouteLinkTemplate let-link>\n    <a [attr.class]=\"link.selected ? ' usa-current' : ''\" [routerLink]=\"[link.route]\"\n        [queryParams]=\"link.queryParams\"><span>{{link.text}}</span></a>\n</ng-template>\n\n<ng-template #sideNavHREFLinkTemplate let-link>\n    <a [attr.class]=\"link.selected ? ' usa-current' : ''\" [attr.href]=\"urlBuilder(link)\"><span>{{link.text}}</span></a>\n</ng-template>\n\n<ng-template #sideNavLabelLinkTemplate let-link>\n    <span [attr.class]=\"link.selected ? ' usa-current' : ''\"><span>{{link.text}}</span></span>\n</ng-template>\n\n<ng-template #sideNavEVENTLinkTemplate let-link>\n    <a [attr.class]=\"link.selected ? ' usa-current' : ''\" href=\"javascript:void(0)\"\n        (click)=\"linkClickEvent(link)\"><span>{{link.text}}</span></a>\n</ng-template>",
                styles: [""]
            }] }
];
SdsSideNavigationComponent.propDecorators = {
    sideNavRouteLinkTemplate: [{ type: ViewChild, args: ['sideNavRouteLinkTemplate',] }],
    sideNavLabelLinkTemplate: [{ type: ViewChild, args: ['sideNavLabelLinkTemplate',] }],
    sideNavHREFLinkTemplate: [{ type: ViewChild, args: ['sideNavHREFLinkTemplate',] }],
    sideNavEVENTLinkTemplate: [{ type: ViewChild, args: ['sideNavEVENTLinkTemplate',] }],
    model: [{ type: Input }],
    linkEvent: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SdsSideNavigationModule {
}
SdsSideNavigationModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule, FormsModule, RouterModule, SdsAccordionModule
                ],
                declarations: [SdsSideNavigationComponent],
                exports: [SdsSideNavigationComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SdsSearchResultListComponent {
    constructor() {
        /**
         * Show divider between results
         */
        this.divider = true;
    }
}
SdsSearchResultListComponent.decorators = [
    { type: Component, args: [{
                selector: 'sds-search-result-list',
                template: "<div *ngFor=\"let item of model\">\n    <hr *ngIf=\"divider\" class=\"thin\" />\n    <ng-container *ngTemplateOutlet=\"resultContentTemplate,\n                   context: { $implicit: item }\"></ng-container>\n</div>\n<hr *ngIf=\"divider && model?.length\" class=\"thin\" />\n<div *ngIf=\"!model|| model.length===0\">\n    <div class=\"grid-row border-1px border-base-lighter bg-base-lightest\">\n      <div class=\"grid-col-auto text-center text-base margin-4\">\n        <fa-icon [icon]=\"['sds', 'search']\" [classes]=\"['search']\" size=\"7x\"></fa-icon>\n      </div>\n      <div class=\"grid-col-fill display-flex flex-column padding-y-1\">\n        <h1 class=\"margin-bottom-105 text-semibold\">No matches found</h1>\n        <p class=\"margin-y-0 font-sans-lg\">We couldn't find a match for your search criteria.</p>\n        <p class=\"margin-y-0 font-sans-lg\">Please try another search or go back to previous results.</p>\n        <button class=\"usa-button usa-button--secondary width-card margin-y-2\">Go Back</button>\n      </div>\n    </div>\n</div>\n",
                styles: [""]
            }] }
];
SdsSearchResultListComponent.propDecorators = {
    model: [{ type: Input }],
    divider: [{ type: Input }],
    resultContentTemplate: [{ type: ContentChild, args: ['resultContent',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SdsSearchResultListModule {
}
SdsSearchResultListModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule, FormsModule, FontAwesomeModule
                ],
                declarations: [SdsSearchResultListComponent],
                exports: [SdsSearchResultListComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HeaderHome {
}
/**
 *
 */
class HeaderNavigationLink {
}
class HeaderSecondaryLink {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const sdsMenuAnimations = {
    transformMenu: trigger('transformMenu', [
        state('void', style({
            opacity: 0,
            transform: 'scale(0.8)'
        })),
        transition('void => enter', group([
            query('.sds-menu', animate('100ms linear', style({
                opacity: 1
            }))),
            animate('120ms cubic-bezier(0, 0, 0.2, 1)', style({ transform: 'scale(1)' }))
        ])),
        transition('* => void', animate('100ms 25ms linear', style({ opacity: 0 })))
    ])
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Injection token used to provide the parent menu to menu items.
 * @type {?}
 */
const SDS_MENU_TOKEN = new InjectionToken('SDS_MENU_TOKEN');
class SdsMenuComponent {
    /**
     * @param {?} _elementRef
     */
    constructor(_elementRef) {
        this._elementRef = _elementRef;
        /**
         * After | Before the menu triger element
         */
        this._xPosition = 'after';
        /**
         * Above | Below the menu triger element
         */
        this._yPosition = 'below';
        /**
         * Menu items inside the current menu.
         */
        this._items = [];
        /**
         * Subscription to tab events on the menu panel
         */
        this._tabSubscription = Subscription.EMPTY;
        /**
         * Config object to be passed into the menu's ngClass
         */
        this._classList = {};
        /**
         * Current state of the panel animation.
         */
        this._panelAnimationState = 'void';
        this._overlapTrigger = false;
        /**
         * Event emitted when the menu is closed.
         */
        this.closed = new EventEmitter();
    }
    /**
     * Position of the menu in the X axis.
     * @return {?}
     */
    get xPosition() {
        return this._xPosition;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set xPosition(value) {
        this._xPosition = value;
        this.setPositionClasses();
    }
    /**
     * Position of the menu in the Y axis.
     * @return {?}
     */
    get yPosition() {
        return this._yPosition;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set yPosition(value) {
        this._yPosition = value;
        this.setPositionClasses();
    }
    /**
     * Whether menu panel overlaps trigger element
     * @return {?}
     */
    get overlapTrigger() {
        return this._overlapTrigger;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set overlapTrigger(value) {
        this._overlapTrigger = coerceBooleanProperty(value);
    }
    /**
     * Transfer classes from the sds-menu to the overlay container
     * @param {?} classes
     * @return {?}
     */
    set panelClass(classes) {
        /** @type {?} */
        const previousPanelClass = this._previousPanelClass;
        // Remove previous classes from current set of classes
        if (previousPanelClass && previousPanelClass.length) {
            previousPanelClass.split(' ').forEach((/**
             * @param {?} className
             * @return {?}
             */
            (className) => {
                this._classList[className] = false;
            }));
        }
        this._previousPanelClass = classes;
        // Adds new classes to current set of classes
        if (classes && classes.length) {
            classes.split(' ').forEach((/**
             * @param {?} className
             * @return {?}
             */
            (className) => {
                this._classList[className] = true;
            }));
            // Remove all classes from <sds-menu>
            this._elementRef.nativeElement.className = '';
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setPositionClasses();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this._keyManager = new FocusKeyManager(this._items).withWrap();
        this._tabSubscription = this._keyManager.tabOut.subscribe((/**
         * @return {?}
         */
        () => this.closed.emit('tab')));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._tabSubscription.unsubscribe();
        this.closed.complete();
    }
    /**
     * Focus the first item in the menu
     * @param {?=} origin
     * @return {?}
     */
    focusFirstItem(origin = 'program') {
        this._keyManager.setFocusOrigin(origin).setFirstItemActive();
    }
    /**
     * Adds classes to the menu panel based on its position
     * @param {?=} posX
     * @param {?=} posY
     * @return {?}
     */
    setPositionClasses(posX = this.xPosition, posY = this.yPosition) {
        /** @type {?} */
        const classes = this._classList;
        classes['sds-menu-before'] = posX === 'before';
        classes['sds-menu-after'] = posX === 'after';
        classes['sds-menu-above'] = posY === 'above';
        classes['sds-menu-below'] = posY === 'below';
    }
    /**
     * Adds a menu item with the menu.
     * @param {?} item
     * @return {?}
     */
    addItem(item) {
        if (this._items.indexOf(item) === -1) {
            this._items.push(item);
        }
    }
    /**
     * Inserts a menu item at an index
     * @param {?} item
     * @param {?} index
     * @return {?}
     */
    insertItem(item, index) {
        if (this._items.indexOf(item) === -1 && index < this._items.length) {
            this._items.splice(index, 0, item);
        }
    }
    /**
     * Removes an item from the menu.
     * @param {?} item
     * @return {?}
     */
    removeItem(item) {
        /** @type {?} */
        const index = this._items.indexOf(item);
        if (this._items.indexOf(item) > -1) {
            this._items.splice(index, 1);
        }
    }
    /**
     * Handle a keyboard event from the menu
     * @param {?} event
     * @return {?}
     */
    _handleKeydown(event) {
        // tslint:disable-next-line: deprecation
        /** @type {?} */
        const keyCode = event.keyCode;
        /** @type {?} */
        const manager = this._keyManager;
        switch (keyCode) {
            case ESCAPE:
                this.closed.emit('keydown');
                break;
            case HOME:
            case END:
                if (!hasModifierKey(event)) {
                    keyCode === HOME
                        ? manager.setFirstItemActive()
                        : manager.setLastItemActive();
                    event.preventDefault();
                }
                break;
            default:
                if (keyCode === UP_ARROW || keyCode === DOWN_ARROW) {
                    manager.setFocusOrigin('keyboard');
                }
                manager.onKeydown(event);
        }
    }
    /**
     * Starts the enter animation.
     * @return {?}
     */
    _startAnimation() {
        this._panelAnimationState = 'enter';
    }
    /**
     * Callback that is invoked when the panel animation completes.
     * @param {?} event
     * @return {?}
     */
    _onAnimationDone(event) { }
    /**
     * Resets the panel animation to its initial state.
     * @return {?}
     */
    _resetAnimation() {
        this._panelAnimationState = 'void';
    }
    /**
     * @param {?} event
     * @return {?}
     */
    _onAnimationStart(event) {
        // Scroll the content element to the top as soon as the animation starts.
        if (event.toState === 'enter' && this._keyManager.activeItemIndex === 0) {
            event.element.scrollTop = 0;
        }
    }
}
SdsMenuComponent.decorators = [
    { type: Component, args: [{
                selector: 'sds-menu',
                exportAs: 'sdsMenu',
                template: "<ng-template>\n  <div\n    class=\"sds-overlay minw-menu maxw-mobile radius-overlay\"\n    [ngClass]=\"_classList\"\n    (keydown)=\"_handleKeydown($event)\"\n    (click)=\"closed.emit('click')\"\n    [@transformMenu]=\"_panelAnimationState\"\n    (@transformMenu.start)=\"_onAnimationStart($event)\"\n    (@transformMenu.done)=\"_onAnimationDone($event)\"\n    tabindex=\"-1\"\n    role=\"menu\"\n  >\n    <div class=\"sds-menu\" [class.sds-menu--small]=\"size === 'sm'\">\n      <ng-content></ng-content>\n    </div>\n  </div>\n</ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                animations: [sdsMenuAnimations.transformMenu],
                providers: [
                    { provide: SDS_MENU_TOKEN, useExisting: SdsMenuComponent }
                ]
            }] }
];
/** @nocollapse */
SdsMenuComponent.ctorParameters = () => [
    { type: ElementRef }
];
SdsMenuComponent.propDecorators = {
    templateRef: [{ type: ViewChild, args: [TemplateRef,] }],
    size: [{ type: Input }],
    xPosition: [{ type: Input }],
    yPosition: [{ type: Input }],
    overlapTrigger: [{ type: Input }],
    panelClass: [{ type: Input, args: ['class',] }],
    closed: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SdsMenuHeaderComponent {
    constructor() {
        this.hideClose = false;
    }
}
SdsMenuHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'sds-menu-header',
                template: "<div class=\"sds-menu__header\">\n  <span class=\"sds-menu__header-title\"> <ng-content></ng-content> </span>\n  <button\n    *ngIf=\"!hideClose\"\n    aria-label=\"Close Menu\"\n    sds-menu-item\n    role=\"button\"\n  >\n  <fa-icon\n  [icon]=\"['fas', 'times']\"\n  [fixedWidth]=\"true\"\n></fa-icon>\n  </button>\n</div>\n"
            }] }
];
SdsMenuHeaderComponent.propDecorators = {
    hideClose: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SdsMenuItemComponent {
    /**
     * @param {?} _elementRef
     * @param {?} _focusMonitor
     * @param {?} _parentMenu
     * @param {?} _parentMenuHeader
     */
    constructor(_elementRef, _focusMonitor, _parentMenu, _parentMenuHeader) {
        this._elementRef = _elementRef;
        this._focusMonitor = _focusMonitor;
        this._parentMenu = _parentMenu;
        this._parentMenuHeader = _parentMenuHeader;
        /**
         * Menu item class
         */
        this.class = this._getClass();
        /**
         * ARIA role for the menu item.
         */
        this.role = 'menuitem';
        /**
         * Menu item tab index
         */
        this.tabIndex = this.disabled ? '-1' : '0';
        /**
         * Holds the disable status value
         */
        this._disabled = false;
        // Start listening to focus changes
        _focusMonitor.monitor(this._elementRef, false);
        // Add this menu item to its parent menu
        // If item its inside a header
        // add it as the first item in the list
        if (_parentMenuHeader) {
            _parentMenu.insertItem(this, 0);
        }
        else {
            _parentMenu.addItem(this);
        }
    }
    /**
     * Whether the menu item should be disabled
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = coerceBooleanProperty(value);
    }
    /**
     * Get item class
     * @return {?}
     */
    _getClass() {
        /** @type {?} */
        const headerButtonSmall = this._parentMenu.size === 'sm' ? 'sds-button--small' : '';
        return this._parentMenuHeader
            ? `sds-button sds-button--circular ${headerButtonSmall}`
            : 'sds-menu__item';
    }
    /**
     * Focuses the menu item.
     * @param {?=} origin
     * @return {?}
     */
    focus(origin = 'program') {
        this._focusMonitor.focusVia(this._elementRef.nativeElement, origin);
    }
    /**
     * Stop listening to focus changes and remove item from parent
     * @return {?}
     */
    ngOnDestroy() {
        this._focusMonitor.stopMonitoring(this._elementRef);
        this._parentMenu.removeItem(this);
    }
}
SdsMenuItemComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line: component-selector
                selector: '[sds-menu-item]',
                template: '<ng-content></ng-content>',
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
SdsMenuItemComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: FocusMonitor },
    { type: undefined, decorators: [{ type: Inject, args: [SDS_MENU_TOKEN,] }] },
    { type: SdsMenuHeaderComponent, decorators: [{ type: Optional }] }
];
SdsMenuItemComponent.propDecorators = {
    class: [{ type: HostBinding, args: ['class',] }],
    role: [{ type: HostBinding, args: ['attr.role',] }, { type: Input }],
    tabIndex: [{ type: HostBinding, args: ['attr.tabIndex',] }],
    disabled: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SdsMenuTriggerForDirective {
    /**
     * @param {?} _overlay
     * @param {?} _element
     * @param {?} _viewContainerRef
     * @param {?} _focusMonitor
     */
    constructor(_overlay, _element, _viewContainerRef, _focusMonitor) {
        this._overlay = _overlay;
        this._element = _element;
        this._viewContainerRef = _viewContainerRef;
        this._focusMonitor = _focusMonitor;
        /**
         * ARIA haspopup for the menu trigger.
         */
        this.ariaHasPopup = true;
        /**
         * Holds value for menuOpen variable
         */
        this._menuOpen = false;
        /**
         * PortalOutlet
         */
        this._overlayRef = null;
        /**
         * Tracks input type
         */
        this._openedBy = null;
        this._closingActionsSubscription = Subscription.EMPTY;
        this._menuCloseSubscription = Subscription.EMPTY;
        /**
         * Event emitted when the associated menu is opened.
         */
        this.menuOpened = new EventEmitter();
        /**
         * Event emitted when the associated menu is closed.
         */
        this.menuClosed = new EventEmitter();
        // On touch devices set _openedBy to 'touch'
        _element.nativeElement.addEventListener('touchstart', (/**
         * @return {?}
         */
        () => (this._openedBy = 'touch')), normalizePassiveListenerOptions({ passive: true }));
    }
    /**
     * ARIA expanded for the menu trigger.
     * @return {?}
     */
    get menuOpen() {
        return this._menuOpen;
    }
    /**
     * References the menu instance that the trigger is associated with.
     * @return {?}
     */
    get menu() {
        return this._menu;
    }
    /**
     * @param {?} menu
     * @return {?}
     */
    set menu(menu) {
        if (menu === this._menu) {
            return;
        }
        this._menu = menu;
        this._menuCloseSubscription.unsubscribe();
        if (menu) {
            this._menuCloseSubscription = menu.closed.asObservable().subscribe((/**
             * @return {?}
             */
            () => {
                this._destroyMenu();
            }));
        }
    }
    /**
     * Handles mouse presses on the trigger.
     * @param {?} event
     * @return {?}
     */
    _handleMousedown(event) {
        if (!isFakeMousedownFromScreenReader(event)) {
            // Since right or middle button clicks won't trigger the `click` event,
            // we shouldn't consider the menu as opened by mouse in those cases.
            this._openedBy = event.button === 0 ? 'mouse' : null;
        }
    }
    /**
     * Toggles the menu between the open and closed states.
     * @return {?}
     */
    toggleMenu() {
        return this._menuOpen ? this.closeMenu() : this.openMenu();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this._overlayRef) {
            this._overlayRef.dispose();
            this._overlayRef = null;
        }
        this._element.nativeElement.removeEventListener('touchstart', (/**
         * @return {?}
         */
        () => (this._openedBy = 'touch')), normalizePassiveListenerOptions({ passive: true }));
        this._menuCloseSubscription.unsubscribe();
        this._closingActionsSubscription.unsubscribe();
    }
    /**
     * Opens the menu.
     * @return {?}
     */
    openMenu() {
        if (this._menuOpen) {
            return;
        }
        /** @type {?} */
        const overlayRef = this._createOverlay();
        /** @type {?} */
        const overlayConfig = overlayRef.getConfig();
        this._setPosition((/** @type {?} */ (overlayConfig.positionStrategy)));
        overlayRef.attach(this._getPortal());
        this._closingActionsSubscription = this._menuClosingActions().subscribe((/**
         * @return {?}
         */
        () => this.closeMenu()));
        this._initMenu();
        if (this.menu instanceof SdsMenuComponent) {
            this.menu._startAnimation();
        }
    }
    /**
     * Closes the menu.
     * @return {?}
     */
    closeMenu() {
        this.menu.closed.emit();
    }
    /**
     * Focuses the menu trigger.
     * @param {?=} origin
     * @return {?}
     */
    focus(origin = 'program') {
        this._focusMonitor.focusVia(this._element, origin);
    }
    /**
     * This method sets the menu state to open and focuses the first item
     * @private
     * @return {?}
     */
    _initMenu() {
        this._setIsMenuOpen(true);
        this.menu.focusFirstItem(this._openedBy || 'program');
    }
    /**
     * sets open state
     * @private
     * @param {?} isOpen
     * @return {?}
     */
    _setIsMenuOpen(isOpen) {
        this._menuOpen = isOpen;
        this._menuOpen ? this.menuOpened.emit() : this.menuClosed.emit();
    }
    /**
     * This method resets the menu when it's closed,
     * most importantly restoring focus to the menu trigger
     * @private
     * @return {?}
     */
    _resetMenu() {
        this._setIsMenuOpen(false);
        if (!this._openedBy) {
            this.focus();
        }
        else {
            this.focus(this._openedBy);
        }
        this._openedBy = null;
    }
    /**
     * Closes the menu and does the necessary cleanup.
     * @private
     * @return {?}
     */
    _destroyMenu() {
        if (!this._overlayRef || !this.menuOpen) {
            return;
        }
        this._closingActionsSubscription.unsubscribe();
        this._overlayRef.detach();
        if (this.menu instanceof SdsMenuComponent) {
            this.menu._resetAnimation();
            this._resetMenu();
        }
    }
    /**
     * This method creates the overlay from the provided menu's template and saves its
     * OverlayRef so that it can be attached to the DOM when openMenu is called.
     * @private
     * @return {?}
     */
    _createOverlay() {
        if (!this._overlayRef) {
            /** @type {?} */
            const config = this._getOverlayConfig();
            this._subscribeToPositions((/** @type {?} */ (config.positionStrategy)));
            this._overlayRef = this._overlay.create(config);
            this._overlayRef.keydownEvents().subscribe();
        }
        return this._overlayRef;
    }
    /**
     * This method builds the configuration object needed to create the overlay, the OverlayState.
     * @private
     * @return {?} OverlayConfig
     */
    _getOverlayConfig() {
        return new OverlayConfig({
            positionStrategy: this._overlay
                .position()
                .flexibleConnectedTo(this._element)
                .withLockedPosition()
                .withTransformOriginOn('.sds-overlay'),
            hasBackdrop: true,
            backdropClass: 'cdk-overlay-transparent-backdrop',
            scrollStrategy: this._overlay.scrollStrategies.reposition()
        });
    }
    /**
     * Listens to changes in the position of the overlay and sets the correct classes
     * on the menu based on the new position.
     * @private
     * @param {?} position
     * @return {?}
     */
    _subscribeToPositions(position) {
        position.positionChanges.subscribe((/**
         * @param {?} change
         * @return {?}
         */
        change => {
            /** @type {?} */
            const posX = change.connectionPair.overlayX === 'start' ? 'after' : 'before';
            /** @type {?} */
            const posY = change.connectionPair.overlayY === 'top' ? 'below' : 'above';
            this.menu.setPositionClasses(posX, posY);
        }));
    }
    /**
     * Sets the appropriate positions on a position strategy
     * so the overlay connects with the trigger correctly.
     * @private
     * @param {?} positionStrategy
     * @return {?}
     */
    _setPosition(positionStrategy) {
        const [originX, originFallbackX] = this.menu.xPosition === 'before' ? ['end', 'start'] : ['start', 'end'];
        const [overlayY, overlayFallbackY] = this.menu.yPosition === 'above' ? ['bottom', 'top'] : ['top', 'bottom'];
        let [originY, originFallbackY] = [overlayY, overlayFallbackY];
        const [overlayX, overlayFallbackX] = [originX, originFallbackX];
        /** @type {?} */
        const offsetY = 0;
        if (!this.menu.overlapTrigger) {
            originY = overlayY === 'top' ? 'bottom' : 'top';
            originFallbackY = overlayFallbackY === 'top' ? 'bottom' : 'top';
        }
        // Positions from most to least desirable
        positionStrategy.withPositions([
            { originX, originY, overlayX, overlayY, offsetY },
            {
                originX: originFallbackX,
                originY,
                overlayX: overlayFallbackX,
                overlayY,
                offsetY
            },
            {
                originX,
                originY: originFallbackY,
                overlayX,
                overlayY: overlayFallbackY,
                offsetY: -offsetY
            },
            {
                originX: originFallbackX,
                originY: originFallbackY,
                overlayX: overlayFallbackX,
                overlayY: overlayFallbackY,
                offsetY: -offsetY
            }
        ]);
    }
    /**
     * Returns a stream that emits whenever an action that should close the menu occurs.
     * @private
     * @return {?}
     */
    _menuClosingActions() {
        /** @type {?} */
        const backdrop = this._overlayRef.backdropClick();
        /** @type {?} */
        const detachments = this._overlayRef.detachments();
        return merge(backdrop, detachments);
    }
    /**
     * Gets the portal that should be attached to the overlay.
     * @private
     * @return {?}
     */
    _getPortal() {
        if (!this._portal || this._portal.templateRef !== this.menu.templateRef) {
            this._portal = new TemplatePortal(this.menu.templateRef, this._viewContainerRef);
        }
        return this._portal;
    }
}
SdsMenuTriggerForDirective.decorators = [
    { type: Directive, args: [{
                selector: '[sdsMenuTriggerFor]'
            },] }
];
/** @nocollapse */
SdsMenuTriggerForDirective.ctorParameters = () => [
    { type: Overlay },
    { type: ElementRef },
    { type: ViewContainerRef },
    { type: FocusMonitor }
];
SdsMenuTriggerForDirective.propDecorators = {
    ariaHasPopup: [{ type: HostBinding, args: ['attr.aria-haspopup',] }],
    menuOpen: [{ type: HostBinding, args: ['attr.aria-expanded',] }],
    menu: [{ type: Input, args: ['sdsMenuTriggerFor',] }],
    menuOpened: [{ type: Output }],
    menuClosed: [{ type: Output }],
    _handleMousedown: [{ type: HostListener, args: ['mousedown', ['$event'],] }],
    toggleMenu: [{ type: HostListener, args: ['click',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SdsMenuModule {
}
SdsMenuModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, OverlayModule, FontAwesomeModule],
                exports: [
                    SdsMenuComponent,
                    SdsMenuItemComponent,
                    SdsMenuTriggerForDirective,
                    SdsMenuHeaderComponent
                ],
                declarations: [
                    SdsMenuComponent,
                    SdsMenuItemComponent,
                    SdsMenuTriggerForDirective,
                    SdsMenuHeaderComponent
                ],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SearchSettings {
    constructor() {
        this.placeholder = 'Search';
        this.dropdown = {
            placeholder: '-Select-',
            options: [],
            inverse: false
        };
    }
}
class SdsSearchComponent {
    /**
     * @param {?} cd
     * @param {?} focusMonitor
     * @param {?} viewportRuler
     */
    constructor(cd, focusMonitor, viewportRuler) {
        this.cd = cd;
        this.focusMonitor = focusMonitor;
        this.viewportRuler = viewportRuler;
        this.searchSettings = new SearchSettings();
        this.model = {};
        this.inputState = {
            initial: { visible: undefined },
            visible: undefined
        };
        this._onChange = (/**
         * @param {?} _
         * @return {?}
         */
        (_) => { });
        this._onTouched = (/**
         * @return {?}
         */
        () => { });
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.inputState.initial.visible = this.isInputVisible();
        this.inputState.visible = this.inputState.initial.visible;
        this.viewportRuler.change(0).subscribe((/**
         * @return {?}
         */
        () => {
            this.inputState.initial.visible = this.isInputVisible();
            this.inputState.visible = this.inputState.initial.visible;
        }));
    }
    /**
     * @return {?}
     */
    hasDropdown() {
        if (this.searchSettings &&
            this.searchSettings.dropdown &&
            this.searchSettings.dropdown.options &&
            this.searchSettings.dropdown.options.length) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleClick(event) {
        event.preventDefault();
        if (!this.inputState.visible) {
            this.setInputVisibleStyles();
            this.focusMonitor.focusVia(this.inputEl, 'program');
        }
        else if (this.inputEl.nativeElement.value || this.selectEl.nativeElement.value) {
            this.model.searchText = this.inputEl.nativeElement.value;
            if (this.selectEl && this.selectEl.nativeElement.value) {
                this.model.searchCatergory = this.selectEl.nativeElement.value;
            }
            this._onChange(this.model);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value && this.model !== value) {
            this.model = value;
            this.cd.markForCheck();
        }
        else {
            this.model = {};
            this.cd.markForCheck();
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChange = fn;
    }
    /**
     * @return {?}
     */
    isInputVisible() {
        return this.inputEl.nativeElement.getBoundingClientRect().width
            ? true
            : false;
    }
    /**
     * @return {?}
     */
    setInputVisibleStyles() {
        /** @type {?} */
        const inputWidth = this.calculateInputWidth();
        this.inputEl.nativeElement.style.display = 'block';
        this.inputEl.nativeElement.style.position = 'absolute';
        this.inputEl.nativeElement.style.left = `-${inputWidth}px`;
        this.inputEl.nativeElement.style.width = `${inputWidth}px`;
        this.inputState.visible = true;
    }
    /**
     * @return {?}
     */
    removeInputVisibleStyles() {
        this.inputEl.nativeElement.style.display = '';
        this.inputEl.nativeElement.style.position = '';
        this.inputEl.nativeElement.style.left = '';
        this.inputEl.nativeElement.style.width = '';
        this.inputState.visible = false;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    focusChange(event) {
        if (event === null && !this.inputState.initial.visible) {
            this.removeInputVisibleStyles();
        }
    }
    /**
     * @return {?}
     */
    calculateInputWidth() {
        /** @type {?} */
        const buttonElement = this.buttonEl.nativeElement;
        /** @type {?} */
        const inputElement = this.inputEl.nativeElement;
        /** @type {?} */
        const rightPosition = buttonElement.getBoundingClientRect().left;
        /** @type {?} */
        const leftPosition = this.parentSelector
            ? inputElement.closest(this.parentSelector).getBoundingClientRect().left
            : 0;
        return Math.floor(rightPosition - leftPosition);
    }
    /**
     * @return {?}
     */
    getClass() {
        /** @type {?} */
        const cls = this.searchSettings && this.searchSettings.size === 'large'
            ? 'usa-search--big'
            : 'usa-search--small';
        return this.searchSettings.dropdown && this.searchSettings.dropdown.inverse
            ? `${cls} sds-inverse`
            : cls;
    }
}
SdsSearchComponent.decorators = [
    { type: Component, args: [{
                selector: 'sds-search',
                template: "<form class=\"usa-form usa-search\" [ngClass]=\"getClass()\" role=\"search\">\n  <label class=\"usa-sr-only\" for=\"options\">Dropdown label</label>\n  <select *ngIf=\"hasDropdown()\" [value]=\"model.searchCategory? model.searchCategory :''\" #selectEl name=\"search options\"\n    class=\"usa-select\" id=\"search-options\">\n    <option [value]=\"\"> {{searchSettings.dropdown.placeholder ? searchSettings.dropdown.placeholder : '-Select-'}}</option>\n    <ng-container *ngFor=\"let item of searchSettings.dropdown.options\">\n      <optgroup *ngIf=\"item.group\" label=\"{{item.label}}\">\n        <option *ngFor=\"let child of item.group\" [value]=\"child.value\" [selected]=\"model.searchCategory == child.value\"\n          [disabled]=\"child.disabled\">\n          {{ child.label }}\n        </option>\n      </optgroup>\n      <option *ngIf=\"!item.group\" [value]=\"item.value\" [selected]=\"model.searchCategory == item.value\" [disabled]=\"item.disabled\">{{\n        item.label }}</option>\n    </ng-container>\n  </select>\n  <ng-container *ngIf=\"(searchSettings.dropdown && searchSettings.dropdown.inverse); then inverseTemplate else inputTemplate\">\n  </ng-container>\n</form>\n\n<ng-template #inputTemplate> <label class=\"usa-sr-only\" for=\"search-field\">Search</label>\n  <input #inputEl [value]=\"model.searchText? model.searchText :''\" [ngClass]=\"inputClass\" id=\"search-field\" type=\"search\" class=\"usa-input\"\n    name=\"search\" [placeholder]=\"searchSettings.placeholder? searchSettings.placeholder : 'type here'\" />\n  <button class=\"usa-button\" type=\"submit\"  (click)=\"handleClick($event)\">\n    <span class=\"usa-sr-only\">Search</span>\n  </button>\n</ng-template>\n<ng-template #inverseTemplate>\n  <div class=\"sds-inverse__search\">\n    <ng-container [ngTemplateOutlet]=\"inputTemplate\"></ng-container>\n  </div>\n</ng-template>",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => SdsSearchComponent)),
                        multi: true
                    }
                ],
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
SdsSearchComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: FocusMonitor },
    { type: ViewportRuler }
];
SdsSearchComponent.propDecorators = {
    inputEl: [{ type: ViewChild, args: ['inputEl', { read: ElementRef },] }],
    selectEl: [{ type: ViewChild, args: ['selectEl', { read: ElementRef },] }],
    buttonEl: [{ type: ViewChild, args: ['buttonEl', { read: ElementRef },] }],
    inputClass: [{ type: Input }],
    parentSelector: [{ type: Input }],
    searchSettings: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SdsSearchModule {
}
SdsSearchModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, A11yModule, FormsModule],
                exports: [SdsSearchComponent],
                declarations: [SdsSearchComponent],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Directive that triggers a callback whenever the width of
 * its associated element has changed.
 */
class SdsObserveWidthDirective {
    /**
     * @param {?} _elementRef
     * @param {?} viewportRuler
     */
    constructor(_elementRef, viewportRuler) {
        this._elementRef = _elementRef;
        this.viewportRuler = viewportRuler;
        /**
         * Event emitted for each change in the element's width.
         */
        this.elementWidth = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.windowResize$ = this.viewportRuler
            .change(0)
            .pipe(startWith(this._getElementWidth()))
            .subscribe((/**
         * @return {?}
         */
        () => this._emitEvent()));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.windowResize$.unsubscribe();
    }
    /**
     * @return {?}
     */
    _emitEvent() {
        /** @type {?} */
        const width = this._getElementWidth();
        this.elementWidth.emit(width);
    }
    /**
     * @return {?}
     */
    _getElementWidth() {
        return this._elementRef.nativeElement.offsetWidth;
    }
}
SdsObserveWidthDirective.decorators = [
    { type: Directive, args: [{ selector: '[sdsObserveWidth]' },] }
];
/** @nocollapse */
SdsObserveWidthDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ViewportRuler }
];
SdsObserveWidthDirective.propDecorators = {
    elementWidth: [{ type: Output, args: ['sdsObserveWidth',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SdsObserversModule {
}
SdsObserversModule.decorators = [
    { type: NgModule, args: [{
                imports: [],
                exports: [SdsObserveWidthDirective],
                declarations: [SdsObserveWidthDirective],
                providers: [],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Used primarily to avoid circular imports between `SdsAccordion` and `SdsAccordionItem`.
 * @type {?}
 */
const SDS_TRUNCATED_TEXT_DATA = new InjectionToken('SdsTruncatedTextData');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const sdsTruncateTextAnimations = {
    container: trigger('container', [
        state('void', style({
            opacity: 0,
            transform: 'scale(0.8)'
        })),
        transition('void => enter', group([
            query('.sds-overlay', animate('100ms linear', style({
                opacity: 1
            }))),
            animate('120ms cubic-bezier(0, 0, 0.2, 1)', style({ transform: 'scale(1)' }))
        ])),
        transition('* => void', animate('100ms 25ms linear', style({ opacity: 0 })))
    ])
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SdsTruncatedTextContainerComponent {
    /**
     * @param {?} data
     */
    constructor(data) {
        this.data = data;
        this._animationState = 'void';
    }
    /**
     * Starts the animation.
     * @return {?}
     */
    startAnimation() {
        this._animationState = 'enter';
    }
    /**
     * Resets the animation to its initial state.
     * @return {?}
     */
    resetAnimation() {
        this._animationState = 'void';
    }
    /**
     * Intentionally left empty to trigger change detection
     * @return {?}
     */
    _onAnimationDone() { }
}
SdsTruncatedTextContainerComponent.decorators = [
    { type: Component, args: [{
                selector: 'sds-truncated-text-container',
                template: `
    <div class="sds-overlay maxw-mobile radius-overlay padding-2">{{ data.text }}</div>
  `,
                animations: [sdsTruncateTextAnimations.container]
            }] }
];
/** @nocollapse */
SdsTruncatedTextContainerComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [SDS_TRUNCATED_TEXT_DATA,] }] }
];
SdsTruncatedTextContainerComponent.propDecorators = {
    _animationState: [{ type: HostBinding, args: ['@container',] }],
    _onAnimationDone: [{ type: HostListener, args: ['@container.done',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SdsTruncateTextByLineDirective {
    /**
     * @param {?} _overlay
     * @param {?} _injector
     * @param {?} _element
     * @param {?} _viewportRuler
     * @param {?} _viewContainerRef
     */
    constructor(_overlay, _injector, _element, _viewportRuler, _viewContainerRef) {
        this._overlay = _overlay;
        this._injector = _injector;
        this._element = _element;
        this._viewportRuler = _viewportRuler;
        this._viewContainerRef = _viewContainerRef;
        /**
         * PortalOutlet
         */
        this._overlayRef = null;
        /**
         * Holds subscription to stream of overlay closing events
         */
        this._closingActionsSubscription = Subscription.EMPTY;
    }
    /**
     * Maximum lines of text limit
     * @return {?}
     */
    get textLinesLimit() {
        return this._textLinesLimit;
    }
    /**
     * @param {?} _textLinesLimit
     * @return {?}
     */
    set textLinesLimit(_textLinesLimit) {
        _textLinesLimit = coerceNumberProperty(_textLinesLimit);
        if (this._textLinesLimit !== _textLinesLimit) {
            this._textLinesLimit = _textLinesLimit;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.initialText = this._element.nativeElement.innerText.trim();
        // Clone element to facilitate calculations
        /** @type {?} */
        const hostCloneEl = (/** @type {?} */ (this._element.nativeElement.cloneNode()));
        // Add 1 character to calculate character width
        hostCloneEl.innerHTML = 'x';
        // Render the clone to get character width
        this._element.nativeElement.parentElement.appendChild(hostCloneEl);
        // Set the clone to inline to prevent cases where the clone
        // expands to 100% width of the container
        hostCloneEl.setAttribute('style', 'display: inline');
        // These are close approximations that are used to better guess
        // how many characters fit in X number of lines
        this.approximatedCharacterWidth = hostCloneEl.offsetWidth;
        // Remove clone after calculations
        hostCloneEl.remove();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.windowResize$ = this._viewportRuler
            .change(0)
            .pipe(startWith('Start'))
            .subscribe((/**
         * @return {?}
         */
        () => this.updateUI()));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this._overlayRef) {
            this._overlayRef.dispose();
        }
        this._closingActionsSubscription.unsubscribe();
        this.windowResize$.unsubscribe();
    }
    /**
     * Configures and creates the CDK overlay
     * @private
     * @return {?}
     */
    _createOverlay() {
        /** @type {?} */
        const overlayPositions = {
            originX: 'start',
            originY: 'bottom',
            overlayX: 'start',
            overlayY: 'top'
        };
        /** @type {?} */
        const config = new OverlayConfig({
            positionStrategy: this._overlay
                .position()
                .flexibleConnectedTo(this._element)
                .withLockedPosition()
                .withPositions([overlayPositions])
                .withTransformOriginOn('.sds-overlay'),
            hasBackdrop: true,
            backdropClass: 'cdk-overlay-transparent-backdrop',
            scrollStrategy: this._overlay.scrollStrategies.close()
        });
        return this._overlay.create(config);
    }
    /**
     * Attach a ComponentPortal to the overlay *
     * @private
     * @param {?} overlay
     * @return {?}
     */
    _attachContainer(overlay) {
        /** @type {?} */
        const injector = new PortalInjector(this._injector, new WeakMap([[SDS_TRUNCATED_TEXT_DATA, { text: this.initialText }]]));
        /** @type {?} */
        const containerPortal = new ComponentPortal(SdsTruncatedTextContainerComponent, this._viewContainerRef, injector);
        /** @type {?} */
        const containerRef = overlay.attach(containerPortal);
        return containerRef.instance;
    }
    /**
     * Returns a stream that emits whenever an action that should close the overlay occurs.
     * @private
     * @return {?}
     */
    _overlayClosingActions() {
        /** @type {?} */
        const backdrop = this._overlayRef.backdropClick();
        /** @type {?} */
        const detachments = this._overlayRef.detachments();
        return merge(backdrop, detachments);
    }
    /**
     * Width of host element
     * @private
     * @return {?}
     */
    _getHostWidth() {
        return this._element.nativeElement.offsetWidth;
    }
    /**
     * Approximated number of characters that are visible in the container
     * @private
     * @return {?}
     */
    _getVisibleCharacters() {
        return Math.floor((this._getHostWidth() / this.approximatedCharacterWidth) *
            this.textLinesLimit);
    }
    /**
     * @private
     * @return {?}
     */
    _isNotLongEnough() {
        return this._getVisibleCharacters() > this.initialText.length;
    }
    /**
     * @return {?}
     */
    openOverlay() {
        // Exit if all text can be visible in container
        if (this._isNotLongEnough())
            return;
        this._overlayRef = this._createOverlay();
        /** @type {?} */
        const container = this._attachContainer(this._overlayRef);
        this._closingActionsSubscription = this._overlayClosingActions().subscribe((/**
         * @return {?}
         */
        () => this.closeOverlay()));
        // Wait for the next event loop tick to start the animation
        setTimeout((/**
         * @return {?}
         */
        () => {
            container.startAnimation();
        }));
    }
    /**
     * @return {?}
     */
    updateUI() {
        // Exit if all text can be visible in container
        if (this._isNotLongEnough())
            return;
        /** @type {?} */
        const ellipsis = '...';
        /** @type {?} */
        const limit = this._getVisibleCharacters() - ellipsis.length;
        /** @type {?} */
        let visibleText = this.initialText.slice(0, limit);
        {
            /** @type {?} */
            const isEndofWord = this.initialText.substr(limit, limit + 1) === ' ';
            if (!isEndofWord) {
                /** @type {?} */
                const previousWord = visibleText.lastIndexOf(' ');
                visibleText = visibleText.slice(0, previousWord);
            }
        }
        this._element.nativeElement.innerText = visibleText + ellipsis;
    }
    /**
     * @return {?}
     */
    closeOverlay() {
        this._closingActionsSubscription.unsubscribe();
        this._overlayRef.detach();
    }
}
SdsTruncateTextByLineDirective.decorators = [
    { type: Directive, args: [{ selector: '[sdsTruncateTextByLine]' },] }
];
/** @nocollapse */
SdsTruncateTextByLineDirective.ctorParameters = () => [
    { type: Overlay },
    { type: Injector },
    { type: ElementRef },
    { type: ViewportRuler },
    { type: ViewContainerRef }
];
SdsTruncateTextByLineDirective.propDecorators = {
    textLinesLimit: [{ type: Input, args: ['sdsTruncateTextByLine',] }],
    openOverlay: [{ type: HostListener, args: ['click',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SdsTruncateModule {
}
SdsTruncateModule.decorators = [
    { type: NgModule, args: [{
                imports: [],
                exports: [SdsTruncateTextByLineDirective],
                declarations: [
                    SdsTruncateTextByLineDirective,
                    SdsTruncatedTextContainerComponent
                ],
                providers: [],
                entryComponents: [SdsTruncatedTextContainerComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Configuration for opening a modal dialog with the SdsDialog service.
 * @template D
 */
class SdsDialogConfig {
    constructor() {
        /**
         * The ARIA role of the dialog element.
         */
        this.role = 'dialog';
        /**
         * Custom class for the overlay pane.
         */
        this.panelClass = '';
        /**
         * Whether the dialog has a backdrop.
         */
        this.hasBackdrop = true;
        /**
         * Custom class for the backdrop,
         */
        this.backdropClass = '';
        /**
         * Whether the user can use escape or clicking on the backdrop to close the modal.
         */
        this.disableClose = false;
        /**
         * Width of the dialog.
         */
        this.width = '';
        /**
         * Height of the dialog.
         */
        this.height = '';
        /**
         * Max-width of the dialog. If a number is provided, pixel units are assumed. Defaults to 80vw
         */
        this.maxWidth = '80vw';
        /**
         * Data being injected into the child component.
         */
        this.data = null;
        /**
         * ID of the element that describes the dialog.
         */
        this.ariaDescribedBy = null;
        /**
         * Aria label to assign to the dialog element
         */
        this.ariaLabel = null;
        /**
         * Whether the dialog should focus the first focusable element on open.
         */
        this.autoFocus = true;
        /**
         * Whether the dialog should restore focus to the
         * previously-focused element, after it's closed.
         */
        this.restoreFocus = true;
        /**
         * Whether the dialog should close when the user goes backwards/forwards in history.
         * Note that this usually doesn't include clicking on links (unless the user is using
         * the `HashLocationStrategy`).
         */
        this.closeOnNavigation = true;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const animationBody = [
    // Note: The `enter` animation transitions to `transform: none`, because for some reason
    // specifying the transform explicitly, causes IE both to blur the dialog content and
    // decimate the animation performance. Leaving it as `none` solves both issues.
    state('void, exit', style({ opacity: 0, transform: 'scale(0.7)' })),
    state('enter', style({ transform: 'none' })),
    transition('* => enter', animate('150ms cubic-bezier(0, 0, 0.2, 1)', style({ transform: 'none', opacity: 1 }))),
    transition('* => void, * => exit', animate('75ms cubic-bezier(0.4, 0.0, 0.2, 1)', style({ opacity: 0 }))),
];
/**
 * Animations used by SdsDialog.
 * \@docs-private
 * @type {?}
 */
const sdsDialogAnimations = {
    /**
     * Animation that is applied on the dialog container by defalt.
     */
    dialogContainer: trigger('dialogContainer', animationBody),
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Throws an exception for the case when a ComponentPortal is
 * attached to a DomPortalOutlet without an origin.
 * \@docs-private
 * @return {?}
 */
function throwSdsDialogContentAlreadyAttachedError() {
    throw Error('Attempting to attach dialog content after content is already attached');
}
/**
 * Internal component that wraps user-provided dialog content.
 * \@docs-private
 */
class SdsDialogContainerComponent extends BasePortalOutlet {
    /**
     * @param {?} _elementRef
     * @param {?} _focusTrapFactory
     * @param {?} _changeDetectorRef
     * @param {?} _document
     * @param {?} _config
     */
    constructor(_elementRef, _focusTrapFactory, _changeDetectorRef, _document, _config) {
        super();
        this._elementRef = _elementRef;
        this._focusTrapFactory = _focusTrapFactory;
        this._changeDetectorRef = _changeDetectorRef;
        this._document = _document;
        this._config = _config;
        /**
         * Element that was focused before the dialog was opened. Save this to restore upon close.
         */
        this._elementFocusedBeforeDialogWasOpened = null;
        /**
         * State of the dialog animation.
         */
        this._state = 'enter';
        /**
         * Emits when an animation state changes.
         */
        this._animationStateChanged = new EventEmitter();
        /**
         * ID of the element that should be considered as the dialog's label.
         */
        this._ariaLabelledBy = null;
    }
    /**
     * Attach a ComponentPortal as content to this dialog container.
     * @template T
     * @param {?} portal Portal to be attached as the dialog content.
     * @return {?}
     */
    attachComponentPortal(portal) {
        if (this._portalOutlet.hasAttached()) {
            throwSdsDialogContentAlreadyAttachedError();
        }
        this._savePreviouslyFocusedElement();
        return this._portalOutlet.attachComponentPortal(portal);
    }
    /**
     * Attach a TemplatePortal as content to this dialog container.
     * @template C
     * @param {?} portal Portal to be attached as the dialog content.
     * @return {?}
     */
    attachTemplatePortal(portal) {
        if (this._portalOutlet.hasAttached()) {
            throwSdsDialogContentAlreadyAttachedError();
        }
        this._savePreviouslyFocusedElement();
        return this._portalOutlet.attachTemplatePortal(portal);
    }
    /**
     * Moves the focus inside the focus trap.
     * @private
     * @return {?}
     */
    _trapFocus() {
        if (!this._focusTrap) {
            this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement);
        }
        // If were to attempt to focus immediately, then the content of the dialog would not yet be
        // ready in instances where change detection has to run first. To deal with this, we simply
        // wait for the microtask queue to be empty.
        if (this._config.autoFocus) {
            this._focusTrap.focusInitialElementWhenReady();
        }
    }
    /**
     * Restores focus to the element that was focused before the dialog opened.
     * @private
     * @return {?}
     */
    _restoreFocus() {
        /** @type {?} */
        const toFocus = this._elementFocusedBeforeDialogWasOpened;
        // We need the extra check, because IE can set the `activeElement` to null in some cases.
        if (this._config.restoreFocus && toFocus && typeof toFocus.focus === 'function') {
            toFocus.focus();
        }
        if (this._focusTrap) {
            this._focusTrap.destroy();
        }
    }
    /**
     * Saves a reference to the element that was focused before the dialog was opened.
     * @private
     * @return {?}
     */
    _savePreviouslyFocusedElement() {
        if (this._document) {
            this._elementFocusedBeforeDialogWasOpened = (/** @type {?} */ (this._document.activeElement));
            // Note that there is no focus method when rendering on the server.
            if (this._elementRef.nativeElement.focus) {
                // Move focus onto the dialog immediately in order to prevent the user from accidentally
                // opening multiple dialogs at the same time. Needs to be async, because the element
                // may not be focusable immediately.
                Promise.resolve().then((/**
                 * @return {?}
                 */
                () => this._elementRef.nativeElement.focus()));
            }
        }
    }
    /**
     * Callback, invoked whenever an animation on the host completes.
     * @param {?} event
     * @return {?}
     */
    _onAnimationDone(event) {
        if (event.toState === 'enter') {
            this._trapFocus();
        }
        else if (event.toState === 'exit') {
            this._restoreFocus();
        }
        this._animationStateChanged.emit(event);
    }
    /**
     * Callback, invoked when an animation on the host starts.
     * @param {?} event
     * @return {?}
     */
    _onAnimationStart(event) {
        this._animationStateChanged.emit(event);
    }
    /**
     * Starts the dialog exit animation.
     * @return {?}
     */
    _startExitAnimation() {
        this._state = 'exit';
        // Mark the container for check so it can react if the
        // view container is using OnPush change detection.
        this._changeDetectorRef.markForCheck();
    }
}
SdsDialogContainerComponent.decorators = [
    { type: Component, args: [{
                selector: 'sds-dialog-container',
                template: "<button sds-dialog-close class=\"close-btn\">\n  <fa-icon [icon]=\"['fas', 'times']\"></fa-icon>\n</button>\n\n<!-- Alert Icons -->\n<div *ngIf=\"_config.alert\" [ngSwitch]=\"_config.alert\" class=\"sds-dialog-icon\">\n  <fa-icon *ngSwitchCase=\"'error'\" [icon]=\"['fas', 'ban']\" size=\"3x\"></fa-icon>\n  <fa-icon\n    *ngSwitchCase=\"'warning'\"\n    [icon]=\"['fas', 'exclamation-triangle']\"\n    size=\"3x\"\n  ></fa-icon>\n  <fa-icon\n    *ngSwitchCase=\"'info'\"\n    [icon]=\"['fas', 'info-circle']\"\n    size=\"3x\"\n  ></fa-icon>\n  <div *ngSwitchDefault>\n    Alert <em>{{ _config.alert }}</em> is not valid\n  </div>\n</div>\n\n<ng-template cdkPortalOutlet></ng-template>\n",
                encapsulation: ViewEncapsulation.None,
                // Using OnPush for dialogs caused some G3 sync issues. Disabled until we can track them down.
                // tslint:disable-next-line:validate-decorators
                changeDetection: ChangeDetectionStrategy.Default,
                animations: [sdsDialogAnimations.dialogContainer],
                // tslint:disable-next-line: use-host-property-decorator
                host: {
                    'class': 'sds-dialog__container',
                    '[class.sds-dialog--alert]': '_config.alert',
                    '[class.sds-dialog--alert-error]': '_config.alert === "error"',
                    '[class.sds-dialog--alert-warning]': '_config.alert === "warning"',
                    '[class.sds-dialog--alert-info]': '_config.alert === "info"',
                    'tabindex': '-1',
                    'aria-modal': 'true',
                    '[attr.id]': '_id',
                    '[attr.role]': '_config.role',
                    '[attr.aria-labelledby]': '_config.ariaLabel ? null : _ariaLabelledBy',
                    '[attr.aria-label]': '_config.ariaLabel',
                    '[attr.aria-describedby]': '_config.ariaDescribedBy || null',
                    '[@dialogContainer]': '_state',
                    '(@dialogContainer.start)': '_onAnimationStart($event)',
                    '(@dialogContainer.done)': '_onAnimationDone($event)',
                }
            }] }
];
/** @nocollapse */
SdsDialogContainerComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: FocusTrapFactory },
    { type: ChangeDetectorRef },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] },
    { type: SdsDialogConfig }
];
SdsDialogContainerComponent.propDecorators = {
    _portalOutlet: [{ type: ViewChild, args: [CdkPortalOutlet,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Counter for unique dialog ids.
/** @type {?} */
let uniqueId$2 = 0;
/**
 * Reference to a dialog opened via the SdsDialog service.
 * @template T, R
 */
class SdsDialogRef {
    /**
     * @param {?} _overlayRef
     * @param {?} _containerInstance
     * @param {?=} _location
     * @param {?=} id
     */
    constructor(_overlayRef, _containerInstance, _location, id = `sds-dialog-${uniqueId$2++}`) {
        this._overlayRef = _overlayRef;
        this._containerInstance = _containerInstance;
        this.id = id;
        /**
         * Whether the user is allowed to close the dialog.
         */
        this.disableClose = this._containerInstance._config.disableClose;
        /**
         * Subject for notifying the user that the dialog has finished opening.
         */
        this._afterOpened = new Subject();
        /**
         * Subject for notifying the user that the dialog has finished closing.
         */
        this._afterClosed = new Subject();
        /**
         * Subject for notifying the user that the dialog has started closing.
         */
        this._beforeClosed = new Subject();
        // Pass the id along to the container.
        _containerInstance._id = id;
        // Emit when opening animation completes
        _containerInstance._animationStateChanged.pipe(filter((/**
         * @param {?} event
         * @return {?}
         */
        event => event.phaseName === 'done' && event.toState === 'enter')), take(1))
            .subscribe((/**
         * @return {?}
         */
        () => {
            this._afterOpened.next();
            this._afterOpened.complete();
        }));
        // Dispose overlay when closing animation is complete
        _containerInstance._animationStateChanged.pipe(filter((/**
         * @param {?} event
         * @return {?}
         */
        event => event.phaseName === 'done' && event.toState === 'exit')), take(1)).subscribe((/**
         * @return {?}
         */
        () => this._overlayRef.dispose()));
        _overlayRef.detachments().subscribe((/**
         * @return {?}
         */
        () => {
            this._beforeClosed.next(this._result);
            this._beforeClosed.complete();
            this._afterClosed.next(this._result);
            this._afterClosed.complete();
            this.componentInstance = (/** @type {?} */ (null));
            this._overlayRef.dispose();
        }));
        _overlayRef.keydownEvents()
            .pipe(filter((/**
         * @param {?} event
         * @return {?}
         */
        event => event.keyCode === ESCAPE && !this.disableClose)))
            .subscribe((/**
         * @return {?}
         */
        () => this.close()));
    }
    /**
     * Close the dialog.
     * @param {?=} dialogResult Optional result to return to the dialog opener.
     * @return {?}
     */
    close(dialogResult) {
        this._result = dialogResult;
        // Transition the backdrop in parallel to the dialog.
        this._containerInstance._animationStateChanged.pipe(filter((/**
         * @param {?} event
         * @return {?}
         */
        event => event.phaseName === 'start')), take(1))
            .subscribe((/**
         * @return {?}
         */
        () => {
            this._beforeClosed.next(dialogResult);
            this._beforeClosed.complete();
            this._overlayRef.detachBackdrop();
        }));
        this._containerInstance._startExitAnimation();
    }
    /**
     * Gets an observable that is notified when the dialog is finished opening.
     * @return {?}
     */
    afterOpened() {
        return this._afterOpened.asObservable();
    }
    /**
     * Gets an observable that is notified when the dialog is finished closing.
     * @return {?}
     */
    afterClosed() {
        return this._afterClosed.asObservable();
    }
    /**
     * Gets an observable that is notified when the dialog has started closing.
     * @return {?}
     */
    beforeClosed() {
        return this._beforeClosed.asObservable();
    }
    /**
     * Gets an observable that emits when the overlay's backdrop has been clicked.
     * @return {?}
     */
    backdropClick() {
        return this._overlayRef.backdropClick();
    }
    /**
     * Gets an observable that emits when keydown events are targeted on the overlay.
     * @return {?}
     */
    keydownEvents() {
        return this._overlayRef.keydownEvents();
    }
    /**
     * Updates the dialog's position.
     * @template THIS
     * @this {THIS}
     * @param {?=} position New dialog position.
     * @return {THIS}
     */
    updatePosition(position) {
        /** @type {?} */
        const strategy = (/** @type {?} */ (this))._getPositionStrategy();
        if (position && (position.left || position.right)) {
            position.left ? strategy.left(position.left) : strategy.right(position.right);
        }
        else {
            strategy.centerHorizontally();
        }
        if (position && (position.top || position.bottom)) {
            position.top ? strategy.top(position.top) : strategy.bottom(position.bottom);
        }
        else {
            strategy.centerVertically();
        }
        (/** @type {?} */ (this))._overlayRef.updatePosition();
        return (/** @type {?} */ (this));
    }
    /**
     * Updates the dialog's width and height.
     * @template THIS
     * @this {THIS}
     * @param {?=} width New width of the dialog.
     * @param {?=} height New height of the dialog.
     * @return {THIS}
     */
    updateSize(width = '', height = '') {
        (/** @type {?} */ (this))._getPositionStrategy().width(width).height(height);
        (/** @type {?} */ (this))._overlayRef.updatePosition();
        return (/** @type {?} */ (this));
    }
    /**
     * Add a CSS class or an array of classes to the overlay pane.
     * @template THIS
     * @this {THIS}
     * @param {?} classes
     * @return {THIS}
     */
    addPanelClass(classes) {
        (/** @type {?} */ (this))._overlayRef.addPanelClass(classes);
        return (/** @type {?} */ (this));
    }
    /**
     * Remove a CSS class or an array of classes from the overlay pane.
     * @template THIS
     * @this {THIS}
     * @param {?} classes
     * @return {THIS}
     */
    removePanelClass(classes) {
        (/** @type {?} */ (this))._overlayRef.removePanelClass(classes);
        return (/** @type {?} */ (this));
    }
    /**
     * Fetches the position strategy object from the overlay ref.
     * @private
     * @return {?}
     */
    _getPositionStrategy() {
        return (/** @type {?} */ (this._overlayRef.getConfig().positionStrategy));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Injection token that can be used to access the data that was passed in to a dialog.
 * @type {?}
 */
const SDS_DIALOG_DATA = new InjectionToken('SdsDialogData');
/**
 * Injection token that can be used to specify default dialog options.
 * @type {?}
 */
const SDS_DIALOG_DEFAULT_OPTIONS = new InjectionToken('sds-dialog-default-options');
/**
 * Injection token that determines the scroll handling while the dialog is open.
 * @type {?}
 */
const SDS_DIALOG_SCROLL_STRATEGY = new InjectionToken('sds-dialog-scroll-strategy');
/**
 * \@docs-private
 * @param {?} overlay
 * @return {?}
 */
function SDS_DIALOG_SCROLL_STRATEGY_FACTORY(overlay) {
    return (/**
     * @return {?}
     */
    () => overlay.scrollStrategies.block());
}
/**
 * \@docs-private
 * @param {?} overlay
 * @return {?}
 */
function SDS_DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {
    return (/**
     * @return {?}
     */
    () => overlay.scrollStrategies.block());
}
/**
 * \@docs-private
 * @type {?}
 */
const SDS_DIALOG_SCROLL_STRATEGY_PROVIDER = {
    provide: SDS_DIALOG_SCROLL_STRATEGY,
    deps: [Overlay],
    useFactory: SDS_DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY,
};
/**
 * Service to open modal dialogs.
 */
class SdsDialogService {
    /**
     * @param {?} _overlay
     * @param {?} _injector
     * @param {?} _location
     * @param {?} _defaultOptions
     * @param {?} scrollStrategy
     * @param {?} _parentDialog
     * @param {?} _overlayContainer
     */
    constructor(_overlay, _injector, _location, _defaultOptions, scrollStrategy, _parentDialog, _overlayContainer) {
        this._overlay = _overlay;
        this._injector = _injector;
        this._location = _location;
        this._defaultOptions = _defaultOptions;
        this._parentDialog = _parentDialog;
        this._overlayContainer = _overlayContainer;
        this._openDialogsAtThisLevel = [];
        this._afterAllClosedAtThisLevel = new Subject();
        this._afterOpenedAtThisLevel = new Subject();
        this._ariaHiddenElements = new Map();
        /**
         * Stream that emits when all open dialog have finished closing.
         * Will emit on subscribe if there are no open dialogs to begin with.
         */
        this.afterAllClosed = defer((/**
         * @return {?}
         */
        () => this.openDialogs.length ?
            this._afterAllClosed :
            this._afterAllClosed.pipe(startWith(undefined))));
        this._scrollStrategy = scrollStrategy;
    }
    /**
     * Keeps track of the currently-open dialogs.
     * @return {?}
     */
    get openDialogs() {
        return this._parentDialog ? this._parentDialog.openDialogs : this._openDialogsAtThisLevel;
    }
    /**
     * Stream that emits when a dialog has been opened.
     * @return {?}
     */
    get afterOpened() {
        return this._parentDialog ? this._parentDialog.afterOpened : this._afterOpenedAtThisLevel;
    }
    /**
     * @return {?}
     */
    get _afterAllClosed() {
        /** @type {?} */
        const parent = this._parentDialog;
        return parent ? parent._afterAllClosed : this._afterAllClosedAtThisLevel;
    }
    /**
     * Opens a modal dialog containing the given component.
     * @template T, D, R
     * @param {?} componentOrTemplateRef Type of the component to load into the dialog,
     *     or a TemplateRef to instantiate as the dialog content.
     * @param {?=} config Extra configuration options.
     * @return {?} Reference to the newly-opened dialog.
     */
    open(componentOrTemplateRef, config) {
        // Convenience widths names: small | medium | large
        // added to help with standardization
        if (config && config.width) {
            switch (config.width) {
                case 'small': {
                    config.width = '370px';
                    break;
                }
                case 'medium': {
                    config.width = '730px';
                    break;
                }
                case 'large': {
                    config.width = '960px';
                    break;
                }
                default: {
                    break;
                }
            }
        }
        config = _applyConfigDefaults(config, this._defaultOptions || new SdsDialogConfig());
        if (config.id && this.getDialogById(config.id)) {
            throw Error(`Dialog with id "${config.id}" exists already. The dialog id must be unique.`);
        }
        /** @type {?} */
        const overlayRef = this._createOverlay(config);
        /** @type {?} */
        const dialogContainer = this._attachDialogContainer(overlayRef, config);
        /** @type {?} */
        const dialogRef = this._attachDialogContent(componentOrTemplateRef, dialogContainer, overlayRef, config);
        // If this is the first dialog that we're opening, hide all the non-overlay content.
        if (!this.openDialogs.length) {
            this._hideNonDialogContentFromAssistiveTechnology();
        }
        this.openDialogs.push(dialogRef);
        dialogRef.afterClosed().subscribe((/**
         * @return {?}
         */
        () => this._removeOpenDialog(dialogRef)));
        this.afterOpened.next(dialogRef);
        return dialogRef;
    }
    /**
     * Closes all of the currently-open dialogs.
     * @return {?}
     */
    closeAll() {
        this._closeDialogs(this.openDialogs);
    }
    /**
     * Finds an open dialog by its id.
     * @param {?} id ID to use when looking up the dialog.
     * @return {?}
     */
    getDialogById(id) {
        return this.openDialogs.find((/**
         * @param {?} dialog
         * @return {?}
         */
        dialog => dialog.id === id));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // Only close the dialogs at this level on destroy
        // since the parent service may still be active.
        this._closeDialogs(this._openDialogsAtThisLevel);
        this._afterAllClosedAtThisLevel.complete();
        this._afterOpenedAtThisLevel.complete();
    }
    /**
     * Creates the overlay into which the dialog will be loaded.
     * @private
     * @param {?} config The dialog configuration.
     * @return {?} A promise resolving to the OverlayRef for the created overlay.
     */
    _createOverlay(config) {
        /** @type {?} */
        const overlayConfig = this._getOverlayConfig(config);
        return this._overlay.create(overlayConfig);
    }
    /**
     * Creates an overlay config from a dialog config.
     * @private
     * @param {?} dialogConfig The dialog configuration.
     * @return {?} The overlay configuration.
     */
    _getOverlayConfig(dialogConfig) {
        /** @type {?} */
        const state$$1 = new OverlayConfig({
            positionStrategy: this._overlay.position().global(),
            scrollStrategy: dialogConfig.scrollStrategy || this._scrollStrategy(),
            panelClass: dialogConfig.panelClass,
            hasBackdrop: dialogConfig.hasBackdrop,
            direction: dialogConfig.direction,
            minWidth: dialogConfig.minWidth,
            minHeight: dialogConfig.minHeight,
            maxWidth: dialogConfig.maxWidth,
            maxHeight: dialogConfig.maxHeight,
            disposeOnNavigation: dialogConfig.closeOnNavigation
        });
        if (dialogConfig.backdropClass) {
            state$$1.backdropClass = dialogConfig.backdropClass;
        }
        return state$$1;
    }
    /**
     * Attaches an SdsDialogContainerComponent to a dialog's already-created overlay.
     * @private
     * @param {?} overlay Reference to the dialog's underlying overlay.
     * @param {?} config The dialog configuration.
     * @return {?} A promise resolving to a ComponentRef for the attached container.
     */
    _attachDialogContainer(overlay, config) {
        /** @type {?} */
        const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
        /** @type {?} */
        const injector = new PortalInjector(userInjector || this._injector, new WeakMap([
            [SdsDialogConfig, config]
        ]));
        /** @type {?} */
        const containerPortal = new ComponentPortal(SdsDialogContainerComponent, config.viewContainerRef, injector);
        /** @type {?} */
        const containerRef = overlay.attach(containerPortal);
        return containerRef.instance;
    }
    /**
     * Attaches the user-provided component to the already-created SdsDialogContainerComponent.
     * @private
     * @template T, R
     * @param {?} componentOrTemplateRef The type of component being loaded into the dialog,
     *     or a TemplateRef to instantiate as the content.
     * @param {?} dialogContainer Reference to the wrapping SdsDialogContainerComponent.
     * @param {?} overlayRef Reference to the overlay in which the dialog resides.
     * @param {?} config The dialog configuration.
     * @return {?} A promise resolving to the SdsDialogRef that should be returned to the user.
     */
    _attachDialogContent(componentOrTemplateRef, dialogContainer, overlayRef, config) {
        // Create a reference to the dialog we're creating in order to give the user a handle
        // to modify and close it.
        /** @type {?} */
        const dialogRef = new SdsDialogRef(overlayRef, dialogContainer, this._location, config.id);
        // When the dialog backdrop is clicked, we want to close it.
        if (config.hasBackdrop) {
            overlayRef.backdropClick().subscribe((/**
             * @return {?}
             */
            () => {
                if (!dialogRef.disableClose) {
                    dialogRef.close();
                }
            }));
        }
        if (componentOrTemplateRef instanceof TemplateRef) {
            dialogContainer.attachTemplatePortal(new TemplatePortal(componentOrTemplateRef, (/** @type {?} */ (null)), (/** @type {?} */ ({ $implicit: config.data, dialogRef }))));
        }
        else {
            /** @type {?} */
            const injector = this._createInjector(config, dialogRef, dialogContainer);
            /** @type {?} */
            const contentRef = dialogContainer.attachComponentPortal(new ComponentPortal(componentOrTemplateRef, undefined, injector));
            dialogRef.componentInstance = contentRef.instance;
        }
        dialogRef
            .updateSize(config.width, config.height)
            .updatePosition(config.position);
        return dialogRef;
    }
    /**
     * Creates a custom injector to be used inside the dialog. This allows a component loaded inside
     * of a dialog to close itself and, optionally, to return a value.
     * @private
     * @template T
     * @param {?} config Config object that is used to construct the dialog.
     * @param {?} dialogRef Reference to the dialog.
     * @param {?} dialogContainer
     * @return {?} The custom injector that can be used inside the dialog.
     */
    _createInjector(config, dialogRef, dialogContainer) {
        /** @type {?} */
        const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
        // The SdsDialogContainerComponent is injected in the portal as the SdsDialogContainerComponent and the dialog's
        // content are created out of the same ViewContainerRef and as such, are siblings for injector
        // purposes. To allow the hierarchy that is expected, the SdsDialogContainerComponent is explicitly
        // added to the injection tokens.
        /** @type {?} */
        const injectionTokens = new WeakMap([
            [SdsDialogContainerComponent, dialogContainer],
            [SDS_DIALOG_DATA, config.data],
            [SdsDialogRef, dialogRef]
        ]);
        if (config.direction &&
            (!userInjector || !userInjector.get(Directionality, null))) {
            injectionTokens.set(Directionality, {
                value: config.direction,
                change: of()
            });
        }
        return new PortalInjector(userInjector || this._injector, injectionTokens);
    }
    /**
     * Removes a dialog from the array of open dialogs.
     * @private
     * @param {?} dialogRef Dialog to be removed.
     * @return {?}
     */
    _removeOpenDialog(dialogRef) {
        /** @type {?} */
        const index = this.openDialogs.indexOf(dialogRef);
        if (index > -1) {
            this.openDialogs.splice(index, 1);
            // If all the dialogs were closed, remove/restore the `aria-hidden`
            // to a the siblings and emit to the `afterAllClosed` stream.
            if (!this.openDialogs.length) {
                this._ariaHiddenElements.forEach((/**
                 * @param {?} previousValue
                 * @param {?} element
                 * @return {?}
                 */
                (previousValue, element) => {
                    if (previousValue) {
                        element.setAttribute('aria-hidden', previousValue);
                    }
                    else {
                        element.removeAttribute('aria-hidden');
                    }
                }));
                this._ariaHiddenElements.clear();
                this._afterAllClosed.next();
            }
        }
    }
    /**
     * Hides all of the content that isn't an overlay from assistive technology.
     * @private
     * @return {?}
     */
    _hideNonDialogContentFromAssistiveTechnology() {
        /** @type {?} */
        const overlayContainer = this._overlayContainer.getContainerElement();
        // Ensure that the overlay container is attached to the DOM.
        if (overlayContainer.parentElement) {
            /** @type {?} */
            const siblings = overlayContainer.parentElement.children;
            for (let i = siblings.length - 1; i > -1; i--) {
                /** @type {?} */
                const sibling = siblings[i];
                if (sibling !== overlayContainer &&
                    sibling.nodeName !== 'SCRIPT' &&
                    sibling.nodeName !== 'STYLE' &&
                    !sibling.hasAttribute('aria-live')) {
                    this._ariaHiddenElements.set(sibling, sibling.getAttribute('aria-hidden'));
                    sibling.setAttribute('aria-hidden', 'true');
                }
            }
        }
    }
    /**
     * Closes all of the dialogs in an array.
     * @private
     * @param {?} dialogs
     * @return {?}
     */
    _closeDialogs(dialogs) {
        /** @type {?} */
        let i = dialogs.length;
        while (i--) {
            // The `_openDialogs` property isn't updated after close until the rxjs subscription
            // runs on the next microtask, in addition to modifying the array as we're going
            // through it. We loop through all of them and call close without assuming that
            // they'll be removed from the list instantaneously.
            dialogs[i].close();
        }
    }
}
SdsDialogService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
SdsDialogService.ctorParameters = () => [
    { type: Overlay },
    { type: Injector },
    { type: Location, decorators: [{ type: Optional }] },
    { type: SdsDialogConfig, decorators: [{ type: Optional }, { type: Inject, args: [SDS_DIALOG_DEFAULT_OPTIONS,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [SDS_DIALOG_SCROLL_STRATEGY,] }] },
    { type: SdsDialogService, decorators: [{ type: Optional }, { type: SkipSelf }] },
    { type: OverlayContainer }
];
/**
 * Applies default options to the dialog config.
 * @param {?=} config Config to be modified.
 * @param {?=} defaultOptions Default options provided.
 * @return {?} The new configuration object.
 */
function _applyConfigDefaults(config, defaultOptions) {
    return Object.assign({}, defaultOptions, config);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Counter used to generate unique IDs for dialog elements.
 * @type {?}
 */
let dialogElementUid = 0;
/**
 * Button that will close the current dialog.
 */
class SdsDialogCloseDirective {
    /**
     * @param {?} dialogRef
     * @param {?} _elementRef
     * @param {?} _dialog
     */
    constructor(dialogRef, _elementRef, _dialog) {
        this.dialogRef = dialogRef;
        this._elementRef = _elementRef;
        this._dialog = _dialog;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.dialogRef) {
            // When this directive is included in a dialog via TemplateRef (rather than being
            // in a Component), the DialogRef isn't available via injection because embedded
            // views cannot be given a custom injector. Instead, we look up the DialogRef by
            // ID. This must occur in `onInit`, as the ID binding for the dialog container won't
            // be resolved at constructor time.
            this.dialogRef = (/** @type {?} */ (getClosestDialog(this._elementRef, this._dialog.openDialogs)));
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const proxiedChange = changes['_sdsDialogClose'] || changes['_sdsDialogCloseResult'];
        if (proxiedChange) {
            this.dialogResult = proxiedChange.currentValue;
        }
    }
}
SdsDialogCloseDirective.decorators = [
    { type: Directive, args: [{
                selector: `button[sds-dialog-close], button[sdsDialogClose]`,
                exportAs: 'sdsDialogClose',
                // tslint:disable-next-line: use-host-property-decorator
                host: {
                    '(click)': 'dialogRef.close(dialogResult)',
                    '[attr.aria-label]': 'ariaLabel || null',
                    'type': 'button',
                }
            },] }
];
/** @nocollapse */
SdsDialogCloseDirective.ctorParameters = () => [
    { type: SdsDialogRef, decorators: [{ type: Optional }] },
    { type: ElementRef },
    { type: SdsDialogService }
];
SdsDialogCloseDirective.propDecorators = {
    ariaLabel: [{ type: Input, args: ['aria-label',] }],
    dialogResult: [{ type: Input, args: ['sds-dialog-close',] }],
    _sdsDialogClose: [{ type: Input, args: ['sdsDialogClose',] }]
};
/**
 * Title of a dialog element. Stays fixed to the top of the dialog when scrolling.
 */
class SdsDialogTitleDirective {
    /**
     * @param {?} _dialogRef
     * @param {?} _elementRef
     * @param {?} _dialog
     */
    constructor(_dialogRef, _elementRef, _dialog) {
        this._dialogRef = _dialogRef;
        this._elementRef = _elementRef;
        this._dialog = _dialog;
        this.id = `sds-dialog-title-${dialogElementUid++}`;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this._dialogRef) {
            this._dialogRef = (/** @type {?} */ (getClosestDialog(this._elementRef, this._dialog.openDialogs)));
        }
        if (this._dialogRef) {
            Promise.resolve().then((/**
             * @return {?}
             */
            () => {
                /** @type {?} */
                const container = this._dialogRef._containerInstance;
                if (container && !container._ariaLabelledBy) {
                    container._ariaLabelledBy = this.id;
                }
            }));
        }
    }
}
SdsDialogTitleDirective.decorators = [
    { type: Directive, args: [{
                selector: '[sds-dialog-title], [sdsDialogTitle]',
                exportAs: 'sdsDialogTitle',
                // tslint:disable-next-line: use-host-property-decorator
                host: {
                    '[class.sds-dialog-title]': 'true',
                    '[id]': 'id',
                },
            },] }
];
/** @nocollapse */
SdsDialogTitleDirective.ctorParameters = () => [
    { type: SdsDialogRef, decorators: [{ type: Optional }] },
    { type: ElementRef },
    { type: SdsDialogService }
];
SdsDialogTitleDirective.propDecorators = {
    id: [{ type: Input }]
};
/**
 * SubTitle of a dialog element
 */
class SdsDialogSubtitleDirective {
}
SdsDialogSubtitleDirective.decorators = [
    { type: Directive, args: [{
                selector: `[sds-dialog-subtitle], sds-dialog-subtitle, [sdsDialogSubtitle]`,
                // tslint:disable-next-line: use-host-property-decorator
                host: { '[class.sds-dialog-subtitle]': 'true' }
            },] }
];
/**
 * Scrollable content container of a dialog.
 */
class SdsDialogContentDirective {
}
SdsDialogContentDirective.decorators = [
    { type: Directive, args: [{
                selector: `[sds-dialog-content], sds-dialog-content, [sdsDialogContent]`,
                // tslint:disable-next-line: use-host-property-decorator
                host: { '[class.sds-dialog-content]': 'true' }
            },] }
];
/**
 * Container for the bottom action buttons in a dialog.
 * Stays fixed to the bottom when scrolling.
 */
class SdsDialogActionsDirective {
}
SdsDialogActionsDirective.decorators = [
    { type: Directive, args: [{
                selector: `[sds-dialog-actions], sds-dialog-actions, [sdsDialogActions]`,
                // tslint:disable-next-line: use-host-property-decorator
                host: { '[class.sds-dialog-actions]': 'true' }
            },] }
];
/**
 * Finds the closest SdsDialogRef to an element by looking at the DOM.
 * @param {?} element Element relative to which to look for a dialog.
 * @param {?} openDialogs References to the currently-open dialogs.
 * @return {?}
 */
function getClosestDialog(element, openDialogs) {
    /** @type {?} */
    let parent = element.nativeElement.parentElement;
    while (parent && !parent.classList.contains('sds-dialog__container')) {
        parent = parent.parentElement;
    }
    return parent ? openDialogs.find((/**
     * @param {?} dialog
     * @return {?}
     */
    dialog => dialog.id === (/** @type {?} */ (parent)).id)) : null;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SdsDialogModule {
}
SdsDialogModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, OverlayModule, PortalModule, FontAwesomeModule],
                exports: [
                    SdsDialogContainerComponent,
                    SdsDialogCloseDirective,
                    SdsDialogTitleDirective,
                    SdsDialogSubtitleDirective,
                    SdsDialogContentDirective,
                    SdsDialogActionsDirective
                ],
                declarations: [
                    SdsDialogContainerComponent,
                    SdsDialogCloseDirective,
                    SdsDialogTitleDirective,
                    SdsDialogSubtitleDirective,
                    SdsDialogActionsDirective,
                    SdsDialogContentDirective
                ],
                providers: [SdsDialogService, SDS_DIALOG_SCROLL_STRATEGY_PROVIDER],
                entryComponents: [SdsDialogContainerComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ExternalLinkDirective {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} cfr
     * @param {?} vc
     */
    constructor(el, renderer, cfr, vc) {
        this.el = el;
        this.renderer = renderer;
        this.cfr = cfr;
        this.vc = vc;
        this.hideIcon = false;
    }
    /**
     * @private
     * @return {?}
     */
    get isExternalLink() {
        return this.href.replace(/^https?:\/\//, '').replace(/^www\./, '').split('/')[0] != location.hostname;
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        if (!this.isExternalLink) {
            return;
        }
        if (!this.hideIcon) {
            this.createIcon();
        }
    }
    /**
     * @private
     * @return {?}
     */
    createIcon() {
        // tslint:disable-next-line:no-unused-expression
        this.vc.constructor.name === "ViewContainerRef_";
        /** @type {?} */
        const factory = this.cfr.resolveComponentFactory(FaIconComponent);
        /** @type {?} */
        const component = this.vc.createComponent(factory);
        component.instance.iconProp = ['fas', 'external-link-alt'];
        /** @type {?} */
        const spanElement = document.createElement('span');
        spanElement.classList.add('margin-left-2px');
        /** @type {?} */
        const supElement = document.createElement('sup');
        supElement.appendChild(component.location.nativeElement);
        spanElement.appendChild(supElement);
        this.el.nativeElement.appendChild(spanElement);
        component.instance.ngOnChanges({});
    }
}
ExternalLinkDirective.decorators = [
    { type: Directive, args: [{
                selector: 'a[href]'
            },] }
];
/** @nocollapse */
ExternalLinkDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ComponentFactoryResolver },
    { type: ViewContainerRef }
];
ExternalLinkDirective.propDecorators = {
    href: [{ type: Input }],
    hideIcon: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SdsDirectivesModule {
}
SdsDirectivesModule.decorators = [
    { type: NgModule, args: [{
                declarations: [ExternalLinkDirective],
                imports: [
                    CommonModule, FontAwesomeModule
                ],
                entryComponents: [FaIconComponent],
                exports: [ExternalLinkDirective]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SdsVideoPlayerComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.config = {
            videoId: this.VPConfiguration.id,
            captionsOnDefault: false,
            seekInterval: this.VPConfiguration.seekInterval,
            videoTitle: 'Video Player',
            debug: this.VPConfiguration.debug
        };
        new InitPxVideo(this.config);
    }
}
SdsVideoPlayerComponent.decorators = [
    { type: Component, args: [{
                selector: 'sds-video-player',
                template: "<div class=\"px-video-container\" id=\"{{VPConfiguration.id}}\" [style.width.px]=\"VPConfiguration.width\" >\n  <div class=\"px-video-img-captions-container\" >\n      <div class=\"px-video-captions hide\" aria-hidden=\"true\"></div>\n      <video width=\"{{VPConfiguration.width}}\" height=\"{{VPConfiguration.height}}\" poster=\"{{VPConfiguration.poster}}\" controls preload={{VPConfiguration.preload}}>\n        <!-- if Safari/Chrome-->\n          <source src=\"{{VPConfiguration.sourceMp4}}\" type=\"video/mp4\" />\n          <!-- If Firefox/Opera/Chrome/IE -->\n          <source src=\"{{VPConfiguration.sourceWebm}}\" type=\"video/webm\" />\n          <track kind=\"subtitles\" kind=\"captions\" label=\"English captions\" src=\"{{VPConfiguration.caption}}\" srclang=\"en\" default />\n      </video>\n  </div>\n  <div class=\"px-video-controls\"></div>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".pull-left{float:left}.sr-only{position:absolute!important;clip:rect(1px,1px,1px,1px);padding:0!important;border:0!important;height:1px!important;width:1px!important;overflow:hidden}.hide{display:none}.show-inline{display:inline-block}.px-video-img-captions-container *{box-sizing:border-box}.px-video-img-captions-container{position:relative}.px-video-progress{width:100%;height:10px}.px-video-progress[value]{-webkit-appearance:none;border:none}.px-video-progress[value]::-webkit-progress-bar{background-color:#e6e6e6}.px-video-progress[value]::-webkit-progress-value{background-color:#009cdf}.px-video-time{font-family:\"Helvetica Neue\",Helvetica,Arial,sans-serif;float:right;margin-top:2px;font-size:14px}.px-video-captions{position:absolute;top:0;left:0;width:100%;padding:.5em;min-height:2.5em;background-color:#000;color:#fff;font-size:1.1em;text-align:center;opacity:.75}.px-video-controls button{border:1px solid #fff;background:url(../images/px-video-sprite.svg) no-repeat;padding:0;margin:0 5px;width:25px;height:20px;overflow:hidden;cursor:pointer}.px-video-controls button:focus{border:1px dotted #999;outline:0}.px-video-controls button.px-video-restart{background-position:-6px -333px;margin-left:0}.px-video-controls button.px-video-restart:focus,.px-video-controls button.px-video-restart:hover{background-position:-6px -297px}.px-video-controls button.px-video-rewind{background-position:-6px -189px}.px-video-controls button.px-video-rewind:focus,.px-video-controls button.px-video-rewind:hover{background-position:-6px -153px}.px-video-controls button.px-video-play{background-position:-6px -45px}.px-video-controls button.px-video-play:focus,.px-video-controls button.px-video-play:hover{background-position:-6px -9px}.px-video-controls button.px-video-pause{background-position:-6px -117px}.px-video-controls button.px-video-pause:focus,.px-video-controls button.px-video-pause:hover{background-position:-6px -81px}.px-video-controls button.px-video-forward{background-position:-6px -261px}.px-video-controls button.px-video-forward:focus,.px-video-controls button.px-video-forward:hover{background-position:-6px -225px}.px-video-fullscreen-btn-container label{display:inline-block;width:25px;height:20px;margin-left:10px;background:url(../images/px-video-sprite.svg) -6px -907px no-repeat}.px-video-fullscreen-btn-container input[type=checkbox]:hover+label{background-position:-6px -943px;cursor:pointer}.px-video-fullscreen-btn-container input[type=checkbox]:focus+label{outline:#999 dotted 1px;background-position:-6px -943px}.px-video-fullscreen-btn-container input[type=checkbox]:checked+label{background-position:-6px -979px}.px-video-fullscreen-btn-container input[type=checkbox]:checked:hover+label{background-position:-6px -1015px}.px-video-captions-btn-container label{display:inline-block;width:25px;height:20px;margin-left:10px;background:url(../images/px-video-sprite.svg) -6px -835px no-repeat}.px-video-captions-btn-container input[type=checkbox]:hover+label{background-position:-6px -799px;cursor:pointer}.px-video-captions-btn-container input[type=checkbox]:focus+label{outline:#999 dotted 1px;background-position:-6px -799px}.px-video-captions-btn-container input[type=checkbox]:checked+label{background-position:-6px -871px}.px-video-mute-btn-container label{display:inline-block;width:25px;height:20px;margin-left:240px;margin-top:2px;background:url(../images/px-video-sprite.svg) -6px -476px no-repeat}.px-video-mute-btn-container input[type=checkbox]:hover+label{background-position:-6px -440px;cursor:pointer}.px-video-mute-btn-container input[type=checkbox]:focus+label{outline:#999 dotted 1px;background-position:-6px -440px}.px-video-mute-btn-container input[type=checkbox]:checked+label{background-position:-6px -692px}.px-video-mute-btn-container input[type=checkbox]:checked:focus+label,.px-video-mute-btn-container input[type=checkbox]:checked:hover+label{background-position:-6px -656px}.px-video-controls input[type=range]{-webkit-appearance:none;height:6px;width:100px;margin-top:8px;background-color:#e6e6e6;outline:0}.px-video-controls input[type=range]:focus::-webkit-slider-thumb{outline:#999 dotted 1px}.px-video-controls input[type=range]::-moz-range-track{-moz-appearance:none;height:6px;background-color:#e6e6e6;border:none}.px-video-controls input[type=range]::-webkit-slider-thumb{-webkit-appearance:none!important;height:10px;width:6px;background-color:#666}.px-video-controls input[type=range]::-moz-range-thumb{height:12px;width:8px;background-color:#666}@media screen and (-ms-high-contrast:active),(-ms-high-contrast:none){.px-video-controls input[type=range]{position:relative;padding:0;height:8px;top:-3px}.px-video-time{margin-top:4px}.px-video-captions{padding:8px;min-height:36px}}.px-video-container{position:relative}.px-video-container.fullscreen{position:fixed;top:0;bottom:0;left:0;right:0;-webkit-cursor-visibility:auto-hide}.px-video-controls.js-fullscreen-controls{position:absolute;bottom:0;width:100%;z-index:940;background:#fff}.px-video-captions.js-fullscreen-captions{min-height:3.5em;font-size:2.5em;padding:1em}.px-timetip{padding:5px 10px;font-family:\"Helvetica Neue\",Helvetica,Arial,sans-serif;font-size:14px;background:rgba(0,0,0,.83);border-radius:3px;color:#fff;width:auto}.px-timetip:after{top:100%;left:50%;border:10px solid rgba(43,43,43,0);content:\" \";height:0;width:0;position:absolute;pointer-events:none;border-top-color:#2b2b2b;margin-left:-10px}"]
            }] }
];
/** @nocollapse */
SdsVideoPlayerComponent.ctorParameters = () => [];
SdsVideoPlayerComponent.propDecorators = {
    VPConfiguration: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SdsVideoPlayerModule {
}
SdsVideoPlayerModule.decorators = [
    { type: NgModule, args: [{
                declarations: [SdsVideoPlayerComponent],
                exports: [SdsVideoPlayerComponent],
                imports: [
                    CommonModule
                ],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SdsPopupDirective {
    /**
     * @param {?} el
     * @param {?} renderer
     */
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.renderer.addClass(this.el.nativeElement, 'sds-popup');
        this.sdsPopupDiv = document.createElement('div');
        this.renderer.addClass(this.sdsPopupDiv, 'sds-popup__content');
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.renderer.appendChild(this.el.nativeElement, this.sdsPopup);
        this.renderer.addClass(this.sdsPopupDiv, this.placement);
        this.renderer.addClass(this.sdsPopupDiv, this.position);
        this.renderer.appendChild(this.sdsPopupDiv, this.el.nativeElement.children[0]);
        this.renderer.appendChild(this.el.nativeElement, this.sdsPopupDiv);
    }
}
SdsPopupDirective.decorators = [
    { type: Directive, args: [{
                selector: '[sdsPopup]',
                exportAs: 'sdsPopup'
            },] }
];
/** @nocollapse */
SdsPopupDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
SdsPopupDirective.propDecorators = {
    sdsPopup: [{ type: Input }],
    position: [{ type: Input }],
    placement: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SdsPopupModule {
}
SdsPopupModule.decorators = [
    { type: NgModule, args: [{
                declarations: [SdsPopupDirective],
                imports: [
                    CommonModule
                ],
                exports: [SdsPopupDirective]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SdsTextComponent {
    /**
     * @param {?} cd
     */
    constructor(cd) {
        this.cd = cd;
        this.items = [];
        this.multiple = true;
        this._onChange = (/**
         * @param {?} _
         * @return {?}
         */
        (_) => { });
        this._onTouched = (/**
         * @return {?}
         */
        () => { });
    }
    // Helper method to programatically add a value to the existing items array
    /**
     * @param {?} val
     * @return {?}
     */
    addItem(val) {
        if (this.multiple) {
            this.items = [...this.items, val];
            this.updateModel();
        }
    }
    // Method that is fired when the child component event notifies us that the items array has been modified within the child component
    /**
     * @param {?} $event
     * @return {?}
     */
    updateItems($event) {
        this.updateModel();
    }
    // Helper method that gets a new instance of the model and notifies ControlValueAccessor that we have a new model for this FormControl (our custom component)
    /**
     * @return {?}
     */
    updateModel() {
        /** @type {?} */
        const model = this.getModel();
        this._onChange(model);
    }
    // Helper method to return a new instance of an array that contains our items
    /**
     * @return {?}
     */
    getModel() {
        return [...this.items];
    }
    // ControlValueAccessor (and Formly) is trying to update the value of the FormControl (our custom component) programatically
    // If there is a value we will just overwrite items
    // If there is no value we reset the items array to be empty
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value && value.length && this.items !== value) {
            this.items = value;
            this.cd.markForCheck();
        }
        else {
            this.items = [];
            this.cd.markForCheck();
        }
    }
    // ControlValueAccessor hook that lets us call this._onChange(var) to let the form know our variable has changed (in this case model)
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChange = fn;
    }
    // ControlValueAccessor hook (not used)
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
}
SdsTextComponent.decorators = [
    { type: Component, args: [{
                selector: 'sds-text',
                template: `
    <div>
      <input #searchInput class="usa-input display-inline-block" />
      <button class="usa-button margin-left-05 display-inline-block" (click)="addItem(searchInput.value); searchInput.value=''">Add Item</button>
    </div>

    <h4>Component Items</h4>
    <pre>{{ items | json }}</pre>

    <hr />

    <h4>Child Component Items <small>(click to remove)</small></h4>
    <sds-text-child [(items)]="items" (itemsChange)="updateItems($event)"></sds-text-child>
  `,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => SdsTextComponent)),
                        multi: true
                    }
                ],
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
SdsTextComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SdsTextChildComponent {
    constructor() {
        this.itemsChange = new EventEmitter();
    }
    // Method to remove an item from the items array, emits an event that the parent component is listening for
    /**
     * @param {?} index
     * @return {?}
     */
    removeItem(index) {
        this.items.splice(index, 1);
        this.itemsChange.emit(this.items);
    }
}
SdsTextChildComponent.decorators = [
    { type: Component, args: [{
                selector: 'sds-text-child',
                template: `
    <ng-container *ngIf="items">
      <span class="sds-tag sds-tag--chip margin-x-05" style="cursor:pointer;" *ngFor="let item of items; let i=index" (click)="removeItem(i)">{{item}} <small class="margin-left-05">(x)</small></span>
    </ng-container>
  `
            }] }
];
SdsTextChildComponent.propDecorators = {
    items: [{ type: Input }],
    itemsChange: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SdsTextModule {
}
SdsTextModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, A11yModule, FormsModule],
                exports: [SdsTextComponent, SdsTextChildComponent],
                declarations: [SdsTextComponent, SdsTextChildComponent],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { SdsAccordionModule, SdsPageModule, SdsToolbarModule, SdsHeaderModule, SdsFooterModule, PaginationModule, SDSAutocompleteComponent, SdsAutocompleteModule, SDSAutocompletelConfiguration, SDSHiercarchicalServiceSearchItem, SdsSelectedResultsModule, SDSSelectedItemModel, SDSSelectedResultConfiguration, SDSSelectedItemModelHelper, SelectionMode, SdsSideNavigationModule, SdsSearchResultListModule, FooterModel, FooterLinkSection, FooterLink, HeaderHome, HeaderNavigationLink, HeaderSecondaryLink, NavigationMode, SideNavigationModel, NavigationLink, SdsMenuModule, SdsSearchModule, SdsObserversModule, SdsTruncateModule, SdsTabOutsideModule, SDSClickOutsideModule, SDS_DIALOG_SCROLL_STRATEGY_FACTORY, SDS_DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY, SDS_DIALOG_DATA, SDS_DIALOG_DEFAULT_OPTIONS, SDS_DIALOG_SCROLL_STRATEGY, SDS_DIALOG_SCROLL_STRATEGY_PROVIDER, SdsDialogService, SdsDialogRef, SdsDialogModule, SdsDirectivesModule, SdsVideoPlayerModule, SdsPopupModule, SdsCollapseModule, SdsTextComponent, SdsTextModule, SearchSettings, SdsSearchComponent, sdsExpansionAnimations as f, SDS_ACCORDION as c, SdsAccordionItemContentDirective as g, SdsAccordionItemHeaderComponent as d, SdsAccordionItemComponent as e, SdsAccordionDirective as a, SDSAutocompleteSearchComponent as w, SdsAutocompleteSearchModule as t, SDSClickOutsideDirective as u, CollapseDirective as p, sdsDialogAnimations as bn, SdsDialogConfig as bl, SdsDialogContainerComponent as bm, SdsDialogActionsDirective as bs, SdsDialogCloseDirective as bo, SdsDialogContentDirective as br, SdsDialogSubtitleDirective as bq, SdsDialogTitleDirective as bp, ExternalLinkDirective as bt, SdsFooterComponent as q, SdsHeaderComponent as n, sdsMenuAnimations as bc, SdsMenuHeaderComponent as be, SdsMenuItemComponent as bd, SdsMenuTriggerForDirective as bf, SDS_MENU_TOKEN as z, SdsMenuComponent as bb, SdsObserveWidthDirective as bg, SdsPageComponent as h, SdsPageOptionsComponent as i, PaginationComponent as r, SdsPopupDirective as bv, SdsSearchResultListComponent as y, SDSSelectedResultComponent as s, SdsSideNavigationComponent as x, SDSTabOutsideDirective as v, SdsTextChildComponent as bw, sdsToolbarAnimations as k, SdsToolbarExpandDirective as l, SdsToolbarHeaderComponent as m, SdsToolbarComponent as j, SdsTopBannerComponent as o, sdsTruncateTextAnimations as bj, SdsTruncatedTextContainerComponent as bi, SdsTruncateTextByLineDirective as bh, SDS_TRUNCATED_TEXT_DATA as bk, SdsVideoPlayerComponent as bu };

//# sourceMappingURL=gsa-sam-components.js.map