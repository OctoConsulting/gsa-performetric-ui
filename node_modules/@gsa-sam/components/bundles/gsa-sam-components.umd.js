(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/cdk/accordion'), require('@angular/cdk/collections'), require('@angular/platform-browser/animations'), require('@angular/router'), require('@angular/cdk/platform'), require('@angular/cdk/coercion'), require('@angular/cdk/bidi'), require('@angular/animations'), require('@angular/cdk/keycodes'), require('rxjs'), require('rxjs/operators'), require('@angular/cdk/overlay'), require('@angular/cdk/portal'), require('@fortawesome/angular-fontawesome'), require('@angular/core'), require('@angular/cdk/a11y'), require('@angular/common'), require('@angular/forms')) :
    typeof define === 'function' && define.amd ? define('@gsa-sam/components', ['exports', '@angular/cdk/accordion', '@angular/cdk/collections', '@angular/platform-browser/animations', '@angular/router', '@angular/cdk/platform', '@angular/cdk/coercion', '@angular/cdk/bidi', '@angular/animations', '@angular/cdk/keycodes', 'rxjs', 'rxjs/operators', '@angular/cdk/overlay', '@angular/cdk/portal', '@fortawesome/angular-fontawesome', '@angular/core', '@angular/cdk/a11y', '@angular/common', '@angular/forms'], factory) :
    (factory((global['gsa-sam'] = global['gsa-sam'] || {}, global['gsa-sam'].components = {}),global.ng.cdk.accordion,global.ng.cdk.collections,global.ng.platformBrowser.animations,global.ng.router,global.ng.cdk.platform,global.ng.cdk.coercion,global.ng.cdk.bidi,global.ng.animations,global.ng.cdk.keycodes,global.rxjs,global.rxjs.operators,global.ng.cdk.overlay,global.ng.cdk.portal,global.angularFontawesome,global.ng.core,global.ng.cdk.a11y,global.ng.common,global.ng.forms));
}(this, (function (exports,accordion,collections,animations,router,platform,coercion,bidi,animations$1,keycodes,rxjs,operators,overlay,portal,angularFontawesome,core,a11y,common,forms) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (b.hasOwnProperty(p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Token used to provide a `SdsAccordion` to `SdsAccordionItem`.
     * Used primarily to avoid circular imports between `SdsAccordion` and `SdsAccordionItem`.
     * @type {?}
     */
    var SDS_ACCORDION = new core.InjectionToken('SDS_ACCORDION');

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Time and timing curve for accordion item animations.
     * @type {?}
     */
    var ACCORDION_ITEM_ANIMATION_TIMING = '225ms cubic-bezier(0.4,0.0,0.2,1)';
    /** @type {?} */
    var sdsExpansionAnimations = {
        /**
         * Animation that expands and collapses the accordion item content.
         */
        bodyExpansion: animations$1.trigger('bodyExpansion', [
            animations$1.state('collapsed, void', animations$1.style({ height: '0px', visibility: 'hidden' })),
            animations$1.state('expanded', animations$1.style({ height: '*', visibility: 'visible' })),
            animations$1.transition('expanded <=> collapsed, void => collapsed', animations$1.animate(ACCORDION_ITEM_ANIMATION_TIMING)),
        ])
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Accordion Item content that will be rendered lazily
     * after the accordion item is opened for the first time.
     */
    var SdsAccordionItemContentDirective = /** @class */ (function () {
        function SdsAccordionItemContentDirective(_template) {
            this._template = _template;
        }
        SdsAccordionItemContentDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'ng-template[sdsAccordionItemContent]'
                    },] }
        ];
        /** @nocollapse */
        SdsAccordionItemContentDirective.ctorParameters = function () {
            return [
                { type: core.TemplateRef }
            ];
        };
        return SdsAccordionItemContentDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Counter for generating unique element ids.
     * @type {?}
     */
    var uniqueId = 0;
    var SdsAccordionItemComponent = /** @class */ (function (_super) {
        __extends(SdsAccordionItemComponent, _super);
        function SdsAccordionItemComponent(accordion$$1, _changeDetectorRef, _uniqueSelectionDispatcher, _viewContainerRef, _document, _animationMode) {
            var _this = _super.call(this, accordion$$1, _changeDetectorRef, _uniqueSelectionDispatcher) || this;
            _this._viewContainerRef = _viewContainerRef;
            _this._animationMode = _animationMode;
            /**
             * An event emitted after the body's expansion animation happens.
             */
            _this.afterExpand = new core.EventEmitter();
            /**
             * An event emitted after the body's collapse animation happens.
             */
            _this.afterCollapse = new core.EventEmitter();
            /**
             * Stream that emits for changes in `\@Input` properties.
             */
            _this._inputChanges = new rxjs.Subject();
            /**
             * ID for the associated header element. Used for a11y labelling.
             */
            _this._headerId = "sds-accordion-item-header-" + uniqueId++;
            /**
             * Stream of body animation done events.
             */
            _this._bodyAnimationDone = new rxjs.Subject();
            _this.accordion = accordion$$1;
            _this._document = _document;
            // We need a Subject with distinctUntilChanged, because the `done` event
            // fires twice on some browsers. See https://github.com/angular/angular/issues/24084
            _this._bodyAnimationDone.pipe(operators.distinctUntilChanged(( /**
             * @param {?} x
             * @param {?} y
             * @return {?}
             */function (x, y) {
                return x.fromState === y.fromState && x.toState === y.toState;
            }))).subscribe(( /**
             * @param {?} event
             * @return {?}
             */function (event) {
                if (event.fromState !== 'void') {
                    if (event.toState === 'expanded') {
                        _this.afterExpand.emit();
                    }
                    else if (event.toState === 'collapsed') {
                        _this.afterCollapse.emit();
                    }
                }
            }));
            return _this;
        }
        /** Gets the expanded state string. */
        /**
         * Gets the expanded state string.
         * @return {?}
         */
        SdsAccordionItemComponent.prototype._getExpandedState = /**
         * Gets the expanded state string.
         * @return {?}
         */
            function () {
                return this.expanded ? 'expanded' : 'collapsed';
            };
        /**
         * @return {?}
         */
        SdsAccordionItemComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._lazyContent) {
                    // Render the content as soon as the accordion item becomes open.
                    this.opened.pipe(operators.startWith(( /** @type {?} */(null))), operators.filter(( /**
                     * @return {?}
                     */function () { return _this.expanded && !_this._portal; })), operators.take(1)).subscribe(( /**
                     * @return {?}
                     */function () {
                        _this._portal = new portal.TemplatePortal(_this._lazyContent._template, _this._viewContainerRef);
                    }));
                }
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        SdsAccordionItemComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                this._inputChanges.next(changes);
            };
        /**
         * @return {?}
         */
        SdsAccordionItemComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnDestroy.call(this);
                this._bodyAnimationDone.complete();
                this._inputChanges.complete();
            };
        /** Checks whether the accordion item's content contains the currently-focused element. */
        /**
         * Checks whether the accordion item's content contains the currently-focused element.
         * @return {?}
         */
        SdsAccordionItemComponent.prototype._containsFocus = /**
         * Checks whether the accordion item's content contains the currently-focused element.
         * @return {?}
         */
            function () {
                if (this._body) {
                    /** @type {?} */
                    var focusedElement = this._document.activeElement;
                    /** @type {?} */
                    var bodyElement = this._body.nativeElement;
                    return focusedElement === bodyElement || bodyElement.contains(focusedElement);
                }
                return false;
            };
        SdsAccordionItemComponent.decorators = [
            { type: core.Component, args: [{
                        selector: "sds-accordion-item",
                        exportAs: "sdsAccordionItem",
                        template: "<ng-content select=\"sds-accordion-item-header\"></ng-content>\n<div\n  class=\"sam-accordion__panel\"\n  role=\"region\"\n  [@bodyExpansion]=\"_getExpandedState()\"\n  (@bodyExpansion.done)=\"_bodyAnimationDone.next($event)\"\n  [attr.aria-labelledby]=\"_headerId\"\n  [id]=\"id\"\n  #body\n>\n  <div class=\"sds-accordion__panel-body\">\n    <ng-content></ng-content>\n    <ng-template [cdkPortalOutlet]=\"_portal\"></ng-template>\n  </div>\n</div>\n",
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        inputs: ['disabled', 'expanded'],
                        outputs: ['opened', 'closed', 'expandedChange'],
                        animations: [sdsExpansionAnimations.bodyExpansion],
                        host: {
                            'class': 'sds-accordion__item',
                            '[class.sds-accordion__item--expanded]': 'expanded',
                            '[class._sds-animation-noopable]': '_animationMode === "NoopAnimations"'
                        }
                    }] }
        ];
        /** @nocollapse */
        SdsAccordionItemComponent.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: core.Optional }, { type: core.SkipSelf }, { type: core.Inject, args: [SDS_ACCORDION,] }] },
                { type: core.ChangeDetectorRef },
                { type: collections.UniqueSelectionDispatcher },
                { type: core.ViewContainerRef },
                { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] },
                { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [animations.ANIMATION_MODULE_TYPE,] }] }
            ];
        };
        SdsAccordionItemComponent.propDecorators = {
            afterExpand: [{ type: core.Output }],
            afterCollapse: [{ type: core.Output }],
            _lazyContent: [{ type: core.ContentChild, args: [SdsAccordionItemContentDirective,] }],
            _body: [{ type: core.ViewChild, args: ['body',] }]
        };
        return SdsAccordionItemComponent;
    }(accordion.CdkAccordionItem));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SdsAccordionItemHeaderComponent = /** @class */ (function () {
        function SdsAccordionItemHeaderComponent(accordionItem, _element, _focusMonitor, _changeDetectorRef) {
            var _this = this;
            this.accordionItem = accordionItem;
            this._element = _element;
            this._focusMonitor = _focusMonitor;
            this._changeDetectorRef = _changeDetectorRef;
            this._parentChangeSubscription = rxjs.Subscription.EMPTY;
            // Since the toggle state depends on an @Input on the accordion item, we
            // need to subscribe and trigger change detection manually.
            this._parentChangeSubscription = rxjs.merge(accordionItem.opened, accordionItem.closed, accordionItem._inputChanges.pipe(operators.filter(( /**
             * @param {?} changes
             * @return {?}
             */function (changes) { return !!(changes["disabled"]); })))).subscribe(( /**
             * @return {?}
             */function () { return _this._changeDetectorRef.markForCheck(); }));
            _focusMonitor.monitor(_element).subscribe(( /**
             * @param {?} origin
             * @return {?}
             */function (origin) {
                if (origin && accordionItem.accordion) {
                    accordionItem.accordion._handleHeaderFocus(_this);
                }
            }));
        }
        Object.defineProperty(SdsAccordionItemHeaderComponent.prototype, "disabled", {
            /**
             * Whether the associated accordion item is disabled.
             * Implemented as a part of `FocusableOption`.
             */
            get: /**
             * Whether the associated accordion item is disabled.
             * Implemented as a part of `FocusableOption`.
             * @return {?}
             */ function () {
                return this.accordionItem.disabled;
            },
            enumerable: true,
            configurable: true
        });
        /** Toggles the expanded state of the accordion item. */
        /**
         * Toggles the expanded state of the accordion item.
         * @return {?}
         */
        SdsAccordionItemHeaderComponent.prototype._toggle = /**
         * Toggles the expanded state of the accordion item.
         * @return {?}
         */
            function () {
                this.accordionItem.toggle();
            };
        /** Gets whether the accordion item is expanded. */
        /**
         * Gets whether the accordion item is expanded.
         * @return {?}
         */
        SdsAccordionItemHeaderComponent.prototype._isExpanded = /**
         * Gets whether the accordion item is expanded.
         * @return {?}
         */
            function () {
                return this.accordionItem.expanded;
            };
        /** Gets the accordion item id. */
        /**
         * Gets the accordion item id.
         * @return {?}
         */
        SdsAccordionItemHeaderComponent.prototype._getAccordionItemId = /**
         * Gets the accordion item id.
         * @return {?}
         */
            function () {
                return this.accordionItem.id;
            };
        /** Handle keydown event calling to toggle() if appropriate. */
        /**
         * Handle keydown event calling to toggle() if appropriate.
         * @param {?} event
         * @return {?}
         */
        SdsAccordionItemHeaderComponent.prototype._keydown = /**
         * Handle keydown event calling to toggle() if appropriate.
         * @param {?} event
         * @return {?}
         */
            function (event) {
                switch (event.keyCode) {
                    // Toggle for space and enter keys.
                    case keycodes.SPACE:
                    case keycodes.ENTER:
                        if (!keycodes.hasModifierKey(event)) {
                            event.preventDefault();
                            this._toggle();
                        }
                        break;
                    default:
                        if (this.accordionItem.accordion) {
                            this.accordionItem.accordion._handleHeaderKeydown(event);
                        }
                        return;
                }
            };
        /**
         * Focuses the item header. Implemented as a part of `FocusableOption`.
         * @param origin Origin of the action that triggered the focus.
         * @docs-private
         */
        /**
         * Focuses the item header. Implemented as a part of `FocusableOption`.
         * \@docs-private
         * @param {?=} origin Origin of the action that triggered the focus.
         * @return {?}
         */
        SdsAccordionItemHeaderComponent.prototype.focus = /**
         * Focuses the item header. Implemented as a part of `FocusableOption`.
         * \@docs-private
         * @param {?=} origin Origin of the action that triggered the focus.
         * @return {?}
         */
            function (origin) {
                if (origin === void 0) {
                    origin = "program";
                }
                this._focusMonitor.focusVia(this._element, origin);
            };
        /**
         * @return {?}
         */
        SdsAccordionItemHeaderComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._parentChangeSubscription.unsubscribe();
                this._focusMonitor.stopMonitoring(this._element);
            };
        SdsAccordionItemHeaderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: "sds-accordion-item-header",
                        template: "<span class=\"sds-accordion__title\" role=\"heading\">\n  <span class=\"sds-accordion__title-text\">\n    <ng-content></ng-content>\n  </span>\n  <span class=\"sds-accordion__icon\"></span>\n</span>\n",
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        host: {
                            class: "sds-accordion__trigger",
                            role: "button",
                            "[attr.id]": "accordionItem._headerId",
                            "[attr.tabindex]": "disabled ? -1 : 0",
                            "[attr.aria-controls]": "_getAccordionItemId()",
                            "[attr.aria-expanded]": "_isExpanded()",
                            "[attr.aria-disabled]": "accordionItem.disabled",
                            "(click)": "_toggle()",
                            "(keydown)": "_keydown($event)"
                        },
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        SdsAccordionItemHeaderComponent.ctorParameters = function () {
            return [
                { type: SdsAccordionItemComponent, decorators: [{ type: core.Host }] },
                { type: core.ElementRef },
                { type: a11y.FocusMonitor },
                { type: core.ChangeDetectorRef }
            ];
        };
        return SdsAccordionItemHeaderComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SdsAccordionDirective = /** @class */ (function (_super) {
        __extends(SdsAccordionDirective, _super);
        function SdsAccordionDirective() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.displayMode = "default";
            return _this;
        }
        /**
         * @return {?}
         */
        SdsAccordionDirective.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                this._keyManager = new a11y.FocusKeyManager(this._headers).withWrap();
            };
        /** Handles keyboard events coming in from the item headers. */
        /**
         * Handles keyboard events coming in from the item headers.
         * @param {?} event
         * @return {?}
         */
        SdsAccordionDirective.prototype._handleHeaderKeydown = /**
         * Handles keyboard events coming in from the item headers.
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var keyCode = event.keyCode;
                if (keyCode === keycodes.HOME) {
                    this._keyManager.setFirstItemActive();
                    event.preventDefault();
                }
                else if (keyCode === keycodes.END) {
                    this._keyManager.setLastItemActive();
                    event.preventDefault();
                }
                else {
                    this._keyManager.onKeydown(event);
                }
            };
        /**
         * @param {?} header
         * @return {?}
         */
        SdsAccordionDirective.prototype._handleHeaderFocus = /**
         * @param {?} header
         * @return {?}
         */
            function (header) {
                this._keyManager.updateActiveItem(header);
            };
        SdsAccordionDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: "sds-accordion",
                        exportAs: "sdsAccordion",
                        inputs: ["multi"],
                        providers: [
                            {
                                provide: SDS_ACCORDION,
                                useExisting: SdsAccordionDirective
                            }
                        ],
                        host: {
                            'class': 'sds-accordion',
                            '[class.sds-accordion--basic]': 'displayMode === "basic"',
                        }
                    },] }
        ];
        SdsAccordionDirective.propDecorators = {
            _headers: [{ type: core.ContentChildren, args: [SdsAccordionItemHeaderComponent, { descendants: true },] }],
            displayMode: [{ type: core.Input }]
        };
        return SdsAccordionDirective;
    }(accordion.CdkAccordion));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SdsAccordionModule = /** @class */ (function () {
        function SdsAccordionModule() {
        }
        SdsAccordionModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, portal.PortalModule],
                        exports: [
                            SdsAccordionDirective,
                            SdsAccordionItemComponent,
                            SdsAccordionItemHeaderComponent,
                            SdsAccordionItemContentDirective
                        ],
                        declarations: [
                            SdsAccordionDirective,
                            SdsAccordionItemComponent,
                            SdsAccordionItemHeaderComponent,
                            SdsAccordionItemContentDirective
                        ],
                        providers: []
                    },] }
        ];
        return SdsAccordionModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SdsPageComponent = /** @class */ (function () {
        function SdsPageComponent() {
        }
        /**
         * @return {?}
         */
        SdsPageComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () { };
        SdsPageComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'sds-page',
                        template: "\n    <div class=\"grid-container\"><ng-content></ng-content></div>\n  "
                    }] }
        ];
        /** @nocollapse */
        SdsPageComponent.ctorParameters = function () { return []; };
        return SdsPageComponent;
    }());
    var SdsPageOptionsComponent = /** @class */ (function () {
        function SdsPageOptionsComponent() {
        }
        /**
         * @return {?}
         */
        SdsPageOptionsComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () { };
        SdsPageOptionsComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'sds-page-options',
                        template: "\n    <div class=\"grid-row position-relative\"><ng-content></ng-content></div>\n  "
                    }] }
        ];
        /** @nocollapse */
        SdsPageOptionsComponent.ctorParameters = function () { return []; };
        return SdsPageOptionsComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SdsPageModule = /** @class */ (function () {
        function SdsPageModule() {
        }
        SdsPageModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [],
                        exports: [SdsPageComponent, SdsPageOptionsComponent],
                        declarations: [SdsPageComponent, SdsPageOptionsComponent],
                        providers: [],
                    },] }
        ];
        return SdsPageModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Time and timing curve for accordion item animations.
     * @type {?}
     */
    var TOOLBAR_ANIMATION_TIMING = '225ms cubic-bezier(0.4,0.0,0.2,1)';
    /** @type {?} */
    var sdsToolbarAnimations = {
        /**
         * Animation that expands and collapses the accordion item content.
         */
        bodyExpansion: animations$1.trigger('bodyExpansion', [
            animations$1.state('collapsed, void', animations$1.style({ width: '0px', height: '0px', opacity: '0', visibility: 'hidden' })),
            animations$1.state('expanded', animations$1.style({ width: '{{expandedWidth}}', height: '*', opacity: '1', visibility: 'visible' }), {
                params: { expandedWidth: '300px' }
            }),
            animations$1.transition('expanded <=> collapsed, void => collapsed', animations$1.animate(TOOLBAR_ANIMATION_TIMING)),
        ])
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Counter for generating unique element ids.
     * @type {?}
     */
    var uniqueId$1 = 0;
    var SdsToolbarComponent = /** @class */ (function () {
        function SdsToolbarComponent() {
            /**
             * The unique Toolbar id.
             */
            this.id = uniqueId$1++;
            /**
             * ID for the header element. Used for a11y labelling.
             */
            this._headerId = "sds-toolbar-header-" + this.id;
            /**
             * ID for the content element. Used for a11y labelling.
             */
            this._contentId = "sds-toolbar-content-" + this.id;
            /**
             * Emits whenever the expanded state of the toolbar changes.
             */
            this.expandedChange = new core.EventEmitter();
            this._expanded = false;
            this._disabled = false;
            /**
             * Width of the toolbar when is expanded.
             */
            this.expandedWidth = "300px";
            // Elements that surround the toolbar need to make space for the expanded toolbar.
            // Adding 20 more pixes to provide padding
            this.expandedSpace = "20px";
        }
        Object.defineProperty(SdsToolbarComponent.prototype, "expanded", {
            /** Whether the toolbar is expanded. */
            get: /**
             * Whether the toolbar is expanded.
             * @return {?}
             */ function () {
                return this._expanded;
            },
            set: /**
             * @param {?} expanded
             * @return {?}
             */ function (expanded) {
                expanded = coercion.coerceBooleanProperty(expanded);
                // Only emit events and update the internal value if the value changes.
                if (this._expanded !== expanded) {
                    this._expanded = expanded;
                    this.expandedChange.emit(expanded);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SdsToolbarComponent.prototype, "disabled", {
            /** Whether the toolbar is disabled. */
            get: /**
             * Whether the toolbar is disabled.
             * @return {?}
             */ function () {
                return this._disabled;
            },
            set: /**
             * @param {?} disabled
             * @return {?}
             */ function (disabled) {
                this._disabled = coercion.coerceBooleanProperty(disabled);
            },
            enumerable: true,
            configurable: true
        });
        /** Toggles the expanded state of the toolbar. */
        /**
         * Toggles the expanded state of the toolbar.
         * @return {?}
         */
        SdsToolbarComponent.prototype.toggle = /**
         * Toggles the expanded state of the toolbar.
         * @return {?}
         */
            function () {
                this.expanded = !this.expanded;
            };
        /** Gets the expanded state string. */
        /**
         * Gets the expanded state string.
         * @return {?}
         */
        SdsToolbarComponent.prototype._getExpandedState = /**
         * Gets the expanded state string.
         * @return {?}
         */
            function () {
                return this.expanded ? "expanded" : "collapsed";
            };
        SdsToolbarComponent.decorators = [
            { type: core.Component, args: [{
                        selector: "sds-toolbar",
                        exportAs: "sdsToolbar",
                        template: "<sds-toolbar-header></sds-toolbar-header>\n<div\n  class=\"sds-toolbar__content\"\n  role=\"region\"\n  [@bodyExpansion]=\"{\n    value: _getExpandedState(),\n    params: { expandedWidth: expandedWidth }\n  }\"\n  [attr.aria-labelledby]=\"_headerId\"\n  [id]=\"_contentId\"\n>\n  <ng-content></ng-content>\n</div>\n",
                        animations: [sdsToolbarAnimations.bodyExpansion],
                        host: {
                            class: "sds-toolbar",
                            "[class.sds-toolbar--expanded]": "expanded"
                        }
                    }] }
        ];
        /** @nocollapse */
        SdsToolbarComponent.ctorParameters = function () { return []; };
        SdsToolbarComponent.propDecorators = {
            expandedChange: [{ type: core.Output }],
            expanded: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            expandedWidth: [{ type: core.Input }],
            expandedSpace: [{ type: core.Input }]
        };
        return SdsToolbarComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SdsToolbarHeaderComponent = /** @class */ (function () {
        function SdsToolbarHeaderComponent(toolbar) {
            this.toolbar = toolbar;
        }
        /** Toggles the expanded state of the toolbar. */
        /**
         * Toggles the expanded state of the toolbar.
         * @return {?}
         */
        SdsToolbarHeaderComponent.prototype._toggle = /**
         * Toggles the expanded state of the toolbar.
         * @return {?}
         */
            function () {
                this.toolbar.toggle();
            };
        Object.defineProperty(SdsToolbarHeaderComponent.prototype, "_isExpanded", {
            /** Gets whether the toolbar is expanded. */
            get: /**
             * Gets whether the toolbar is expanded.
             * @return {?}
             */ function () {
                return this.toolbar.expanded;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SdsToolbarHeaderComponent.prototype, "_disabled", {
            /** Whether the toolbar is disabled. */
            get: /**
             * Whether the toolbar is disabled.
             * @return {?}
             */ function () {
                return this.toolbar.disabled;
            },
            enumerable: true,
            configurable: true
        });
        SdsToolbarHeaderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: "sds-toolbar-header",
                        template: "<button\n  class=\"sds-toolbar__toogle-btn\"\n  [attr.id]=\"toolbar._headerId\"\n  [attr.tabindex]=\"_disabled ? -1 : 0\"\n  [attr.aria-controls]=\"toolbar._contentId\"\n  [attr.aria-expanded]=\"_isExpanded\"\n  [attr.aria-disabled]=\"_disabled\"\n  (click)=\"_toggle()\"\n>\n  <div class=\"sds-toolbar__toggle\">\n    <span class=\"usa-sr-only\">Open/Close Toolbar</span>\n  </div>\n</button>\n",
                        host: {
                            class: "sds-toolbar__header"
                        }
                    }] }
        ];
        /** @nocollapse */
        SdsToolbarHeaderComponent.ctorParameters = function () {
            return [
                { type: SdsToolbarComponent, decorators: [{ type: core.Host }] }
            ];
        };
        return SdsToolbarHeaderComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SdsToolbarExpandDirective = /** @class */ (function () {
        function SdsToolbarExpandDirective(renderer, _element) {
            this.renderer = renderer;
            this._element = _element;
        }
        Object.defineProperty(SdsToolbarExpandDirective.prototype, "toolbar", {
            /** References the toolbar instance that the element its associated with. */
            get: /**
             * References the toolbar instance that the element its associated with.
             * @return {?}
             */ function () {
                return this._toolbar;
            },
            set: /**
             * @param {?} toolbar
             * @return {?}
             */ function (toolbar) {
                if (toolbar === this._toolbar) {
                    return;
                }
                this._toolbar = toolbar;
                /** Sets toolbar expanded width */
                this._expandedWidth = this._toolbar.expandedSpace;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SdsToolbarExpandDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.setStyle(this.toolbar.expanded);
                this.toolbar.expandedChange.subscribe(( /**
                 * @param {?} value
                 * @return {?}
                 */function (value) {
                    _this.setStyle(value);
                }));
            };
        /**
         * @private
         * @param {?} value
         * @return {?}
         */
        SdsToolbarExpandDirective.prototype.setStyle = /**
         * @private
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value) {
                    this.renderer.setStyle(this._element.nativeElement, "margin-left", "" + this._expandedWidth);
                }
                else {
                    this.renderer.removeStyle(this._element.nativeElement, "margin-left");
                }
            };
        SdsToolbarExpandDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: "[sdsToolbarExpand]"
                    },] }
        ];
        /** @nocollapse */
        SdsToolbarExpandDirective.ctorParameters = function () {
            return [
                { type: core.Renderer2 },
                { type: core.ElementRef }
            ];
        };
        SdsToolbarExpandDirective.propDecorators = {
            toolbar: [{ type: core.Input, args: ["sdsToolbarExpand",] }]
        };
        return SdsToolbarExpandDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SdsToolbarModule = /** @class */ (function () {
        function SdsToolbarModule() {
        }
        SdsToolbarModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [SdsToolbarComponent, SdsToolbarExpandDirective],
                        declarations: [
                            SdsToolbarComponent,
                            SdsToolbarHeaderComponent,
                            SdsToolbarExpandDirective
                        ],
                        providers: []
                    },] }
        ];
        return SdsToolbarModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {number} */
    var NavigationMode = {
        INTERNAL: 0, EXTERNAL: 1, EVENT: 2, LABEL: 3,
    };
    NavigationMode[NavigationMode.INTERNAL] = 'INTERNAL';
    NavigationMode[NavigationMode.EXTERNAL] = 'EXTERNAL';
    NavigationMode[NavigationMode.EVENT] = 'EVENT';
    NavigationMode[NavigationMode.LABEL] = 'LABEL';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NavigationHelper = /** @class */ (function () {
        function NavigationHelper() {
        }
        /**
         * checks if link is internal
         * @param link
         */
        /**
         * checks if link is internal
         * @param {?} link
         * @return {?}
         */
        NavigationHelper.prototype.isLinkInternal = /**
         * checks if link is internal
         * @param {?} link
         * @return {?}
         */
            function (link) {
                return link.mode === NavigationMode.INTERNAL;
            };
        /**
         * checks if link is external
         * @param link
         */
        /**
         * checks if link is external
         * @param {?} link
         * @return {?}
         */
        NavigationHelper.prototype.isLinkExternal = /**
         * checks if link is external
         * @param {?} link
         * @return {?}
         */
            function (link) {
                return link.mode === NavigationMode.EXTERNAL;
            };
        return NavigationHelper;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SdsHeaderComponent = /** @class */ (function () {
        function SdsHeaderComponent() {
            this.mobileNavActive = false;
            /**
             * Navigation helper
             */
            this.navigationHelper = new NavigationHelper();
            /**
             * determines if the top banner is shown
             */
            this.showTopBanner = true;
            this.topBannerDescription = '';
            /**
             * event for event based
             */
            this.linkEvent = new core.EventEmitter();
        }
        /**
         * Takes in a text string and removes all white space characters and returns the new string
         * @param text
         */
        /**
         * Takes in a text string and removes all white space characters and returns the new string
         * @param {?} text
         * @return {?}
         */
        SdsHeaderComponent.prototype.removeWhiteSpace = /**
         * Takes in a text string and removes all white space characters and returns the new string
         * @param {?} text
         * @return {?}
         */
            function (text) {
                return text.replace(/ /g, '');
            };
        /**
         * seeif any secondary link has a counter
         */
        /**
         * seeif any secondary link has a counter
         * @return {?}
         */
        SdsHeaderComponent.prototype.hasCounter = /**
         * seeif any secondary link has a counter
         * @return {?}
         */
            function () {
                /** @type {?} */
                var hasCounter = false;
                if (this.model) {
                    if (this.model.secondaryLinks) {
                        this.model.secondaryLinks.forEach(( /**
                         * @param {?} item
                         * @return {?}
                         */function (item) {
                            if (item.hasCounter) {
                                hasCounter = true;
                            }
                        }));
                    }
                }
                return hasCounter;
            };
        /**
         * Deselects previous seletion
         * @param id
         */
        /**
         * Deselects previous seletion
         * @param {?} id
         * @return {?}
         */
        SdsHeaderComponent.prototype.select = /**
         * Deselects previous seletion
         * @param {?} id
         * @return {?}
         */
            function (id) {
                this.deselect();
                /** @type {?} */
                var item = this.find(id);
                if (item) {
                    item.selected = true;
                }
            };
        /**
         * Deselects all the items in the header model
         */
        /**
         * Deselects all the items in the header model
         * @return {?}
         */
        SdsHeaderComponent.prototype.deselect = /**
         * Deselects all the items in the header model
         * @return {?}
         */
            function () {
                if (this.model) {
                    if (this.model.home) {
                        this.model.home.selected = false;
                    }
                    if (this.model.navigationLinks) {
                        this.model.navigationLinks.forEach(( /**
                         * @param {?} item
                         * @return {?}
                         */function (item) {
                            item.selected = false;
                            if (item.children) {
                                item.children.forEach(( /**
                                 * @param {?} child
                                 * @return {?}
                                 */function (child) {
                                    child.selected = false;
                                }));
                            }
                        }));
                    }
                    if (this.model.secondaryLinks) {
                        this.model.secondaryLinks.forEach(( /**
                         * @param {?} item
                         * @return {?}
                         */function (item) {
                            item.selected = false;
                        }));
                    }
                }
            };
        /**
         * Finds the navigation element by id in the header model
         * @param id of the navigation item
         */
        /**
         * Finds the navigation element by id in the header model
         * @param {?} id of the navigation item
         * @return {?}
         */
        SdsHeaderComponent.prototype.find = /**
         * Finds the navigation element by id in the header model
         * @param {?} id of the navigation item
         * @return {?}
         */
            function (id) {
                /** @type {?} */
                var toReturn = null;
                if (this.model) {
                    if (this.model.home) {
                        if (this.model.home.id === id) {
                            toReturn = this.model.home;
                        }
                    }
                    toReturn = this.findNavigationLinks(id, toReturn);
                    if (this.model.secondaryLinks) {
                        this.model.secondaryLinks.forEach(( /**
                         * @param {?} item
                         * @return {?}
                         */function (item) {
                            if (item.id === id) {
                                toReturn = item;
                            }
                        }));
                    }
                }
                return toReturn;
            };
        /**
         * Searchs the items in the navigation links
         * @param id
         */
        /**
         * Searchs the items in the navigation links
         * @private
         * @param {?} id
         * @param {?} toReturn
         * @return {?}
         */
        SdsHeaderComponent.prototype.findNavigationLinks = /**
         * Searchs the items in the navigation links
         * @private
         * @param {?} id
         * @param {?} toReturn
         * @return {?}
         */
            function (id, toReturn) {
                if (this.model.navigationLinks) {
                    this.model.navigationLinks.forEach(( /**
                     * @param {?} item
                     * @return {?}
                     */function (item) {
                        if (item.id === id) {
                            toReturn = item;
                        }
                        if (item.children) {
                            item.children.forEach(( /**
                             * @param {?} child
                             * @return {?}
                             */function (child) {
                                if (child.id === id) {
                                    toReturn = child;
                                }
                            }));
                        }
                    }));
                }
                return toReturn;
            };
        /**
         * Link clicked and emits the link data into an event
         * @param link
         */
        /**
         * Link clicked and emits the link data into an event
         * @param {?} link
         * @return {?}
         */
        SdsHeaderComponent.prototype.linkClickEvent = /**
         * Link clicked and emits the link data into an event
         * @param {?} link
         * @return {?}
         */
            function (link) {
                this.linkEvent.emit(link);
                return false;
            };
        // When the mobile nav is active, and the close box isn't visible,
        // we know the user's viewport has been resized to be larger.
        // Let's make the page state consistent by deactivating the mobile nav.
        // When the mobile nav is active, and the close box isn't visible,
        // we know the user's viewport has been resized to be larger.
        // Let's make the page state consistent by deactivating the mobile nav.
        /**
         * @param {?} event
         * @return {?}
         */
        SdsHeaderComponent.prototype.onBrowserResize =
            // When the mobile nav is active, and the close box isn't visible,
            // we know the user's viewport has been resized to be larger.
            // Let's make the page state consistent by deactivating the mobile nav.
            /**
             * @param {?} event
             * @return {?}
             */
            function (event) {
                if (this.mobileNavActive &&
                    this.closeNavBtn.nativeElement.getBoundingClientRect().width === 0) {
                    this.mobileNavActive = false;
                }
            };
        /**
         * @return {?}
         */
        SdsHeaderComponent.prototype.openMobileNav = /**
         * @return {?}
         */
            function () {
                this.mobileNavActive = true;
            };
        /**
         * @return {?}
         */
        SdsHeaderComponent.prototype.closeMobileNav = /**
         * @return {?}
         */
            function () {
                this.mobileNavActive = false;
                // The mobile nav was just deactivated, and focus was on the close
                // button, which is no longer visible. We don't want the focus to
                // disappear into the void, so focus on the menu button if it's
                // visible (this may have been what the user was just focused on,
                // if they triggered the mobile nav by mistake).
                this.openNavBtn.nativeElement.focus();
            };
        // The mobile nav was just activated, so focus on the close button,
        // The mobile nav was just activated, so focus on the close button,
        /**
         * @return {?}
         */
        SdsHeaderComponent.prototype.navAnimationEnd =
            // The mobile nav was just activated, so focus on the close button,
            /**
             * @return {?}
             */
            function () {
                this.closeNavBtn.nativeElement.focus();
            };
        SdsHeaderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'sds-header',
                        template: "<sds-top-banner *ngIf=\"showTopBanner\" \n[description]=\"topBannerDescription\"\n></sds-top-banner>\n<div\n  class=\"usa-overlay\"\n  [class.is-visible]=\"mobileNavActive\"\n  (click)=\"closeMobileNav()\"\n></div>\n<header class=\"usa-header usa-header--extended\">\n  <div class=\"usa-navbar\">\n    <div class=\"usa-logo\" id=\"extended-logo\">\n      <ng-container\n        [ngTemplateOutlet]=\"\n          navigationHelper.isLinkInternal(model.home)\n            ? homeLinkRouteTemplate\n            : homeLinkHREFTemplate\n        \"\n        [ngTemplateOutletContext]=\"{ $implicit: model.home }\"\n      ></ng-container>\n    </div>\n    <button #usaNavOpen class=\"usa-menu-btn\" (click)=\"openMobileNav()\">\n      <fa-layers [fixedWidth]=\"true\" size=\"3x\">\n        <fa-icon\n          [icon]=\"['fas', 'square']\"\n          [classes]=\"['text-primary']\"\n        ></fa-icon>\n        <fa-icon\n          [icon]=\"['sds', 'bars']\"\n          [classes]=\"['icon-bars']\"\n          transform=\"shrink-6\"\n        ></fa-icon>\n        <fa-layers-counter\n          *ngIf=\"hasCounter()\"\n          [classes]=\"['icon-layers-counter']\"\n        ></fa-layers-counter>\n      </fa-layers>\n      <span class=\"usa-sr-only\">Menu</span>\n    </button>\n  </div>\n  <nav\n    aria-label=\"Primary navigation\"\n    class=\"usa-nav\"\n    (keydown.esc)=\"closeMobileNav()\"\n    (animationend)=\"navAnimationEnd()\"\n    [class.is-visible]=\"mobileNavActive\"\n    [cdkTrapFocus]=\"mobileNavActive\"\n  >\n    <div class=\"usa-nav__inner\">\n      <button #usaNavClose class=\"usa-nav__close\" (click)=\"closeMobileNav()\">\n        <fa-layers [fixedWidth]=\"true\" size=\"lg\">\n          <fa-icon\n            [icon]=\"['fas', 'circle']\"\n            [inverse]=\"true\"\n            transform=\"grow-2\"\n          ></fa-icon>\n          <fa-icon [icon]=\"['fas', 'times']\" transform=\"shrink-6\"></fa-icon>\n        </fa-layers>\n        <span class=\"usa-sr-only\">Close</span>\n      </button>\n      <ul class=\"usa-nav__primary usa-accordion\">\n        <li\n          *ngFor=\"let link of model.navigationLinks\"\n          class=\"usa-nav__primary-item\"\n        >\n          <ng-container\n            [ngTemplateOutlet]=\"link.route ? linkTemplate : dropDownTemplate\"\n            [ngTemplateOutletContext]=\"{ $implicit: link }\"\n          ></ng-container>\n        </li>\n      </ul>\n      <div class=\"usa-nav__secondary\">\n        <ul class=\"usa-nav__secondary-links\">\n          <li\n            *ngFor=\"let link of model.secondaryLinks\"\n            class=\"usa-nav__secondary-item\"\n          >\n            <ng-container\n              [ngTemplateOutlet]=\"\n                navigationHelper.isLinkInternal(link)\n                  ? secondaryRouteLinkTemplate\n                  : navigationHelper.isLinkExternal(link)\n                  ? secondaryHREFLinkTemplate\n                  : secondaryEVENTLinkTemplate\n              \"\n              [ngTemplateOutletContext]=\"{ $implicit: link }\"\n            ></ng-container>\n          </li>\n        </ul>\n      </div>\n    </div>\n  </nav>\n</header>\n<ng-template #homeLinkRouteTemplate let-home>\n  <a [routerLink]=\"home.route\" title=\"Home\" aria-label=\"Home\">\n    <img class=\"sds-header__logo\" [src]=\"home.logo\" [alt]=\"home.text\" />\n  </a>\n</ng-template>\n\n<ng-template #homeLinkHREFTemplate let-home>\n  <a [attr.href]=\"home.route\" title=\"Home\" aria-label=\"Home\">\n    <img class=\"sds-header__logo\" [src]=\"home.logo\" [alt]=\"home.text\" />\n  </a>\n</ng-template>\n\n<ng-template #secondaryRouteLinkTemplate let-link>\n  <a\n    [attr.id]=\"link.id\"\n    [routerLink]=\"[link.route]\"\n    [attr.class]=\"link.selected ? 'usa-current' : ''\"\n  >\n    <ng-container\n      [ngTemplateOutlet]=\"iconLinkTemplate\"\n      [ngTemplateOutletContext]=\"{ $implicit: link }\"\n    >\n    </ng-container>\n  </a>\n</ng-template>\n\n<ng-template #secondaryHREFLinkTemplate let-link>\n  <a\n    [attr.id]=\"link.id\"\n    [attr.href]=\"[link.route]\"\n    [attr.class]=\"link.selected ? 'usa-current' : ''\"\n  >\n    <ng-container\n      [ngTemplateOutlet]=\"iconLinkTemplate\"\n      [ngTemplateOutletContext]=\"{ $implicit: link }\"\n    >\n    </ng-container>\n  </a>\n</ng-template>\n\n<ng-template #secondaryEVENTLinkTemplate let-link>\n  <a\n    [attr.id]=\"link.id\"\n    (click)=\"linkClickEvent(link)\"\n    href=\"javascript:void(0)\"\n    [attr.class]=\"link.selected ? 'usa-current' : ''\"\n  >\n    <ng-container\n      [ngTemplateOutlet]=\"iconLinkTemplate\"\n      [ngTemplateOutletContext]=\"{ $implicit: link }\"\n    >\n    </ng-container>\n  </a>\n</ng-template>\n\n<ng-template #iconLinkTemplate let-link>\n  <fa-layers [fixedWidth]=\"true\">\n    <fa-icon [icon]=\"[link.imageClassPrefix, link.imageClass]\"></fa-icon>\n    <fa-layers-counter\n      *ngIf=\"link.hasCounter\"\n      [classes]=\"['icon-layers-counter']\"\n    ></fa-layers-counter>\n  </fa-layers>\n  <span class=\"sds-nav__secondary-item-text\">{{ link.text }}</span>\n</ng-template>\n\n<ng-template #linkTemplate let-link>\n  <ng-container\n    [ngTemplateOutlet]=\"\n      navigationHelper.isLinkInternal(link)\n        ? linkRouteTemplate\n        : navigationHelper.isLinkExternal(link)\n        ? linkHREFTemplate\n        : linkEventTemplate\n    \"\n    [ngTemplateOutletContext]=\"{ $implicit: link }\"\n  ></ng-container>\n</ng-template>\n\n<ng-template #linkRouteTemplate let-link>\n  <a\n    [attr.id]=\"link.id\"\n    [attr.class]=\"link.selected ? 'usa-nav__link usa-current' : 'usa-nav__link'\"\n    [routerLink]=\"[link.route]\"\n    ><span>{{ link.text }}</span></a\n  >\n</ng-template>\n\n<ng-template #linkHREFTemplate let-link>\n  <a\n    [attr.id]=\"link.id\"\n    [attr.class]=\"link.selected ? 'usa-nav__link usa-current' : 'usa-nav__link'\"\n    [attr.href]=\"[link.route]\"\n    ><span>{{ link.text }}</span></a\n  >\n</ng-template>\n\n<ng-template #linkEventTemplate let-link>\n  <a\n    [attr.id]=\"link.id\"\n    [attr.class]=\"link.selected ? 'usa-nav__link usa-current' : 'usa-nav__link'\"\n    href=\"javascript:void(0)\"\n    (click)=\"linkClickEvent(link)\"\n    ><span>{{ link.text }}</span></a\n  >\n</ng-template>\n\n<ng-template #dropDownTemplate let-link>\n  <button\n    [attr.id]=\"link.id\"\n    [attr.class]=\"\n      link.selected\n        ? 'usa-accordion__button usa-nav__link usa-current'\n        : 'usa-accordion__button usa-nav__link'\n    \"\n    aria-expanded=\"false\"\n    [attr.aria-controls]=\"removeWhiteSpace(link.text) + '-section'\"\n  >\n    <span>{{ link.text }}</span>\n  </button>\n  <ul\n    [attr.id]=\"removeWhiteSpace(link.text) + '-section'\"\n    class=\"usa-nav__submenu\"\n    hidden\n  >\n    <li *ngFor=\"let childLink of link.children\" class=\"usa-nav__submenu-item\">\n      <ng-container\n        [ngTemplateOutlet]=\"\n          navigationHelper.isLinkInternal(childLink)\n            ? dropDownRouteLinkTemplate\n            : navigationHelper.isLinkExternal(childLink)\n            ? dropDownHREFLinkTemplate\n            : dropDownEVENTLinkTemplate\n        \"\n        [ngTemplateOutletContext]=\"{ $implicit: childLink }\"\n      ></ng-container>\n    </li>\n  </ul>\n</ng-template>\n\n<ng-template #dropDownRouteLinkTemplate let-childLink>\n  <a [routerLink]=\"[childLink.route]\">{{ childLink.text }}</a>\n</ng-template>\n\n<ng-template #dropDownHREFLinkTemplate let-childLink>\n  <a [attr.href]=\"[childLink.route]\">{{ childLink.text }}</a>\n</ng-template>\n\n<ng-template #dropDownEVENTLinkTemplate let-childLink>\n  <a href=\"javascript:void(0)\" (click)=\"linkClickEvent(childLink)\">{{\n    childLink.text\n  }}</a>\n</ng-template>\n",
                        styles: [""]
                    }] }
        ];
        SdsHeaderComponent.propDecorators = {
            openNavBtn: [{ type: core.ViewChild, args: ['usaNavOpen',] }],
            closeNavBtn: [{ type: core.ViewChild, args: ['usaNavClose',] }],
            showTopBanner: [{ type: core.Input }],
            model: [{ type: core.Input }],
            topBannerDescription: [{ type: core.Input }],
            linkEvent: [{ type: core.Output }],
            onBrowserResize: [{ type: core.HostListener, args: ['window:resize', ['$event'],] }]
        };
        return SdsHeaderComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SdsTopBannerComponent = /** @class */ (function () {
        function SdsTopBannerComponent() {
            this.showDetail = false;
            this.description = '';
        }
        /**
         * @return {?}
         */
        SdsTopBannerComponent.prototype.toggleDetails = /**
         * @return {?}
         */
            function () {
                this.showDetail = !this.showDetail;
            };
        /**
         * @return {?}
         */
        SdsTopBannerComponent.prototype.closeDetail = /**
         * @return {?}
         */
            function () {
                if (this.showDetail) {
                    this.showDetail = false;
                }
            };
        SdsTopBannerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'sds-top-banner',
                        template: "<div class=\"usa-banner\">\n  <div class=\"usa-accordion\">\n    <header\n      class=\"usa-banner__header\"\n      [class.sam-banner__header--expanded]=\"showDetail\"\n    >\n      <div class=\"usa-banner__inner\">\n        <div class=\"grid-col-auto\">\n          <span class=\"usa-banner__header-flag\"></span>\n        </div>\n        <div class=\"grid-col-fill tablet:grid-col-auto\">\n          <p class=\"usa-banner__header-text\">\n            An official website of the United States government\n          </p>\n          <p class=\"usa-banner__header-action\" aria-hidden=\"true\">\n            Here\u2019s how you know\n          </p>\n        </div>\n        <button\n          class=\"usa-accordion__button usa-banner__button\"\n          (click)=\"toggleDetails()\"\n          (blur)=\"closeDetail()\"\n          [attr.aria-expanded]=\"showDetail\"\n          aria-controls=\"gov-banner\"\n        >\n          <span class=\"usa-banner__button-text\">Here\u2019s how you know</span>\n        </button>\n        <div class=\"usa-banner__header-description\">\n          <em>{{ description }}</em>\n        </div>\n      </div>\n    </header>\n    <div\n      class=\"usa-banner__content usa-accordion__content\"\n      id=\"gov-banner\"\n      [hidden]=\"!showDetail\"\n    >\n      <div class=\"grid-row grid-gap-lg\">\n        <div class=\"usa-banner__guidance tablet:grid-col-6\">\n          <span class=\"usa-banner__icon usa-media-block__img\"></span>\n          <div class=\"usa-media-block__body\">\n            <p>\n              <strong>The .gov means it\u2019s official.</strong> <br />\n              Federal government websites often end in .gov or .mil. Before\n              sharing sensitive information, make sure you\u2019re on a federal\n              government site.\n            </p>\n          </div>\n        </div>\n        <div class=\"usa-banner__guidance tablet:grid-col-6\">\n          <span class=\"usa-banner__icon usa-media-block__img\"></span>\n          <div class=\"usa-media-block__body\">\n            <p>\n              <strong>The site is secure.</strong> <br />\n              The <strong>https://</strong> ensures that you are connecting to\n              the official website and that any information you provide is\n              encrypted and transmitted securely.\n            </p>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n",
                        styles: [""]
                    }] }
        ];
        SdsTopBannerComponent.propDecorators = {
            description: [{ type: core.Input }]
        };
        return SdsTopBannerComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SdsHeaderModule = /** @class */ (function () {
        function SdsHeaderModule() {
        }
        SdsHeaderModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule, forms.FormsModule, router.RouterModule, angularFontawesome.FontAwesomeModule, a11y.A11yModule
                        ],
                        declarations: [SdsHeaderComponent, SdsTopBannerComponent],
                        exports: [SdsHeaderComponent]
                    },] }
        ];
        return SdsHeaderModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SdsFooterComponent = /** @class */ (function () {
        function SdsFooterComponent() {
            /**
             * Navigation helper
             */
            this.navigationHelper = new NavigationHelper();
            this.isCollapsedContent = true;
            /**
             * event for event based
             */
            this.linkEvent = new core.EventEmitter();
        }
        /**
         * Link clicked and emits the link data into an event
         * @param link
         */
        /**
         * Link clicked and emits the link data into an event
         * @param {?} link
         * @return {?}
         */
        SdsFooterComponent.prototype.linkClickEvent = /**
         * Link clicked and emits the link data into an event
         * @param {?} link
         * @return {?}
         */
            function (link) {
                this.linkEvent.emit(link);
                return false;
            };
        SdsFooterComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'sds-footer',
                        template: "<footer class=\"usa-footer usa-footer--big\" role=\"contentinfo\">\n\n  <div class=\"sds-feedback\">\n    <button type=\"button\" class=\"sds-feedback__button\" [attr.aria-expanded]=\"!isCollapsedContent\" aria-controls=\"collapseID\" (click)=\"isCollapsedContent = !isCollapsedContent\">\n      <fa-layers [fixedWidth]=\"true\" size=\"2x\">\n        <fa-icon [icon]=\"['fas', 'circle']\" [sdsCollapse]=\"isCollapsedContent\" class=\"text-base-light margin-auto\"></fa-icon>\n        <fa-icon [icon]=\"['sds', 'arrow-up']\" [sdsCollapse]=\"isCollapsedContent\" transform=\"shrink-6\"></fa-icon>\n        <fa-icon [icon]=\"['fas', 'circle']\" [sdsCollapse]=\"!isCollapsedContent\" class=\"text-primary margin-auto\"></fa-icon>\n        <fa-icon [icon]=\"['sds', 'arrow-down']\" [sdsCollapse]=\"!isCollapsedContent\" transform=\"shrink-6\"></fa-icon>\n      </fa-layers>\n      <span class=\"sds-feedback__title\">Feedback</span>\n    </button>\n    <div id=\"collapseID\" [sdsCollapse]=\"isCollapsedContent\" class=\"sds-feedback__response\">\n      <div class=\"tablet:width-tablet-lg padding-4 margin-auto\">\n        <span class=\"sds-feedback__response-title\">One Question </span>\n        <span class=\"sds-feedback__response-title-thin\"> Survey</span>\n        <p class=\"sds-feedback__response-text\">What changes or improvements would you suggest?</p>\n        <input class=\"sds-feedback__input\" type=\"text\">\n        <button class=\"usa-button usa-button--secondary margin-y-2 float-right\">Submit</button>\n      </div>\n    </div>\n  </div>\n\n  <div class=\"usa-footer__primary-section\">\n    <div class=\"grid-container\">\n      <div class=\"grid-row grid-gap\">\n        <div class=\"mobile-lg:grid-col-12 tablet:grid-col-4\">\n          <div\n            class=\"usa-footer__logo grid-row mobile-lg:grid-gap-1 margin-top-3\"\n          >\n            <div\n              class=\"mobile-lg:grid-col-3 mobile-lg:grid-offset-3 tablet:grid-offset-none tablet:grid-col-auto\"\n            >\n              <img\n                *ngIf=\"model.footerLogo\"\n                class=\"usa-footer__logo-img\"\n                [attr.src]=\"model.footerLogo.imageSourcePath\"\n                [attr.alt]=\"model.footerLogo.imageAltText\"\n              />\n              <a\n                *ngIf=\"!model.footerLogo\"\n                class=\"usa-footer__logo-text\"\n                target=\"_blank\"\n                href=\"http://gsa.gov\"\n              >\n                GSA.gov\n              </a>\n            </div>\n            <div class=\"mobile-lg:grid-col-4 tablet:grid-col-auto\">\n              <span class=\"usa-footer__logo-heading\">\n                {{\n                  model.footerLogo?.text || 'General Services Administration'\n                }}\n              </span>\n            </div>\n          </div>\n        </div>\n        <div class=\"mobile-lg:grid-col-12 tablet:grid-col-8\">\n          <nav class=\"usa-footer__nav\">\n            <div class=\"grid-row grid-gap-4\">\n              <div\n                class=\"mobile-lg:grid-col-12 desktop:grid-col-4\"\n                *ngFor=\"let section of model.linkSections\"\n              >\n                <section\n                  class=\"usa-footer__primary-content usa-footer__primary-content--collapsible\"\n                >\n                  <span class=\"usa-footer__primary-link\">{{\n                    section.text\n                  }}</span>\n                  <ul class=\"usa-list usa-list--unstyled\">\n                    <li\n                      class=\"usa-footer__secondary-link\"\n                      *ngFor=\"let link of section.links\"\n                    >\n                      <ng-container\n                        [ngTemplateOutlet]=\"\n                          navigationHelper.isLinkInternal(link)\n                            ? footerRouteLinkTemplate\n                            : navigationHelper.isLinkExternal(link)\n                            ? footerHREFLinkTemplate\n                            : footerEVENTLinkTemplate\n                        \"\n                        [ngTemplateOutletContext]=\"{ $implicit: link }\"\n                      ></ng-container>\n                    </li>\n                  </ul>\n                </section>\n              </div>\n            </div>\n          </nav>\n        </div>\n      </div>\n    </div>\n  </div>\n  <div class=\"usa-footer__secondary-section\">\n    <div class=\"grid-container\">\n      <div class=\"grid-row\">\n        <div class=\"grid-col-12\">\n          <p class=\"font-body-2xs line-height-sans-4 margin-top-0\">\n            This is a U.S. General Services Administration Federal Government\n            computer system that is\n            <strong>\"FOR OFFICIAL USE ONLY.\"</strong> This system is subject to\n            monitoring. Individuals found performing unauthorized activities are\n            subject to disciplinary action including criminal prosecution.\n          </p>\n        </div>\n      </div>\n    </div>\n  </div>\n</footer>\n\n<ng-template #footerRouteLinkTemplate let-link>\n  <a [routerLink]=\"[link.route]\">{{ link.text }}</a>\n</ng-template>\n\n<ng-template #footerHREFLinkTemplate let-link>\n  <a [attr.href]=\"[link.route]\">{{ link.text }}</a>\n</ng-template>\n\n<ng-template #footerEVENTLinkTemplate let-link>\n  <a href=\"javascript:void(0)\" (click)=\"linkClickEvent(link)\">{{\n    link.text\n  }}</a>\n</ng-template>\n",
                        styles: [""]
                    }] }
        ];
        SdsFooterComponent.propDecorators = {
            model: [{ type: core.Input }],
            isCollapsedContent: [{ type: core.Input }],
            linkEvent: [{ type: core.Output }]
        };
        return SdsFooterComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var CollapseDirective = /** @class */ (function () {
        function CollapseDirective() {
            this.collapsed = true;
        }
        CollapseDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[sdsCollapse]',
                        exportAs: 'sdsCollapse',
                        host: { '[class.display-none]': 'collapsed' }
                    },] }
        ];
        /** @nocollapse */
        CollapseDirective.ctorParameters = function () { return []; };
        CollapseDirective.propDecorators = {
            collapsed: [{ type: core.Input, args: ['sdsCollapse',] }]
        };
        return CollapseDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SdsCollapseModule = /** @class */ (function () {
        function SdsCollapseModule() {
        }
        SdsCollapseModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [CollapseDirective],
                        imports: [
                            common.CommonModule
                        ],
                        exports: [CollapseDirective]
                    },] }
        ];
        return SdsCollapseModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SdsFooterModule = /** @class */ (function () {
        function SdsFooterModule() {
        }
        SdsFooterModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule, forms.FormsModule, router.RouterModule, SdsCollapseModule, angularFontawesome.FontAwesomeModule
                        ],
                        declarations: [SdsFooterComponent],
                        exports: [SdsFooterComponent]
                    },] }
        ];
        return SdsFooterModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var PaginationModel = /** @class */ (function () {
        function PaginationModel() {
        }
        return PaginationModel;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var PaginationComponent = /** @class */ (function () {
        function PaginationComponent(change) {
            this.change = change;
            /**
             * Output of the page model object
             */
            this.pageChange = new core.EventEmitter();
            /**
             * Pagination model
             */
            this.page = new PaginationModel();
            /**
             * debounce time for current page input
             */
            this.debounceTime = 500;
            /**
             * Drop down options for page size
             */
            this.options = [
                { label: '25', value: 25 },
                { label: '50', value: 50 },
                { label: '100', value: 100 }
            ];
        }
        /**
         * @return {?}
         */
        PaginationComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.maintainPreviousValue();
            };
        /**
         * Stores the previous number. Used when focus out if field empty
         */
        /**
         * Stores the previous number. Used when focus out if field empty
         * @private
         * @return {?}
         */
        PaginationComponent.prototype.maintainPreviousValue = /**
         * Stores the previous number. Used when focus out if field empty
         * @private
         * @return {?}
         */
            function () {
                this.previousNumber = this.page.pageNumber.valueOf();
            };
        /**
         * previous page lowers page number by one within range
         */
        /**
         * previous page lowers page number by one within range
         * @return {?}
         */
        PaginationComponent.prototype.previousPage = /**
         * previous page lowers page number by one within range
         * @return {?}
         */
            function () {
                if (this.page.pageNumber > 1) {
                    this.page.pageNumber--;
                    this.maintainPreviousValue();
                    this.pageChange.emit(this.page);
                }
            };
        /**
         * next page increase page number by one within range
         */
        /**
         * next page increase page number by one within range
         * @return {?}
         */
        PaginationComponent.prototype.nextPage = /**
         * next page increase page number by one within range
         * @return {?}
         */
            function () {
                if (this.page.pageNumber < this.page.totalPages) {
                    this.page.pageNumber++;
                    this.maintainPreviousValue();
                    this.pageChange.emit(this.page);
                }
            };
        /**
         * current page changes sets new value if within range
         * @param newValue
         */
        /**
         * current page changes sets new value if within range
         * @param {?=} newValue
         * @return {?}
         */
        PaginationComponent.prototype.valuechange = /**
         * current page changes sets new value if within range
         * @param {?=} newValue
         * @return {?}
         */
            function (newValue) {
                var _this = this;
                window.clearTimeout(this.timeoutNumber);
                this.timeoutNumber = window.setTimeout(( /**
                 * @return {?}
                 */function () {
                    if (newValue || newValue === 0) {
                        newValue = _this.handleInputOutsideBounds(newValue);
                        if (newValue >= 1 && newValue <= _this.page.totalPages) {
                            _this.page.pageNumber = newValue;
                            _this.maintainPreviousValue();
                            _this.pageChange.emit(_this.page);
                            _this.change.detectChanges();
                        }
                    }
                    else {
                        if (_this.page.pageNumber) {
                            _this.maintainPreviousValue();
                        }
                    }
                }), this.debounceTime);
            };
        /**
         * adjusts the value if not within the page limit above or below
         * @param newValue handles
         */
        /**
         * adjusts the value if not within the page limit above or below
         * @private
         * @param {?=} newValue handles
         * @return {?}
         */
        PaginationComponent.prototype.handleInputOutsideBounds = /**
         * adjusts the value if not within the page limit above or below
         * @private
         * @param {?=} newValue handles
         * @return {?}
         */
            function (newValue) {
                if (newValue < 1) {
                    newValue = 1;
                    this.currentPageField.nativeElement.value = newValue;
                }
                else if (newValue > this.page.totalPages) {
                    newValue = this.page.totalPages;
                    this.currentPageField.nativeElement.value = newValue;
                }
                return newValue;
            };
        /**
         * current page focus out will replace with previous valid if empty
         */
        /**
         * current page focus out will replace with previous valid if empty
         * @return {?}
         */
        PaginationComponent.prototype.currentPageFocusOut = /**
         * current page focus out will replace with previous valid if empty
         * @return {?}
         */
            function () {
                if (this.currentPageField.nativeElement.value === '') {
                    this.currentPageField.nativeElement.value = this.page.pageNumber = this.previousNumber;
                    this.change.detectChanges();
                }
            };
        /**
         * page size selection change
         */
        /**
         * page size selection change
         * @return {?}
         */
        PaginationComponent.prototype.onSelectChange = /**
         * page size selection change
         * @return {?}
         */
            function () {
                this.page.pageNumber = 1;
                this.pageChange.emit(this.page);
            };
        PaginationComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'sds-pagination',
                        template: "<div class=\"sds-pagination\">\n  <div class=\"sds-pagination__controls\">\n    <button [attr.id]=\"paginationConfiguration.id +'-previousPage'\" (click)=\"previousPage()\">Previous Page</button>\n    <label class=\"usa-label font-sans-3xs margin-top-1 text-italic text-base usa-sr-only\"\n      [attr.for]=\"paginationConfiguration.id + '-currentPage'\">Current Page</label>\n    <input [attr.id]=\"paginationConfiguration.id +'-currentPage'\"\n      class=\"usa-input height-3 width-4 line-height-05 font-sans-3xs text-center border-base-light\" #currentPage\n      (ngModelChange)=\"valuechange($event)\" [(ngModel)]=\"page.pageNumber\" type=\"number\" min=\"1\"\n      [(attr.max)]=\"page.totalPages\" (focusout)=\"currentPageFocusOut()\" aria-label=\"current page\" />\n    <span class=\"sds-pagination__total\">\n      of <strong>{{ page.totalPages }}</strong>\n    </span>\n    <button [attr.id]=\"paginationConfiguration.id +'-nextPage'\" (click)=\"nextPage()\">Next Page</button>\n  </div>\n  <div class=\"sds-pagination__results\">\n    <label class=\"usa-label font-sans-3xs text-italic text-base\"\n      [attr.for]=\"paginationConfiguration.id + '-select'\">Results per page</label>\n    <select class=\"usa-select usa-select--small border-base-light\" [attr.id]=\"paginationConfiguration.id + '-select'\"\n      (change)=\"onSelectChange()\" [(ngModel)]=\"page.pageSize\">\n      <option *ngFor=\"let item of options\" [ngValue]=\"item.value\">\n        {{ item.label }}\n      </option>\n    </select>\n  </div>\n</div>\n",
                        styles: ["input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}input[type=number]{-moz-appearance:textfield}"]
                    }] }
        ];
        /** @nocollapse */
        PaginationComponent.ctorParameters = function () {
            return [
                { type: core.ChangeDetectorRef }
            ];
        };
        PaginationComponent.propDecorators = {
            currentPageField: [{ type: core.ViewChild, args: ['currentPage',] }],
            pageChange: [{ type: core.Output }],
            page: [{ type: core.Input }],
            paginationConfiguration: [{ type: core.Input }]
        };
        return PaginationComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var PaginationModule = /** @class */ (function () {
        function PaginationModule() {
        }
        PaginationModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [PaginationComponent],
                        imports: [
                            common.CommonModule, forms.FormsModule
                        ],
                        exports: [PaginationComponent]
                    },] }
        ];
        return PaginationModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SDSSelectedItemModel = /** @class */ (function () {
        function SDSSelectedItemModel(items) {
            this.items = items ? __spread(items) : [];
        }
        return SDSSelectedItemModel;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SDSSelectedItemModelHelper = /** @class */ (function () {
        function SDSSelectedItemModelHelper() {
        }
        /**
          *  adds an item to the collection
          * if selected mode is single it removes any existing items
          * also checks to see if that item already exists
          * keyfield is used to determine uniqueness of the item added
          * @param itemToAdd
          * @param keyField
          * @param selectionMode
          * @param items
          */
        /**
         *  adds an item to the collection
         * if selected mode is single it removes any existing items
         * also checks to see if that item already exists
         * keyfield is used to determine uniqueness of the item added
         * @param {?} itemToAdd
         * @param {?} keyField
         * @param {?} selectionMode
         * @param {?} items
         * @return {?}
         */
        SDSSelectedItemModelHelper.addItem = /**
         *  adds an item to the collection
         * if selected mode is single it removes any existing items
         * also checks to see if that item already exists
         * keyfield is used to determine uniqueness of the item added
         * @param {?} itemToAdd
         * @param {?} keyField
         * @param {?} selectionMode
         * @param {?} items
         * @return {?}
         */
            function (itemToAdd, keyField, selectionMode, items) {
                if (!SDSSelectedItemModelHelper.contatinsItem(itemToAdd[keyField], keyField, items)) {
                    if (selectionMode === SelectionMode.SINGLE) {
                        SDSSelectedItemModelHelper.clearItems(items);
                    }
                    items.push(itemToAdd);
                }
            };
        /**
         * adds an array of items to the list and will not add duplicate items
         * keyfield is used to determine uniqueness of the item added
         * @param toAddItems
         * @param keyField
         * @param selectionMode
         * @param items
         */
        /**
         * adds an array of items to the list and will not add duplicate items
         * keyfield is used to determine uniqueness of the item added
         * @param {?} toAddItems
         * @param {?} keyField
         * @param {?} selectionMode
         * @param {?} items
         * @return {?}
         */
        SDSSelectedItemModelHelper.addItems = /**
         * adds an array of items to the list and will not add duplicate items
         * keyfield is used to determine uniqueness of the item added
         * @param {?} toAddItems
         * @param {?} keyField
         * @param {?} selectionMode
         * @param {?} items
         * @return {?}
         */
            function (toAddItems, keyField, selectionMode, items) {
                for (var i = 0; i < toAddItems.length; i++) {
                    SDSSelectedItemModelHelper.addItem(toAddItems[i], keyField, selectionMode, items);
                }
            };
        /**
         * removes the item from the list
         * keyfield is used to determine uniqueness of the item added
         * @param item
         * @param keyField
         * @param items
         */
        /**
         * removes the item from the list
         * keyfield is used to determine uniqueness of the item added
         * @param {?} item
         * @param {?} keyField
         * @param {?} items
         * @return {?}
         */
        SDSSelectedItemModelHelper.removeItem = /**
         * removes the item from the list
         * keyfield is used to determine uniqueness of the item added
         * @param {?} item
         * @param {?} keyField
         * @param {?} items
         * @return {?}
         */
            function (item, keyField, items) {
                if (SDSSelectedItemModelHelper.contatinsItem(item[keyField], keyField, items)) {
                    items.splice(items.indexOf(item), 1);
                }
            };
        /**
         * checks to see if a particular item exists by the provied key
         * keyfield is used to determine uniqueness of the item added
         * @param key
         * @param keyField
         * @param items
         */
        /**
         * checks to see if a particular item exists by the provied key
         * keyfield is used to determine uniqueness of the item added
         * @param {?} key
         * @param {?} keyField
         * @param {?} items
         * @return {?}
         */
        SDSSelectedItemModelHelper.contatinsItem = /**
         * checks to see if a particular item exists by the provied key
         * keyfield is used to determine uniqueness of the item added
         * @param {?} key
         * @param {?} keyField
         * @param {?} items
         * @return {?}
         */
            function (key, keyField, items) {
                /** @type {?} */
                var item = items.find(( /**
                 * @param {?} o
                 * @return {?}
                 */function (o) { return o[keyField] === key; }));
                return item !== null && item !== undefined;
            };
        /**
         * Clears the list of items
         * @param items
         */
        /**
         * Clears the list of items
         * @param {?} items
         * @return {?}
         */
        SDSSelectedItemModelHelper.clearItems = /**
         * Clears the list of items
         * @param {?} items
         * @return {?}
         */
            function (items) {
                while (items.length > 0) {
                    items.pop();
                }
            };
        /**
         * updates an array of items to the list and will not add duplicate items
         * keyfield is used to determine uniqueness of the item added
         * @param selectedItems
         * @param keyField
         * @param selectionMode
         * @param items
         */
        /**
         * updates an array of items to the list and will not add duplicate items
         * keyfield is used to determine uniqueness of the item added
         * @param {?} selectedItems
         * @param {?} keyField
         * @param {?} selectionMode
         * @param {?} items
         * @return {?}
         */
        SDSSelectedItemModelHelper.replaceItems = /**
         * updates an array of items to the list and will not add duplicate items
         * keyfield is used to determine uniqueness of the item added
         * @param {?} selectedItems
         * @param {?} keyField
         * @param {?} selectionMode
         * @param {?} items
         * @return {?}
         */
            function (selectedItems, keyField, selectionMode, items) {
                //Clears Old List
                SDSSelectedItemModelHelper.clearItems(items);
                //Adds new List
                SDSSelectedItemModelHelper.addItems(selectedItems, keyField, selectionMode, items);
            };
        return SDSSelectedItemModelHelper;
    }());
    /** @enum {number} */
    var SelectionMode = {
        SINGLE: 0, MULTIPLE: 1,
    };
    SelectionMode[SelectionMode.SINGLE] = 'SINGLE';
    SelectionMode[SelectionMode.MULTIPLE] = 'MULTIPLE';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var Autocomplete_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(( /**
         * @return {?}
         */function () { return SDSAutocompleteComponent; })),
        multi: true
    };
    var SDSAutocompleteComponent = /** @class */ (function () {
        function SDSAutocompleteComponent(cd) {
            this.cd = cd;
            /**
             * Stored Event for ControlValueAccessor
             */
            this.onTouched = ( /**
             * @return {?}
             */function () { });
            /**
             * Stored Event for ControlValueAccessor
             */
            this.onChange = ( /**
             * @param {?} _
             * @return {?}
             */function (_) { });
        }
        // ControlValueAccessor (and Formly) is trying to update the value of the FormControl (our custom component) programatically
        // If there is a value we will just overwrite items
        // If there is no value we reset the items array to be empty
        // ControlValueAccessor (and Formly) is trying to update the value of the FormControl (our custom component) programatically
        // If there is a value we will just overwrite items
        // If there is no value we reset the items array to be empty
        /**
         * @param {?} value
         * @return {?}
         */
        SDSAutocompleteComponent.prototype.writeValue =
            // ControlValueAccessor (and Formly) is trying to update the value of the FormControl (our custom component) programatically
            // If there is a value we will just overwrite items
            // If there is no value we reset the items array to be empty
            /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value instanceof SDSSelectedItemModel && value.items && value.items.length && this.model.items !== value.items) {
                    this.model.items = __spread(value.items);
                    this.cd.markForCheck();
                }
                else if (value && value.length && this.model.items !== value) {
                    this.model.items = value;
                    this.cd.markForCheck();
                }
                else {
                    if (!this.model || !(this.model instanceof SDSSelectedItemModel)) {
                        this.model = new SDSSelectedItemModel();
                    }
                    this.model.items = value && value.items ? value.items : [];
                    this.cd.markForCheck();
                }
            };
        // Method that is fired when the child component event notifies us that the items array has been modified within the child component
        // Method that is fired when the child component event notifies us that the items array has been modified within the child component
        /**
         * @param {?} $event
         * @return {?}
         */
        SDSAutocompleteComponent.prototype.updateItems =
            // Method that is fired when the child component event notifies us that the items array has been modified within the child component
            /**
             * @param {?} $event
             * @return {?}
             */
            function ($event) {
                this.updateModel();
            };
        // Helper method that gets a new instance of the model and notifies ControlValueAccessor that we have a new model for this FormControl (our custom component)
        // Helper method that gets a new instance of the model and notifies ControlValueAccessor that we have a new model for this FormControl (our custom component)
        /**
         * @return {?}
         */
        SDSAutocompleteComponent.prototype.updateModel =
            // Helper method that gets a new instance of the model and notifies ControlValueAccessor that we have a new model for this FormControl (our custom component)
            /**
             * @return {?}
             */
            function () {
                /** @type {?} */
                var model = this.getModel();
                this.onChange(model);
            };
        // Helper method to return a new instance of an array that contains our items
        // Helper method to return a new instance of an array that contains our items
        /**
         * @return {?}
         */
        SDSAutocompleteComponent.prototype.getModel =
            // Helper method to return a new instance of an array that contains our items
            /**
             * @return {?}
             */
            function () {
                return __spread(this.model.items);
            };
        // ControlValueAccessor hook that lets us call this._onChange(var) to let the form know our variable has changed (in this case model)
        // ControlValueAccessor hook that lets us call this._onChange(var) to let the form know our variable has changed (in this case model)
        /**
         * @param {?} fn
         * @return {?}
         */
        SDSAutocompleteComponent.prototype.registerOnChange =
            // ControlValueAccessor hook that lets us call this._onChange(var) to let the form know our variable has changed (in this case model)
            /**
             * @param {?} fn
             * @return {?}
             */
            function (fn) {
                this.onChange = fn;
            };
        // ControlValueAccessor hook (not used)
        // ControlValueAccessor hook (not used)
        /**
         * @param {?} fn
         * @return {?}
         */
        SDSAutocompleteComponent.prototype.registerOnTouched =
            // ControlValueAccessor hook (not used)
            /**
             * @param {?} fn
             * @return {?}
             */
            function (fn) {
                this.onTouched = fn;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        SDSAutocompleteComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        /**
         * @return {?}
         */
        SDSAutocompleteComponent.prototype.isSingleMode = /**
         * @return {?}
         */
            function () {
                if (this.configuration) {
                    return this.configuration.selectionMode === SelectionMode.SINGLE;
                }
                else {
                    return false;
                }
            };
        SDSAutocompleteComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'sds-autocomplete',
                        template: "<sds-search-autocomplete [disabled]=\"disabled\" (ngModelChange)=\"updateItems($event)\" #autocomplete\n    [service]=\"service\" [(ngModel)]=\"model\" [configuration]=\"configuration\" [itemTemplate]=\"suggestionTemplate\">\n</sds-search-autocomplete>\n<sds-selected-result (ngModelChange)=\"updateItems($event)\" [disabled]=\"disabled\" *ngIf=\"!isSingleMode()\"\n    [(ngModel)]=\"model\" [configuration]=\"configuration\" [itemTemplate]=\"selectedItemTemplate\"></sds-selected-result>\n",
                        providers: [Autocomplete_VALUE_ACCESSOR],
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        SDSAutocompleteComponent.ctorParameters = function () {
            return [
                { type: core.ChangeDetectorRef }
            ];
        };
        SDSAutocompleteComponent.propDecorators = {
            suggestionTemplate: [{ type: core.Input }],
            selectedItemTemplate: [{ type: core.Input }],
            configuration: [{ type: core.Input }],
            service: [{ type: core.Input }],
            onTouched: [{ type: core.HostListener, args: ['focusout',] }]
        };
        return SDSAutocompleteComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var SDS_SelectedResult_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(( /**
         * @return {?}
         */function () { return SDSSelectedResultComponent; })),
        multi: true
    };
    var SDSSelectedResultComponent = /** @class */ (function () {
        function SDSSelectedResultComponent() {
            /**
             * Stored Event for ControlValueAccessor
             */
            this.onTouchedCallback = ( /**
             * @return {?}
             */function () { return null; });
            /**
             * Stored Event for ControlValueAccessor
             */
            this.propogateChange = ( /**
             * @param {?} _
             * @return {?}
             */function (_) { return null; });
        }
        /**
         * Removes item from the model
         * @param item
         */
        /**
         * Removes item from the model
         * @param {?} item
         * @return {?}
         */
        SDSSelectedResultComponent.prototype.removeItem = /**
         * Removes item from the model
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (!this.disabled) {
                    SDSSelectedItemModelHelper.removeItem(item, this.configuration.primaryKeyField, this.model.items);
                    this.propogateChange(this.model);
                    this.onTouchedCallback();
                }
            };
        /**
         * @param {?} obj
         * @return {?}
         */
        SDSSelectedResultComponent.prototype.writeValue = /**
         * @param {?} obj
         * @return {?}
         */
            function (obj) {
                if (obj instanceof SDSSelectedItemModel) {
                    this.model = ( /** @type {?} */(obj));
                }
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        SDSSelectedResultComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.propogateChange = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        SDSSelectedResultComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onTouchedCallback = fn;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        SDSSelectedResultComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        /**
         * Gets the string value from the specifed properties of an object
         * @param object
         * @param propertyFields comma seperated list with periods depth of object
         */
        /**
         * Gets the string value from the specifed properties of an object
         * @param {?} object
         * @param {?} propertyFields comma seperated list with periods depth of object
         * @return {?}
         */
        SDSSelectedResultComponent.prototype.getObjectValue = /**
         * Gets the string value from the specifed properties of an object
         * @param {?} object
         * @param {?} propertyFields comma seperated list with periods depth of object
         * @return {?}
         */
            function (object, propertyFields) {
                /** @type {?} */
                var value = '';
                /** @type {?} */
                var current = object;
                /** @type {?} */
                var fieldSplit = propertyFields.split(',');
                for (var i = 0; i < fieldSplit.length; i++) {
                    /** @type {?} */
                    var fieldValue = fieldSplit[i];
                    /** @type {?} */
                    var fieldPartSplit = fieldValue.split('.');
                    for (var j = 0; j < fieldPartSplit.length; j++) {
                        /** @type {?} */
                        var fieldCheckValue = fieldPartSplit[j];
                        if (current) {
                            current = current[fieldCheckValue];
                        }
                    }
                    if (current) {
                        value += current.toString() + ' ';
                    }
                    current = object;
                }
                return value.trim();
            };
        SDSSelectedResultComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'sds-selected-result',
                        template: "<ul  *ngIf=\"model\" [attr.aria-label]=\"configuration.labelText +' results'\" class=\"usa-list usa-list--unstyled sds-autocomplete-selected\" aria-relevant=\"additions\" role=\"listbox\" aria-live=\"polite\">\n    <li role=\"option\" *ngFor=\"let result of model.items; let i = index\">\n        <div [attr.class]=\" disabled ? 'sds-tag sds-tag--chip sds-autocomplete-selected__item sds-autocomplete-selected__item--disabled' :'sds-tag sds-tag--chip sds-autocomplete-selected__item'\">\n            <ng-container *ngIf=\"itemTemplate\" [ngTemplateOutlet]=\"itemTemplate\" [ngTemplateOutletContext]=\"{$implicit:result}\">\n            </ng-container>\n            <ng-container *ngIf=\"!itemTemplate\">\n                <span class=\"display-block text-semibold\"> {{ getObjectValue(result, configuration.primaryTextField) }}\n                </span>\n                <ng-container *ngIf=\"configuration.secondaryTextField && result[configuration.secondaryTextField] \">\n                    {{ result[configuration.secondaryTextField] }}\n                </ng-container>\n            </ng-container>\n            <button [attr.aria-label]=\"'Remove Item ' + getObjectValue(result, configuration.primaryTextField)\" [class.text-base]=\"disabled\" aria-hidden=\"false\" class=\"sds-tag__close  position-absolute right-1 top-2px\" (click)=\"removeItem(result)\" (keyup.enter)=\"removeItem(result)\">\n        <fa-icon [icon]=\"['fas', 'times']\" size=\"sm\"></fa-icon>\n      </button>\n        </div>\n    </li>\n</ul>",
                        providers: [SDS_SelectedResult_VALUE_ACCESSOR],
                        styles: [""]
                    }] }
        ];
        SDSSelectedResultComponent.propDecorators = {
            itemTemplate: [{ type: core.Input }],
            configuration: [{ type: core.Input }],
            disabled: [{ type: core.Input }]
        };
        return SDSSelectedResultComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SdsSelectedResultsModule = /** @class */ (function () {
        function SdsSelectedResultsModule() {
        }
        SdsSelectedResultsModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, forms.FormsModule, router.RouterModule, angularFontawesome.FontAwesomeModule],
                        declarations: [SDSSelectedResultComponent],
                        exports: [SDSSelectedResultComponent]
                    },] }
        ];
        return SdsSelectedResultsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var KeyHelper = /** @class */ (function () {
        function KeyHelper() {
            var keys = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                keys[_i] = arguments[_i];
            }
            this._allowedKeys = [];
            this._currentlySupported = [
                'enter', 'up', 'down', 'left', 'right', 'tab', 'esc', 'space',
                'shift', 'backspace', '1', '2', '3', '4', '5', '6', '7', '8',
                '9', '0', 'delete'
            ];
            this._setAllowedKeys.apply(this, __spread(keys));
        }
        /**
         * @param {?} event
         * @return {?}
         */
        KeyHelper.prototype.isAllowed = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                /** @type {?} */
                var val = this._allowedKeys
                    .reduce(( /**
             * @param {?} val
             * @param {?} key
             * @return {?}
             */function (val, key) {
                    return KeyHelper.is(key, event) || val;
                }), false);
                return val;
            };
        /**
         * @private
         * @param {...?} keys
         * @return {?}
         */
        KeyHelper.prototype._setAllowedKeys = /**
         * @private
         * @param {...?} keys
         * @return {?}
         */
            function () {
                var _this = this;
                var keys = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    keys[_i] = arguments[_i];
                }
                keys.forEach(( /**
                 * @param {?} key
                 * @return {?}
                 */function (key) {
                    if (_this._currentlySupported.indexOf(key) !== -1) {
                        _this._allowedKeys.push(key);
                    }
                    else {
                        /** @type {?} */
                        var ok = _this._allowedToString();
                        /** @type {?} */
                        var msg = "Only supports " + ok + " at this time";
                        throw new TypeError(msg);
                    }
                }));
            };
        /**
         * @private
         * @return {?}
         */
        KeyHelper.prototype._allowedToString = /**
         * @private
         * @return {?}
         */
            function () {
                return this._allowedKeys.join(', ');
            };
        /**
         * @param {?} event
         * @return {?}
         */
        KeyHelper.getKeyCode = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (!event) {
                    return undefined;
                }
                else if (event.key) {
                    return event.key;
                }
                else if (event.code) {
                    return event.code;
                }
                else if (event.keyIdentifier) {
                    return event.keyIdentifier;
                }
                else {
                    return undefined;
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        KeyHelper.getNumberFromKey = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                /** @type {?} */
                var tests = [
                    KeyHelper._zero, KeyHelper._one, KeyHelper._two,
                    KeyHelper._three, KeyHelper._four, KeyHelper._five,
                    KeyHelper._six, KeyHelper._seven, KeyHelper._eight,
                    KeyHelper._nine
                ];
                return tests.reduce(( /**
                 * @param {?} val
                 * @param {?} test
                 * @return {?}
                 */function (val, test) {
                    return val !== undefined
                        ? val
                        : test(event);
                }), undefined);
            };
        /**
         * @param {?} validKeyParam
         * @param {?} event
         * @return {?}
         */
        KeyHelper.is = /**
         * @param {?} validKeyParam
         * @param {?} event
         * @return {?}
         */
            function (validKeyParam, event) {
                /** @type {?} */
                var lowercased = validKeyParam.toLowerCase();
                switch (lowercased) {
                    case 'enter':
                        return this._isEnter(event);
                    case 'up':
                        return this._isArrowUp(event);
                    case 'down':
                        return this._isArrowDown(event);
                    case 'left':
                        return this._isArrowLeft(event);
                    case 'right':
                        return this._isArrowRight(event);
                    case 'tab':
                        return this._isTab(event);
                    case 'esc':
                        return this._isEscape(event);
                    case 'space':
                        return this._isSpace(event);
                    case 'shift':
                        return this._isShift(event);
                    case 'backspace':
                        return this._isBackspace(event);
                    case 'delete':
                        return this._isDelete(event);
                    case '0':
                        return this._isExpectedNumber(0, event);
                    case '1':
                        return this._isExpectedNumber(1, event);
                    case '2':
                        return this._isExpectedNumber(2, event);
                    case '3':
                        return this._isExpectedNumber(3, event);
                    case '4':
                        return this._isExpectedNumber(4, event);
                    case '5':
                        return this._isExpectedNumber(5, event);
                    case '6':
                        return this._isExpectedNumber(6, event);
                    case '7':
                        return this._isExpectedNumber(7, event);
                    case '8':
                        return this._isExpectedNumber(8, event);
                    case '9':
                        return this._isExpectedNumber(9, event);
                    default:
                        return false;
                }
            };
        /**
         * @private
         * @param {?} e
         * @return {?}
         */
        KeyHelper._isEnter = /**
         * @private
         * @param {?} e
         * @return {?}
         */
            function (e) {
                if (e.code === 'Enter'
                    || e.key === 'Enter'
                    || e.keyIdentifier === 'Enter'
                    || e.which === 13
                    || e.charCode === 13
                    || e.keyCode === 13) {
                    return true;
                }
                else {
                    return false;
                }
            };
        /**
         * @private
         * @param {?} e
         * @return {?}
         */
        KeyHelper._isArrowUp = /**
         * @private
         * @param {?} e
         * @return {?}
         */
            function (e) {
                if (e.code === 'ArrowUp'
                    || e.key === 'ArrowUp'
                    || e.key === 'Up'
                    || e.keyIdentifier === 'Up'
                    || e.which === 38
                    || e.keyCode === 38) {
                    return true;
                }
                else {
                    return false;
                }
            };
        /**
         * @private
         * @param {?} e
         * @return {?}
         */
        KeyHelper._isArrowDown = /**
         * @private
         * @param {?} e
         * @return {?}
         */
            function (e) {
                if (e.code === 'ArrowDown'
                    || e.key === 'ArrowDown'
                    || e.key === 'Down'
                    || e.keyIdentifier === 'Down'
                    || e.which === 40
                    || e.keyCode === 40) {
                    return true;
                }
                else {
                    return false;
                }
            };
        /**
         * @private
         * @param {?} e
         * @return {?}
         */
        KeyHelper._isArrowLeft = /**
         * @private
         * @param {?} e
         * @return {?}
         */
            function (e) {
                if (e.code === 'ArrowLeft'
                    || e.key === 'ArrowLeft'
                    || e.key === 'Left'
                    || e.keyIdentifier === 'Left'
                    || e.which === 37
                    || e.keyCode === 37) {
                    return true;
                }
                else {
                    return false;
                }
            };
        /**
         * @private
         * @param {?} e
         * @return {?}
         */
        KeyHelper._isArrowRight = /**
         * @private
         * @param {?} e
         * @return {?}
         */
            function (e) {
                if (e.code === 'ArrowRight'
                    || e.key === 'ArrowRight'
                    || e.key === 'Right'
                    || e.keyIdentifier === 'Right'
                    || e.which === 39
                    || e.keyCode === 39) {
                    return true;
                }
                else {
                    return false;
                }
            };
        /**
         * @private
         * @param {?} e
         * @return {?}
         */
        KeyHelper._isTab = /**
         * @private
         * @param {?} e
         * @return {?}
         */
            function (e) {
                if (e.code === 'Tab'
                    || e.key === 'Tab'
                    || e.keyIdentifier === 'U+0009'
                    || e.which === 9
                    || e.keyCode === 9) {
                    return true;
                }
                else {
                    return false;
                }
            };
        /**
         * @private
         * @param {?} e
         * @return {?}
         */
        KeyHelper._isEscape = /**
         * @private
         * @param {?} e
         * @return {?}
         */
            function (e) {
                if (e.code === 'Escape'
                    || e.key === 'Escape'
                    || e.key === 'Esc'
                    || e.keyIdentifier === 'U+001B'
                    || e.which === 27
                    || e.keyCode === 27) {
                    return true;
                }
                else {
                    return false;
                }
            };
        /**
         * @private
         * @param {?} e
         * @return {?}
         */
        KeyHelper._isSpace = /**
         * @private
         * @param {?} e
         * @return {?}
         */
            function (e) {
                if (e.code === 'Space'
                    || e.key === ' '
                    || e.key === 'Spacebar'
                    || e.keyIdentifier === 'U+0020'
                    || e.which === 32
                    || e.keyCode === 32) {
                    return true;
                }
                else {
                    return false;
                }
            };
        /**
         * @private
         * @param {?} e
         * @return {?}
         */
        KeyHelper._isShift = /**
         * @private
         * @param {?} e
         * @return {?}
         */
            function (e) {
                if (e.code === 'ShiftLeft'
                    || e.code === 'ShiftRight'
                    || e.key === 'Shift'
                    || e.keyIdentifier === 'Shift'
                    || e.which === 16
                    || e.keyCode === 16) {
                    return true;
                }
                else {
                    return false;
                }
            };
        /**
         * @private
         * @param {?} e
         * @return {?}
         */
        KeyHelper._isBackspace = /**
         * @private
         * @param {?} e
         * @return {?}
         */
            function (e) {
                if (e.code === 'Backspace'
                    || e.key === 'Backspace'
                    || e.keyIdentifier === 'U+0008'
                    || e.which === 8
                    || e.keyCode === 8) {
                    return true;
                }
                else {
                    return false;
                }
            };
        /**
         * @private
         * @param {?} e
         * @return {?}
         */
        KeyHelper._isDelete = /**
         * @private
         * @param {?} e
         * @return {?}
         */
            function (e) {
                if (e.code === 'Delete'
                    || e.key === 'Delete'
                    || e.keyIdentifier === 'U+007F'
                    || e.which === 46
                    || e.keyCode === 46) {
                    return true;
                }
                else {
                    return false;
                }
            };
        /**
         * @private
         * @param {?} e
         * @return {?}
         */
        KeyHelper._zero = /**
         * @private
         * @param {?} e
         * @return {?}
         */
            function (e) {
                if (e.code === 'Digit0'
                    || e.code === 'Numpad0'
                    || e.key === 0
                    || e.keyCode === 48
                    || e.keyCode === 96
                    || e.keyIdentifier === 'U+0030'
                    || e.which === 48) {
                    return 0;
                }
                else {
                    return undefined;
                }
            };
        /**
         * @private
         * @param {?} e
         * @return {?}
         */
        KeyHelper._one = /**
         * @private
         * @param {?} e
         * @return {?}
         */
            function (e) {
                if (e.code === 'Digit1'
                    || e.code === 'Numpad1'
                    || e.key === 1
                    || e.keyCode === 49
                    || e.keyCode === 97
                    || e.keyIdentifier === 'U+0031'
                    || e.which === 49) {
                    return 1;
                }
                else {
                    return undefined;
                }
            };
        /**
         * @private
         * @param {?} e
         * @return {?}
         */
        KeyHelper._two = /**
         * @private
         * @param {?} e
         * @return {?}
         */
            function (e) {
                if (e.code === 'Digit2'
                    || e.code === 'Numpad2'
                    || e.key === 2
                    || e.keyCode === 50
                    || e.keyCode === 98
                    || e.keyIdentifier === 'U+0032'
                    || e.which === 50) {
                    return 2;
                }
                else {
                    return undefined;
                }
            };
        /**
         * @private
         * @param {?} e
         * @return {?}
         */
        KeyHelper._three = /**
         * @private
         * @param {?} e
         * @return {?}
         */
            function (e) {
                if (e.code === 'Digit3'
                    || e.code === 'Numpad3'
                    || e.key === 3
                    || e.keyCode === 51
                    || e.keyCode === 99
                    || e.keyIdentifier === 'U+0033'
                    || e.which === 51) {
                    return 3;
                }
                else {
                    return undefined;
                }
            };
        /**
         * @private
         * @param {?} e
         * @return {?}
         */
        KeyHelper._four = /**
         * @private
         * @param {?} e
         * @return {?}
         */
            function (e) {
                if (e.code === 'Digit4'
                    || e.code === 'Numpad4'
                    || e.key === 4
                    || e.keyCode === 52
                    || e.keyCode === 100
                    || e.keyIdentifier === 'U+0034'
                    || e.which === 52) {
                    return 4;
                }
                else {
                    return undefined;
                }
            };
        /**
         * @private
         * @param {?} e
         * @return {?}
         */
        KeyHelper._five = /**
         * @private
         * @param {?} e
         * @return {?}
         */
            function (e) {
                if (e.code === 'Digit5'
                    || e.code === 'Numpad5'
                    || e.key === 5
                    || e.keyCode === 53
                    || e.keyCode === 101
                    || e.keyIdentifier === 'U+0035'
                    || e.which === 53) {
                    return 5;
                }
                else {
                    return undefined;
                }
            };
        /**
         * @private
         * @param {?} e
         * @return {?}
         */
        KeyHelper._six = /**
         * @private
         * @param {?} e
         * @return {?}
         */
            function (e) {
                if (e.code === 'Digit6'
                    || e.code === 'Numpad6'
                    || e.key === 6
                    || e.keyCode === 54
                    || e.keyCode === 102
                    || e.keyIdentifier === 'U+0036'
                    || e.which === 54) {
                    return 6;
                }
                else {
                    return undefined;
                }
            };
        /**
         * @private
         * @param {?} e
         * @return {?}
         */
        KeyHelper._seven = /**
         * @private
         * @param {?} e
         * @return {?}
         */
            function (e) {
                if (e.code === 'Digit7'
                    || e.code === 'Numpad7'
                    || e.key === 7
                    || e.keyCode === 55
                    || e.keyCode === 103
                    || e.keyIdentifier === 'U+0037'
                    || e.which === 55) {
                    return 7;
                }
                else {
                    return undefined;
                }
            };
        /**
         * @private
         * @param {?} e
         * @return {?}
         */
        KeyHelper._eight = /**
         * @private
         * @param {?} e
         * @return {?}
         */
            function (e) {
                if (e.code === 'Digit8'
                    || e.code === 'Numpad8'
                    || e.key === 8
                    || e.keyCode === 56
                    || e.keyCode === 104
                    || e.keyIdentifier === 'U+0038'
                    || e.which === 56) {
                    return 8;
                }
                else {
                    return undefined;
                }
            };
        /**
         * @private
         * @param {?} e
         * @return {?}
         */
        KeyHelper._nine = /**
         * @private
         * @param {?} e
         * @return {?}
         */
            function (e) {
                if (e.code === 'Digit9'
                    || e.code === 'Numpad9'
                    || e.key === 9
                    || e.keyCode === 57
                    || e.keyCode === 105
                    || e.keyIdentifier === 'U+0039'
                    || e.which === 57) {
                    return 9;
                }
                else {
                    return undefined;
                }
            };
        /**
         * @private
         * @param {?} expected
         * @param {?} event
         * @return {?}
         */
        KeyHelper._isExpectedNumber = /**
         * @private
         * @param {?} expected
         * @param {?} event
         * @return {?}
         */
            function (expected, event) {
                return expected === KeyHelper.getNumberFromKey(event);
            };
        return KeyHelper;
    }());
    /** @enum {string} */
    var KEYS = {
        'ENTER': 'enter',
        'UP': 'up',
        'DOWN': 'down',
        'LEFT': 'left',
        'RIGHT': 'right',
        'TAB': 'tab',
        'ESC': 'esc',
        'SPACE': 'space',
        'SHIFT': 'shift',
        'BACKSPACE': 'backspace',
        'ONE': '1',
        'TWO': '2',
        'THREE': '3',
        'FOUR': '4',
        'FIVE': '5',
        'SIX': '6',
        'SEVEN': '7',
        'EIGHT': '8',
        'NINE': '9',
        'ZERO': '0',
        'DELETE': 'delete',
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var Autocomplete_Autocomplete_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(( /**
         * @return {?}
         */function () { return SDSAutocompleteSearchComponent; })),
        multi: true
    };
    var SDSAutocompleteSearchComponent = /** @class */ (function () {
        function SDSAutocompleteSearchComponent(_changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            /**
             * selected index
             */
            this.highlightedIndex = 0;
            /**
             * value of the input field
             */
            this.inputValue = '';
            /**
             * Proprty being set on the object is highlighted
             */
            this.HighlightedPropertyName = 'highlighted';
            this.showLoad = true;
            /**
             * Search string
             */
            this.searchString = null;
            /**
             * To make input readonly
             */
            this.inputReadOnly = false;
            /**
             * Used to store selected items
             */
            this.items = [];
            /**
             * Stored Event for ControlValueAccessor
             */
            this.onTouchedCallback = ( /**
             * @return {?}
             */function () { return null; });
            /**
             * Stored Event for ControlValueAccessor
             */
            this.propogateChange = ( /**
             * @param {?} _
             * @return {?}
             */function (_) { return null; });
            this.resultsAvailableMessage = ' results available. Use up and down arrows\
  to scroll through results. Hit enter to select.';
            this.index = 0;
            /**
             * Determines if the dropdown should be shown
             */
            this.showResults = false;
        }
        /**
         * Gets the string value from the specifed properties of an object
         * @param object
         * @param propertyFields comma seperated list with periods depth of object
         */
        /**
         * Gets the string value from the specifed properties of an object
         * @param {?} object
         * @param {?} propertyFields comma seperated list with periods depth of object
         * @return {?}
         */
        SDSAutocompleteSearchComponent.prototype.getObjectValue = /**
         * Gets the string value from the specifed properties of an object
         * @param {?} object
         * @param {?} propertyFields comma seperated list with periods depth of object
         * @return {?}
         */
            function (object, propertyFields) {
                /** @type {?} */
                var value = '';
                /** @type {?} */
                var current = object;
                /** @type {?} */
                var fieldSplit = propertyFields.split(',');
                for (var i = 0; i < fieldSplit.length; i++) {
                    /** @type {?} */
                    var fieldValue = fieldSplit[i];
                    /** @type {?} */
                    var fieldPartSplit = fieldValue.split('.');
                    for (var j = 0; j < fieldPartSplit.length; j++) {
                        /** @type {?} */
                        var fieldCheckValue = fieldPartSplit[j];
                        if (current) {
                            current = current[fieldCheckValue];
                        }
                    }
                    if (current) {
                        value += current.toString() + ' ';
                    }
                    current = object;
                }
                return value.trim();
            };
        /**
         * Clears the input fields and value
         */
        /**
         * Clears the input fields and value
         * @return {?}
         */
        SDSAutocompleteSearchComponent.prototype.clearInput = /**
         * Clears the input fields and value
         * @return {?}
         */
            function () {
                this.inputValue = '';
                this.onTouchedCallback();
                this.clearAndHideResults();
            };
        /**
         *
         * @param event
         */
        /**
         *
         * @param {?} event
         * @return {?}
         */
        SDSAutocompleteSearchComponent.prototype.checkForFocus = /**
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.focusRemoved();
                this.showResults = false;
            };
        /**
         *
         */
        /**
         *
         * @private
         * @return {?}
         */
        SDSAutocompleteSearchComponent.prototype.focusRemoved = /**
         *
         * @private
         * @return {?}
         */
            function () {
                if (this.configuration) {
                    if (this.configuration.selectionMode === SelectionMode.SINGLE) {
                        if (this.model.items.length > 0) {
                            if (this.inputValue.length === 0) {
                                SDSSelectedItemModelHelper.clearItems(this.model.items);
                                this.propogateChange(this.model);
                            }
                            else {
                                this.inputValue = this.getObjectValue(this.model.items[0], this.configuration.primaryTextField);
                            }
                        }
                    }
                    else {
                        this.inputValue = '';
                    }
                }
                else {
                    this.inputValue = '';
                }
            };
        /**
         * @param {?} ev
         * @return {?}
         */
        SDSAutocompleteSearchComponent.prototype.onkeypress = /**
         * @param {?} ev
         * @return {?}
         */
            function (ev) {
                return this.configuration.inputReadOnly ? false : true;
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SDSAutocompleteSearchComponent.prototype.textChange = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (!this.configuration.isTagModeEnabled) {
                    // ie 11 placeholders will incorrectly trigger input events (known bug)
                    // if input isn't active element then don't do anything
                    if (event.target != document.activeElement) {
                        event.preventDefault();
                        return;
                    }
                    /** @type {?} */
                    var searchString = event.target.value || '';
                    this.getResults(searchString);
                }
            };
        /**
         * Event method used when focus is gained to the input
         */
        /**
         * Event method used when focus is gained to the input
         * @return {?}
         */
        SDSAutocompleteSearchComponent.prototype.inputFocusHandler = /**
         * Event method used when focus is gained to the input
         * @return {?}
         */
            function () {
                if (!this.configuration.isTagModeEnabled) {
                    if (this.configuration.focusInSearch) {
                        this.getResults(this.inputValue || '');
                    }
                    this.onTouchedCallback();
                }
            };
        /**
         * Key event
         * @param event
         */
        /**
         * Key event
         * @param {?} event
         * @return {?}
         */
        SDSAutocompleteSearchComponent.prototype.onKeydown = /**
         * Key event
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (KeyHelper.is(KEYS.TAB, event)) {
                    return;
                }
                else if (KeyHelper.is(KEYS.BACKSPACE, event)) {
                    if (this.configuration.inputReadOnly) {
                        event.preventDefault();
                    }
                }
                else if (KeyHelper.is(KEYS.DOWN, event)) {
                    this.onArrowDown();
                }
                else if (KeyHelper.is(KEYS.UP, event)) {
                    event.preventDefault();
                    this.onArrowUp();
                }
                else if (KeyHelper.is(KEYS.ENTER, event) && this.highlightedIndex >= 0) {
                    if (this.configuration.isTagModeEnabled) {
                        /** @type {?} */
                        var val = this.createFreeTextItem();
                        this.selectItem(val);
                    }
                    else {
                        this.selectItem(this.highlightedItem);
                    }
                }
                else if (KeyHelper.is(KEYS.ENTER, event) && this.highlightedIndex < 0) {
                    /** @type {?} */
                    var val = this.createFreeTextItem();
                    this.selectItem(val);
                }
                else if (KeyHelper.is(KEYS.ESC, event)) {
                    if (this.showResults) {
                        this.clearAndHideResults();
                        if (event.stopPropagation) {
                            event.stopPropagation();
                        }
                    }
                }
            };
        /**
         * selects the item adding it to the model and closes the results
         * @param item
         */
        /**
         * selects the item adding it to the model and closes the results
         * @param {?} item
         * @return {?}
         */
        SDSAutocompleteSearchComponent.prototype.selectItem = /**
         * selects the item adding it to the model and closes the results
         * @param {?} item
         * @return {?}
         */
            function (item) {
                var _this = this;
                SDSSelectedItemModelHelper.addItem(item, this.configuration.primaryKeyField, this.configuration.selectionMode, this.items);
                setTimeout(( /**
                 * @return {?}
                 */function () {
                    _this.model.items = __spread(_this.items);
                    _this.propogateChange(_this.model);
                }), 0);
                /** @type {?} */
                var message = this.getObjectValue(item, this.configuration.primaryTextField);
                this.inputValue = message;
                this.focusRemoved();
                this.showResults = false;
            };
        /**
         *  clears the results and closes result drop down
         */
        /**
         *  clears the results and closes result drop down
         * @private
         * @return {?}
         */
        SDSAutocompleteSearchComponent.prototype.clearAndHideResults = /**
         *  clears the results and closes result drop down
         * @private
         * @return {?}
         */
            function () {
                this.results = [];
                this.showResults = false;
                this.focusRemoved();
            };
        /**
         *  handles the arrow up key event
         */
        /**
         *  handles the arrow up key event
         * @private
         * @return {?}
         */
        SDSAutocompleteSearchComponent.prototype.onArrowUp = /**
         *  handles the arrow up key event
         * @private
         * @return {?}
         */
            function () {
                if (this.results && this.results.length > 0) {
                    if (this.highlightedIndex >= 0) {
                        this.highlightedIndex--;
                        this.setHighlightedItem(this.results[this.highlightedIndex]);
                        this.scrollSelectedItemIntoView();
                    }
                }
            };
        /**
         *  handles the arrow down key event
         */
        /**
         *  handles the arrow down key event
         * @private
         * @return {?}
         */
        SDSAutocompleteSearchComponent.prototype.onArrowDown = /**
         *  handles the arrow down key event
         * @private
         * @return {?}
         */
            function () {
                if (this.results && this.results.length > 0) {
                    if (this.highlightedIndex < this.results.length - 1) {
                        this.highlightedIndex++;
                        this.setHighlightedItem(this.results[this.highlightedIndex]);
                        this.scrollSelectedItemIntoView();
                    }
                }
            };
        /**
         * @return {?}
         */
        SDSAutocompleteSearchComponent.prototype.showFreeText = /**
         * @return {?}
         */
            function () {
                if (this.configuration.isFreeTextEnabled) {
                    if (this.inputValue) {
                        if (this.inputValue.length !== 0) {
                            /** @type {?} */
                            var foundItem = false;
                            if (this.results) {
                                for (var i = 0; i < this.results.length && !foundItem; i++) {
                                    /** @type {?} */
                                    var item = this.results[i];
                                    foundItem =
                                        item[this.configuration.primaryTextField] === this.inputValue;
                                }
                            }
                            if (this.model.items.length > 0 && !foundItem) {
                                for (var i = 0; i < this.model.items.length && !foundItem; i++) {
                                    /** @type {?} */
                                    var item = this.model.items[i];
                                    foundItem =
                                        item[this.configuration.primaryTextField] === this.inputValue;
                                }
                            }
                            return !foundItem;
                        }
                        else {
                            return false;
                        }
                    }
                    else {
                        return false;
                    }
                }
                else {
                    return this.configuration.isFreeTextEnabled;
                }
            };
        /**
         * @private
         * @return {?}
         */
        SDSAutocompleteSearchComponent.prototype.createFreeTextItem = /**
         * @private
         * @return {?}
         */
            function () {
                /** @type {?} */
                var item = { type: 'custom' };
                item[this.configuration.primaryTextField] = this.inputValue;
                item[this.configuration.primaryKeyField] = this.inputValue;
                return item;
            };
        /**
         *  gets the inital results
         * @param searchString
         */
        /**
         *  gets the inital results
         * @private
         * @param {?} searchString
         * @return {?}
         */
        SDSAutocompleteSearchComponent.prototype.getResults = /**
         *  gets the inital results
         * @private
         * @param {?} searchString
         * @return {?}
         */
            function (searchString) {
                var _this = this;
                if (searchString.length >= this.configuration.minimumCharacterCountSearch) {
                    if (!this.matchPastSearchString(searchString) ||
                        (this.matchPastSearchString(searchString) && !this.showResults) ||
                        this.matchPastSearchString('')) {
                        this.searchString = searchString;
                        window.clearTimeout(this.timeoutNumber);
                        this.timeoutNumber = window.setTimeout(( /**
                         * @return {?}
                         */function () {
                            _this.showLoad = true;
                            _this.service.getDataByText(0, searchString).subscribe(( /**
                             * @param {?} result
                             * @return {?}
                             */function (result) {
                                _this.results = result.items;
                                _this.showLoad = false;
                                _this.maxResults = result.totalItems;
                                _this.highlightedIndex = _this.configuration.isFreeTextEnabled
                                    ? -1
                                    : 0;
                                if (!_this.configuration.isFreeTextEnabled) {
                                    _this.setHighlightedItem(_this.results[_this.highlightedIndex]);
                                }
                                _this.showResults = true;
                                _this.addScreenReaderMessage(_this.maxResults + ' ' + _this.resultsAvailableMessage);
                                _this._changeDetectorRef.markForCheck();
                            }));
                        }), this.configuration.debounceTime);
                    }
                }
            };
        /**
         * Checks if the new search string matches the old search string
         * @param searchString
         */
        /**
         * Checks if the new search string matches the old search string
         * @private
         * @param {?} searchString
         * @return {?}
         */
        SDSAutocompleteSearchComponent.prototype.matchPastSearchString = /**
         * Checks if the new search string matches the old search string
         * @private
         * @param {?} searchString
         * @return {?}
         */
            function (searchString) {
                return this.searchString === searchString;
            };
        /**
         * highlights the index being hovered
         * @param index
         */
        /**
         * highlights the index being hovered
         * @param {?} index
         * @return {?}
         */
        SDSAutocompleteSearchComponent.prototype.listItemHover = /**
         * highlights the index being hovered
         * @param {?} index
         * @return {?}
         */
            function (index) {
                this.highlightedIndex = index;
                this.setHighlightedItem(this.results[this.highlightedIndex]);
            };
        /**
         * Scroll Event Handler (Calculates if mpre items should be asked for from service on scrolling down)
         */
        /**
         * Scroll Event Handler (Calculates if mpre items should be asked for from service on scrolling down)
         * @return {?}
         */
        SDSAutocompleteSearchComponent.prototype.onScroll = /**
         * Scroll Event Handler (Calculates if mpre items should be asked for from service on scrolling down)
         * @return {?}
         */
            function () {
                if (this.maxResults > this.results.length) {
                    /** @type {?} */
                    var scrollAreaHeight = this.resultsListElement.nativeElement.offsetHeight;
                    /** @type {?} */
                    var scrollTopPos = this.resultsListElement.nativeElement.scrollTop;
                    /** @type {?} */
                    var scrollAreaMaxHeight = this.resultsListElement.nativeElement
                        .scrollHeight;
                    if (scrollTopPos + scrollAreaHeight * 2 >= scrollAreaMaxHeight) {
                        this.getAdditionalResults();
                    }
                }
            };
        /**
         * gets more results based when scrolling and adds the items
         */
        /**
         * gets more results based when scrolling and adds the items
         * @private
         * @return {?}
         */
        SDSAutocompleteSearchComponent.prototype.getAdditionalResults = /**
         * gets more results based when scrolling and adds the items
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                this.showLoad = true;
                this.service
                    .getDataByText(this.results.length, this.searchString)
                    .subscribe(( /**
             * @param {?} result
             * @return {?}
             */function (result) {
                    for (var i = 0; i < result.items.length; i++) {
                        _this.addResult(result.items[i]);
                    }
                    _this.showLoad = false;
                    _this.maxResults = result.totalItems;
                }));
            };
        /**
         * adds a single item to the list
         * @param item
         */
        /**
         * adds a single item to the list
         * @private
         * @param {?} item
         * @return {?}
         */
        SDSAutocompleteSearchComponent.prototype.addResult = /**
         * adds a single item to the list
         * @private
         * @param {?} item
         * @return {?}
         */
            function (item) {
                //add check to make sure item does not exist
                this.results.push(item);
            };
        /**
         * When paging up and down with arrow key it sets the highlighted item into view
         */
        /**
         * When paging up and down with arrow key it sets the highlighted item into view
         * @private
         * @return {?}
         */
        SDSAutocompleteSearchComponent.prototype.scrollSelectedItemIntoView = /**
         * When paging up and down with arrow key it sets the highlighted item into view
         * @private
         * @return {?}
         */
            function () {
                if (this.highlightedIndex >= 0) {
                    /** @type {?} */
                    var selectedChild = this.resultsListElement.nativeElement.children[this.highlightedIndex];
                    selectedChild.scrollIntoView({
                        behavior: 'smooth',
                        block: 'nearest',
                        inline: 'start'
                    });
                }
            };
        /**
         * Sets the highlighted item by keyboard or mouseover
         * @param item
         */
        /**
         * Sets the highlighted item by keyboard or mouseover
         * @private
         * @param {?} item
         * @return {?}
         */
        SDSAutocompleteSearchComponent.prototype.setHighlightedItem = /**
         * Sets the highlighted item by keyboard or mouseover
         * @private
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (this.results && this.results.length > 0) {
                    if (this.highlightedItem) {
                        this.highlightedItem[this.HighlightedPropertyName] = false;
                    }
                    /** @type {?} */
                    var message = '';
                    if (item) {
                        this.highlightedItem = item;
                        this.highlightedItem[this.HighlightedPropertyName] = true;
                        message = item[this.configuration.primaryTextField];
                        if (this.configuration.secondaryTextField &&
                            item[this.configuration.secondaryTextField]) {
                            message += ': ' + item[this.configuration.secondaryTextField];
                        }
                    }
                    else {
                        this.highlightedItem = undefined;
                        message = 'No item selected';
                    }
                    this.addScreenReaderMessage(message);
                }
            };
        /**
         * Adds message to be read by screen reader
         * @param message
         */
        /**
         * Adds message to be read by screen reader
         * @private
         * @param {?} message
         * @return {?}
         */
        SDSAutocompleteSearchComponent.prototype.addScreenReaderMessage = /**
         * Adds message to be read by screen reader
         * @private
         * @param {?} message
         * @return {?}
         */
            function (message) {
                this.srOnlyText = message;
            };
        /**
         * @param {?} obj
         * @return {?}
         */
        SDSAutocompleteSearchComponent.prototype.writeValue = /**
         * @param {?} obj
         * @return {?}
         */
            function (obj) {
                if (obj instanceof SDSSelectedItemModel) {
                    this.model = ( /** @type {?} */(obj));
                    this._changeDetectorRef.markForCheck();
                    if (this.model.items.length === 0) {
                        this.inputValue = '';
                    }
                    else {
                        if (this.configuration.selectionMode === SelectionMode.SINGLE) {
                            this.inputValue = this.getObjectValue(this.model.items[0], this.configuration.primaryTextField);
                        }
                    }
                }
            };
        /**
         * @return {?}
         */
        SDSAutocompleteSearchComponent.prototype.getClass = /**
         * @return {?}
         */
            function () {
                return this.configuration.inputReadOnly &&
                    this.configuration.selectionMode === SelectionMode.MULTIPLE
                    ? 'hide-cursor'
                    : '';
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        SDSAutocompleteSearchComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.propogateChange = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        SDSAutocompleteSearchComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onTouchedCallback = fn;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        SDSAutocompleteSearchComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        SDSAutocompleteSearchComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'sds-search-autocomplete',
                        template: "<div sds-click-outside (clickOutside)=\"checkForFocus($event)\" sds-tab-outside (tabOutside)=\"checkForFocus($event)\">\n  <div class=\"maxw-mobile-lg position-relative\">\n    <div role=\"combobox\" [attr.id]=\"configuration.id+'-container'\" [attr.aria-expanded]=\"showResults\" [attr.aria-owns]=\"showResults? configuration.id+ '-listbox' : undefined\"\n      aria-haspopup=\"listbox\">\n      <input [disabled]=\"disabled\" (keypress)=\"onkeypress($event)\" (input)=\"textChange($event)\" class=\"usa-input padding-right-3\"\n        [ngClass]=\"getClass()\" #input [attr.aria-label]=\"configuration.ariaLabelText\" [attr.id]=\"configuration.id\" type=\"text\"\n        (focus)=\"inputFocusHandler()\" (keydown)=\"onKeydown($event)\" [(ngModel)]=\"inputValue\" aria-autocomplete=\"list\"\n        [attr.placeholder]=\"configuration.autocompletePlaceHolderText\" [attr.aria-activedescendant]=\"showResults? configuration.id+'-resultItem-'+highlightedIndex :''\"\n        [attr.aria-controls]=\"showResults? configuration.id+ '-listbox' : undefined\" autocomplete=\"off\">\n    </div>\n    <ul #resultsList *ngIf=\"showResults\" [attr.id]=\"configuration.id+ '-listbox'\" role=\"listbox\" class=\"usa-list usa-list--unstyled sds-autocomplete\"\n      (scroll)=\"onScroll()\">\n      <ng-container *ngIf=\"(results && results.length > 0)\">\n        <li [attr.id]=\"configuration.id+'-resultItem-'+i\" role=\"option\" *ngFor=\"let result of results; let i = index\"\n          (mouseenter)=\"listItemHover(i)\" [class]=\"result['highlighted'] ? 'sds-autocomplete__item sds-autocomplete__item--selected' : 'sds-autocomplete__item' \"\n          (click)=\"selectItem(result)\">\n          <ng-container *ngIf=\"itemTemplate\" [ngTemplateOutlet]=\"itemTemplate\" [ngTemplateOutletContext]=\"{$implicit:result}\">\n          </ng-container>\n\n          <ng-container *ngIf=\"!itemTemplate\">\n            <span class=\"display-block text-semibold\">\n              {{ getObjectValue(result, configuration.primaryTextField) }}\n              <span *ngIf=\"result.type === 'custom'\">\n                - {{configuration.freeTextSubtext}}\n              </span>\n            </span>\n            <ng-container *ngIf=\"configuration.secondaryTextField &&  result[configuration.secondaryTextField] \">\n              <span class=\"description\">{{ result[configuration.secondaryTextField] }}</span>\n            </ng-container>\n          </ng-container>\n        </li>\n      </ng-container>\n      <ng-container *ngIf=\"(!results || results.length == 0)\">\n        <li class=\"emptyResults margin-1\">No results found</li>\n      </ng-container>\n      <ng-container *ngIf=\"showLoad\">\n        <li class=\"autoLoading\">\n          <div class=\"lightToGrayBackgroundGradiate\">\n\n          </div>\n          <div class=\"grayToLightBackgroundGradiate\">\n\n          </div>\n        </li>\n        <li class=\"autoLoading\">\n          <div class=\"lightToGrayBackgroundGradiate\">\n\n          </div>\n          <div class=\"grayToLightBackgroundGradiate\">\n\n          </div>\n        </li>\n      </ng-container>\n    </ul>\n\n    <ng-container *ngIf=\"!input.disabled\">\n      <span class=\"position-absolute right-105 top-1 cursor-pointer\">\n        <span *ngIf=\"(inputValue && !disabled)\" tabindex=\"0\" role=\"button\" aria-label=\"Clear input\" aria-hidden=\"false\"\n          (click)=\"clearInput()\" (keyup.enter)=\"clearInput()\">\n          <fa-icon [icon]=\"['fas', 'times']\" size=\"xs\"></fa-icon>\n        </span>\n        <span *ngIf=\"!configuration.isTagModeEnabled\" tabindex=\"1\" role=\"button\" aria-label=\"Clear input\" aria-hidden=\"false\"\n          class=\"margin-left-1\">\n          <fa-icon *ngIf=\"(!showResults && !disabled)\" (click)=\"inputFocusHandler()\" [icon]=\"['fas', 'caret-down']\"\n            size=\"sm\"></fa-icon>\n          <fa-icon *ngIf=\"(showResults && !disabled)\" (click)=\"checkForFocus($event)\" [icon]=\"['fas', 'caret-up']\" size=\"sm\"></fa-icon>\n        </span>\n      </span>\n    </ng-container>\n    <ul class=\"usa-sr-only\" aria-live=\"assertive\">\n      <li>{{srOnlyText}}</li>\n    </ul>\n  </div>",
                        providers: [Autocomplete_Autocomplete_VALUE_ACCESSOR],
                        styles: [".grayToLightBackgroundGradiate{background:linear-gradient(to right,#c4c4c4,#f7f7f7);background-size:400% 400%;height:10px;padding:2.5px 0;text-align:center;color:#888;font-size:15px;font-weight:700;margin:7px 10px 0;-webkit-animation:5s infinite gradiantShiftGray;animation:5s infinite gradiantShiftGray}@-webkit-keyframes gradiantShiftGray{0%,100%{background-position:0 50%}50%{background-position:100% 50%}}@keyframes gradiantShiftGray{0%,100%{background-position:0 50%}50%{background-position:100% 50%}}.lightToGrayBackgroundGradiate{background:linear-gradient(to right,#f7f7f7,#c4c4c4);background-size:400% 400%;height:15px;padding:2.5px 0;text-align:center;color:#888;font-size:15px;font-weight:700;margin:10px 10px 0;-webkit-animation:5s infinite gradiantShift;animation:5s infinite gradiantShift}@-webkit-keyframes gradiantShift{0%,100%{background-position:0 50%}50%{background-position:100% 50%}}@keyframes gradiantShift{0%,100%{background-position:0 50%}50%{background-position:100% 50%}}.autoLoading{height:60px}.hide-cursor{color:transparent;text-shadow:0 0 0}"]
                    }] }
        ];
        /** @nocollapse */
        SDSAutocompleteSearchComponent.ctorParameters = function () {
            return [
                { type: core.ChangeDetectorRef }
            ];
        };
        SDSAutocompleteSearchComponent.propDecorators = {
            resultsListElement: [{ type: core.ViewChild, args: ['resultsList',] }],
            input: [{ type: core.ViewChild, args: ['input',] }],
            itemTemplate: [{ type: core.Input }],
            configuration: [{ type: core.Input }],
            service: [{ type: core.Input }],
            inputReadOnly: [{ type: core.Input }],
            disabled: [{ type: core.Input }]
        };
        return SDSAutocompleteSearchComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * The <sam-click-outside> directive can detect whether a click is made inside
     * the target
     */
    var SDSClickOutsideDirective = /** @class */ (function () {
        function SDSClickOutsideDirective(_elementRef) {
            this._elementRef = _elementRef;
            /**
             * Event emitted when clicked outside the target
             */
            this.clickOutside = new core.EventEmitter();
        }
        /**
         * @param {?} targetElement
         * @return {?}
         */
        SDSClickOutsideDirective.prototype.onClick = /**
         * @param {?} targetElement
         * @return {?}
         */
            function (targetElement) {
                /** @type {?} */
                var clickedInside = this._elementRef.nativeElement.contains(targetElement);
                if (!clickedInside) {
                    this.clickOutside.emit(undefined);
                }
            };
        SDSClickOutsideDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[sds-click-outside]'
                    },] }
        ];
        /** @nocollapse */
        SDSClickOutsideDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef }
            ];
        };
        SDSClickOutsideDirective.propDecorators = {
            clickOutside: [{ type: core.Output }],
            onClick: [{ type: core.HostListener, args: ['document:click', ['$event.target'],] }]
        };
        return SDSClickOutsideDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SDSClickOutsideModule = /** @class */ (function () {
        function SDSClickOutsideModule() {
        }
        SDSClickOutsideModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule, forms.FormsModule
                        ],
                        declarations: [SDSClickOutsideDirective],
                        exports: [SDSClickOutsideDirective]
                    },] }
        ];
        return SDSClickOutsideModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SDSTabOutsideDirective = /** @class */ (function () {
        function SDSTabOutsideDirective(_elementRef) {
            this._elementRef = _elementRef;
            /**
             * Emitter for tabOutside event
             */
            this.tabOutside = new core.EventEmitter();
        }
        /**
         * @param {?} target
         * @return {?}
         */
        SDSTabOutsideDirective.prototype.hasFocusChanged = /**
         * @param {?} target
         * @return {?}
         */
            function (target) {
                /** @type {?} */
                var isInsideHost = this._elementRef.nativeElement.contains(target);
                if (!isInsideHost) {
                    this.tabOutside.emit(undefined);
                }
            };
        SDSTabOutsideDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[sds-tab-outside]'
                    },] }
        ];
        /** @nocollapse */
        SDSTabOutsideDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef }
            ];
        };
        SDSTabOutsideDirective.propDecorators = {
            tabOutside: [{ type: core.Output }],
            hasFocusChanged: [{ type: core.HostListener, args: ['document:keyup', ['$event.target'],] }]
        };
        return SDSTabOutsideDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SdsTabOutsideModule = /** @class */ (function () {
        function SdsTabOutsideModule() {
        }
        SdsTabOutsideModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule, forms.FormsModule
                        ],
                        declarations: [SDSTabOutsideDirective],
                        exports: [SDSTabOutsideDirective]
                    },] }
        ];
        return SdsTabOutsideModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SdsAutocompleteSearchModule = /** @class */ (function () {
        function SdsAutocompleteSearchModule() {
        }
        SdsAutocompleteSearchModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            SDSClickOutsideModule,
                            SdsTabOutsideModule,
                            angularFontawesome.FontAwesomeModule
                        ],
                        declarations: [SDSAutocompleteSearchComponent],
                        exports: [SDSAutocompleteSearchComponent]
                    },] }
        ];
        return SdsAutocompleteSearchModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SdsAutocompleteModule = /** @class */ (function () {
        function SdsAutocompleteModule() {
        }
        SdsAutocompleteModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule, forms.FormsModule, router.RouterModule, SdsSelectedResultsModule, SdsAutocompleteSearchModule
                        ],
                        declarations: [SDSAutocompleteComponent],
                        exports: [SDSAutocompleteComponent]
                    },] }
        ];
        return SdsAutocompleteModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SDSAutocompletelConfiguration = /** @class */ (function () {
        /**
           * sets the default debounce time to 250 milliseconds
           */
        function SDSAutocompletelConfiguration() {
            /**
             * Mode of the model either allows a single item or multiple items
             */
            this.selectionMode = SelectionMode.SINGLE;
            /**
             * Allows option to allow user text not in the standard results
             */
            this.isFreeTextEnabled = false;
            /**
             * Text appeneded ad the end of free text
             */
            this.freeTextSubtext = 'search';
            /**
             * Focus into autocomplete search
             */
            this.focusInSearch = true;
            /**
             * The aria-label for the auto-complete
             */
            this.ariaLabelText = 'Auto Complete';
            /**
             * To enable the tag mode
             */
            this.isTagModeEnabled = false;
            /**
             * To make input readonly
             */
            this.inputReadOnly = false;
            this.debounceTime = 250;
            this.minimumCharacterCountSearch = 0;
        }
        return SDSAutocompletelConfiguration;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SDSHiercarchicalServiceSearchItem = /** @class */ (function () {
        function SDSHiercarchicalServiceSearchItem() {
        }
        return SDSHiercarchicalServiceSearchItem;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SDSSelectedResultConfiguration = /** @class */ (function () {
        function SDSSelectedResultConfiguration() {
            /**
             * Mode of the model either allows a single item or multiple items
             */
            this.selectionMode = SelectionMode.SINGLE;
        }
        return SDSSelectedResultConfiguration;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SdsSideNavigationComponent = /** @class */ (function () {
        function SdsSideNavigationComponent() {
            /**
             * Navigation helper
             */
            this.navigationHelper = new NavigationHelper();
            /**
             * event for event based
             */
            this.linkEvent = new core.EventEmitter();
        }
        /**
         * Takes the navigation item and returns the template to be used
         * @param item navigation item
         */
        /**
         * Takes the navigation item and returns the template to be used
         * @param {?} item navigation item
         * @return {?}
         */
        SdsSideNavigationComponent.prototype.getItemTemplate = /**
         * Takes the navigation item and returns the template to be used
         * @param {?} item navigation item
         * @return {?}
         */
            function (item) {
                /** @type {?} */
                var template = null;
                switch (item.mode) {
                    case NavigationMode.EVENT:
                        template = this.sideNavEVENTLinkTemplate;
                        break;
                    case NavigationMode.EXTERNAL:
                        template = this.sideNavHREFLinkTemplate;
                        break;
                    case NavigationMode.INTERNAL:
                        template = this.sideNavRouteLinkTemplate;
                        break;
                    case NavigationMode.LABEL:
                        template = this.sideNavLabelLinkTemplate;
                        break;
                    default:
                        template = null;
                        break;
                }
                return template;
            };
        /**
         * Selects new item and parents and deselects previous
         * @param id
         */
        /**
         * Selects new item and parents and deselects previous
         * @param {?} id
         * @return {?}
         */
        SdsSideNavigationComponent.prototype.select = /**
         * Selects new item and parents and deselects previous
         * @param {?} id
         * @return {?}
         */
            function (id) {
                this.deselect();
                for (var i = 0; i < this.model.navigationLinks.length; i++) {
                    /** @type {?} */
                    var item = this.model.navigationLinks[i];
                    this.selectItem(id, item, null);
                }
            };
        /**
         * Selects item if matches passed in id and will select parent
         * @param id
         * @param item
         * @param parent
         */
        /**
         * Selects item if matches passed in id and will select parent
         * @private
         * @param {?} id
         * @param {?} item
         * @param {?} parent
         * @return {?}
         */
        SdsSideNavigationComponent.prototype.selectItem = /**
         * Selects item if matches passed in id and will select parent
         * @private
         * @param {?} id
         * @param {?} item
         * @param {?} parent
         * @return {?}
         */
            function (id, item, parent) {
                if (item.id === id) {
                    item.selected = true;
                    if (parent) {
                        parent.selected = true;
                    }
                }
                else {
                    if (item.children) {
                        for (var i = 0; i < item.children.length; i++) {
                            /** @type {?} */
                            var childItem = item.children[i];
                            this.selectItem(id, childItem, item);
                        }
                        if (item.selected) {
                            if (parent) {
                                parent.selected = true;
                            }
                        }
                    }
                }
            };
        /**
         * Deselects all the items in the side navigation model
         */
        /**
         * Deselects all the items in the side navigation model
         * @return {?}
         */
        SdsSideNavigationComponent.prototype.deselect = /**
         * Deselects all the items in the side navigation model
         * @return {?}
         */
            function () {
                if (this.model) {
                    if (this.model.navigationLinks) {
                        for (var i = 0; i < this.model.navigationLinks.length; i++) {
                            this.deselectItem(this.model.navigationLinks[i]);
                        }
                    }
                }
            };
        /**
         * checks if item is selected and if selcted will check children and will unselect
         */
        /**
         * checks if item is selected and if selcted will check children and will unselect
         * @private
         * @param {?} item
         * @return {?}
         */
        SdsSideNavigationComponent.prototype.deselectItem = /**
         * checks if item is selected and if selcted will check children and will unselect
         * @private
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (item.selected) {
                    item.selected = false;
                    if (item.children) {
                        for (var i = 0; i < item.children.length; i++) {
                            this.deselectItem(item.children[i]);
                        }
                    }
                }
            };
        /**
         * Link clicked and emits the link data into an event
         * @param link
         */
        /**
         * Link clicked and emits the link data into an event
         * @param {?} link
         * @return {?}
         */
        SdsSideNavigationComponent.prototype.linkClickEvent = /**
         * Link clicked and emits the link data into an event
         * @param {?} link
         * @return {?}
         */
            function (link) {
                this.linkEvent.emit(link);
                return false;
            };
        /**
         * creates url from provided route and query params
         * @param item
         */
        /**
         * creates url from provided route and query params
         * @param {?} item
         * @return {?}
         */
        SdsSideNavigationComponent.prototype.urlBuilder = /**
         * creates url from provided route and query params
         * @param {?} item
         * @return {?}
         */
            function (item) {
                /** @type {?} */
                var url = item.route;
                /** @type {?} */
                var queryParams = this.queryStringBuilder(item);
                if (queryParams) {
                    if (url.indexOf('?') === -1) {
                        url += '?' + queryParams;
                    }
                    else if (url.indexOf('?') === url.length - 1) {
                        url += queryParams;
                    }
                    else {
                        url += '&' + queryParams;
                    }
                }
                return url;
            };
        /**
         * creates query string
         * @param item
         */
        /**
         * creates query string
         * @private
         * @param {?} item
         * @return {?}
         */
        SdsSideNavigationComponent.prototype.queryStringBuilder = /**
         * creates query string
         * @private
         * @param {?} item
         * @return {?}
         */
            function (item) {
                /** @type {?} */
                var ret = [];
                for (var d in item.queryParams) {
                    ret.push(encodeURIComponent(d) + '=' + encodeURIComponent(item.queryParams[d]));
                }
                return ret.join('&');
            };
        SdsSideNavigationComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'sds-side-navigation',
                        template: "<nav>\n    <ul class=\"usa-sidenav\">\n        <li *ngFor=\"let link of model.navigationLinks\" class=\"sidenav__item\">\n            <ng-container [ngTemplateOutlet]=\"sideNavLinkTemplate\" [ngTemplateOutletContext]=\"{$implicit:link}\">\n            </ng-container>\n        </li>\n    </ul>\n</nav>\n\n<ng-template #sideNavLinkTemplate let-link>\n    <ng-container [ngTemplateOutlet]=\"getItemTemplate(link)\" [ngTemplateOutletContext]=\"{$implicit:link}\">\n    </ng-container>\n    <ul *ngIf=\"link.children\" class=\"usa-sidenav__sublist\">\n        <li *ngFor=\"let link of link.children\" class=\"sidenav__item\">\n            <ng-container [ngTemplateOutlet]=\"sideNavLinkTemplate\" [ngTemplateOutletContext]=\"{$implicit:link}\">\n            </ng-container>\n        </li>\n    </ul>\n</ng-template>\n\n<ng-template #sideNavRouteLinkTemplate let-link>\n    <a [attr.class]=\"link.selected ? ' usa-current' : ''\" [routerLink]=\"[link.route]\"\n        [queryParams]=\"link.queryParams\"><span>{{link.text}}</span></a>\n</ng-template>\n\n<ng-template #sideNavHREFLinkTemplate let-link>\n    <a [attr.class]=\"link.selected ? ' usa-current' : ''\" [attr.href]=\"urlBuilder(link)\"><span>{{link.text}}</span></a>\n</ng-template>\n\n<ng-template #sideNavLabelLinkTemplate let-link>\n    <span [attr.class]=\"link.selected ? ' usa-current' : ''\"><span>{{link.text}}</span></span>\n</ng-template>\n\n<ng-template #sideNavEVENTLinkTemplate let-link>\n    <a [attr.class]=\"link.selected ? ' usa-current' : ''\" href=\"javascript:void(0)\"\n        (click)=\"linkClickEvent(link)\"><span>{{link.text}}</span></a>\n</ng-template>",
                        styles: [""]
                    }] }
        ];
        SdsSideNavigationComponent.propDecorators = {
            sideNavRouteLinkTemplate: [{ type: core.ViewChild, args: ['sideNavRouteLinkTemplate',] }],
            sideNavLabelLinkTemplate: [{ type: core.ViewChild, args: ['sideNavLabelLinkTemplate',] }],
            sideNavHREFLinkTemplate: [{ type: core.ViewChild, args: ['sideNavHREFLinkTemplate',] }],
            sideNavEVENTLinkTemplate: [{ type: core.ViewChild, args: ['sideNavEVENTLinkTemplate',] }],
            model: [{ type: core.Input }],
            linkEvent: [{ type: core.Output }]
        };
        return SdsSideNavigationComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SdsSideNavigationModule = /** @class */ (function () {
        function SdsSideNavigationModule() {
        }
        SdsSideNavigationModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule, forms.FormsModule, router.RouterModule, SdsAccordionModule
                        ],
                        declarations: [SdsSideNavigationComponent],
                        exports: [SdsSideNavigationComponent]
                    },] }
        ];
        return SdsSideNavigationModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SdsSearchResultListComponent = /** @class */ (function () {
        function SdsSearchResultListComponent() {
            /**
             * Show divider between results
             */
            this.divider = true;
        }
        SdsSearchResultListComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'sds-search-result-list',
                        template: "<div *ngFor=\"let item of model\">\n    <hr *ngIf=\"divider\" class=\"thin\" />\n    <ng-container *ngTemplateOutlet=\"resultContentTemplate,\n                   context: { $implicit: item }\"></ng-container>\n</div>\n<hr *ngIf=\"divider && model?.length\" class=\"thin\" />\n<div *ngIf=\"!model|| model.length===0\">\n    <div class=\"grid-row border-1px border-base-lighter bg-base-lightest\">\n      <div class=\"grid-col-auto text-center text-base margin-4\">\n        <fa-icon [icon]=\"['sds', 'search']\" [classes]=\"['search']\" size=\"7x\"></fa-icon>\n      </div>\n      <div class=\"grid-col-fill display-flex flex-column padding-y-1\">\n        <h1 class=\"margin-bottom-105 text-semibold\">No matches found</h1>\n        <p class=\"margin-y-0 font-sans-lg\">We couldn't find a match for your search criteria.</p>\n        <p class=\"margin-y-0 font-sans-lg\">Please try another search or go back to previous results.</p>\n        <button class=\"usa-button usa-button--secondary width-card margin-y-2\">Go Back</button>\n      </div>\n    </div>\n</div>\n",
                        styles: [""]
                    }] }
        ];
        SdsSearchResultListComponent.propDecorators = {
            model: [{ type: core.Input }],
            divider: [{ type: core.Input }],
            resultContentTemplate: [{ type: core.ContentChild, args: ['resultContent',] }]
        };
        return SdsSearchResultListComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SdsSearchResultListModule = /** @class */ (function () {
        function SdsSearchResultListModule() {
        }
        SdsSearchResultListModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule, forms.FormsModule, angularFontawesome.FontAwesomeModule
                        ],
                        declarations: [SdsSearchResultListComponent],
                        exports: [SdsSearchResultListComponent]
                    },] }
        ];
        return SdsSearchResultListModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var FooterModel = /** @class */ (function () {
        function FooterModel() {
        }
        return FooterModel;
    }());
    var FooterLinkSection = /** @class */ (function () {
        function FooterLinkSection() {
        }
        return FooterLinkSection;
    }());
    var FooterLink = /** @class */ (function () {
        function FooterLink() {
        }
        return FooterLink;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var HeaderHome = /** @class */ (function () {
        function HeaderHome() {
        }
        return HeaderHome;
    }());
    /**
     *
     */
    var /**
     *
     */ HeaderNavigationLink = /** @class */ (function () {
        function HeaderNavigationLink() {
        }
        return HeaderNavigationLink;
    }());
    var HeaderSecondaryLink = /** @class */ (function () {
        function HeaderSecondaryLink() {
        }
        return HeaderSecondaryLink;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SideNavigationModel = /** @class */ (function () {
        function SideNavigationModel() {
        }
        return SideNavigationModel;
    }());
    var NavigationLink = /** @class */ (function () {
        function NavigationLink() {
        }
        return NavigationLink;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var sdsMenuAnimations = {
        transformMenu: animations$1.trigger('transformMenu', [
            animations$1.state('void', animations$1.style({
                opacity: 0,
                transform: 'scale(0.8)'
            })),
            animations$1.transition('void => enter', animations$1.group([
                animations$1.query('.sds-menu', animations$1.animate('100ms linear', animations$1.style({
                    opacity: 1
                }))),
                animations$1.animate('120ms cubic-bezier(0, 0, 0.2, 1)', animations$1.style({ transform: 'scale(1)' }))
            ])),
            animations$1.transition('* => void', animations$1.animate('100ms 25ms linear', animations$1.style({ opacity: 0 })))
        ])
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Injection token used to provide the parent menu to menu items.
     * @type {?}
     */
    var SDS_MENU_TOKEN = new core.InjectionToken('SDS_MENU_TOKEN');
    var SdsMenuComponent = /** @class */ (function () {
        function SdsMenuComponent(_elementRef) {
            this._elementRef = _elementRef;
            /**
             * After | Before the menu triger element
             */
            this._xPosition = 'after';
            /**
             * Above | Below the menu triger element
             */
            this._yPosition = 'below';
            /**
             * Menu items inside the current menu.
             */
            this._items = [];
            /**
             * Subscription to tab events on the menu panel
             */
            this._tabSubscription = rxjs.Subscription.EMPTY;
            /**
             * Config object to be passed into the menu's ngClass
             */
            this._classList = {};
            /**
             * Current state of the panel animation.
             */
            this._panelAnimationState = 'void';
            this._overlapTrigger = false;
            /**
             * Event emitted when the menu is closed.
             */
            this.closed = new core.EventEmitter();
        }
        Object.defineProperty(SdsMenuComponent.prototype, "xPosition", {
            /** Position of the menu in the X axis. */
            get: /**
             * Position of the menu in the X axis.
             * @return {?}
             */ function () {
                return this._xPosition;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._xPosition = value;
                this.setPositionClasses();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SdsMenuComponent.prototype, "yPosition", {
            /** Position of the menu in the Y axis. */
            get: /**
             * Position of the menu in the Y axis.
             * @return {?}
             */ function () {
                return this._yPosition;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._yPosition = value;
                this.setPositionClasses();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SdsMenuComponent.prototype, "overlapTrigger", {
            /** Whether menu panel overlaps trigger element */
            get: /**
             * Whether menu panel overlaps trigger element
             * @return {?}
             */ function () {
                return this._overlapTrigger;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._overlapTrigger = coercion.coerceBooleanProperty(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SdsMenuComponent.prototype, "panelClass", {
            /** Transfer classes from the sds-menu to the overlay container */
            set: /**
             * Transfer classes from the sds-menu to the overlay container
             * @param {?} classes
             * @return {?}
             */ function (classes) {
                var _this = this;
                /** @type {?} */
                var previousPanelClass = this._previousPanelClass;
                // Remove previous classes from current set of classes
                if (previousPanelClass && previousPanelClass.length) {
                    previousPanelClass.split(' ').forEach(( /**
                     * @param {?} className
                     * @return {?}
                     */function (className) {
                        _this._classList[className] = false;
                    }));
                }
                this._previousPanelClass = classes;
                // Adds new classes to current set of classes
                if (classes && classes.length) {
                    classes.split(' ').forEach(( /**
                     * @param {?} className
                     * @return {?}
                     */function (className) {
                        _this._classList[className] = true;
                    }));
                    // Remove all classes from <sds-menu>
                    this._elementRef.nativeElement.className = '';
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SdsMenuComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.setPositionClasses();
            };
        /**
         * @return {?}
         */
        SdsMenuComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this._keyManager = new a11y.FocusKeyManager(this._items).withWrap();
                this._tabSubscription = this._keyManager.tabOut.subscribe(( /**
                 * @return {?}
                 */function () {
                    return _this.closed.emit('tab');
                }));
            };
        /**
         * @return {?}
         */
        SdsMenuComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._tabSubscription.unsubscribe();
                this.closed.complete();
            };
        /** Focus the first item in the menu */
        /**
         * Focus the first item in the menu
         * @param {?=} origin
         * @return {?}
         */
        SdsMenuComponent.prototype.focusFirstItem = /**
         * Focus the first item in the menu
         * @param {?=} origin
         * @return {?}
         */
            function (origin) {
                if (origin === void 0) {
                    origin = 'program';
                }
                this._keyManager.setFocusOrigin(origin).setFirstItemActive();
            };
        /** Adds classes to the menu panel based on its position */
        /**
         * Adds classes to the menu panel based on its position
         * @param {?=} posX
         * @param {?=} posY
         * @return {?}
         */
        SdsMenuComponent.prototype.setPositionClasses = /**
         * Adds classes to the menu panel based on its position
         * @param {?=} posX
         * @param {?=} posY
         * @return {?}
         */
            function (posX, posY) {
                if (posX === void 0) {
                    posX = this.xPosition;
                }
                if (posY === void 0) {
                    posY = this.yPosition;
                }
                /** @type {?} */
                var classes = this._classList;
                classes['sds-menu-before'] = posX === 'before';
                classes['sds-menu-after'] = posX === 'after';
                classes['sds-menu-above'] = posY === 'above';
                classes['sds-menu-below'] = posY === 'below';
            };
        /** Adds a menu item with the menu. */
        /**
         * Adds a menu item with the menu.
         * @param {?} item
         * @return {?}
         */
        SdsMenuComponent.prototype.addItem = /**
         * Adds a menu item with the menu.
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (this._items.indexOf(item) === -1) {
                    this._items.push(item);
                }
            };
        /** Inserts a menu item at an index */
        /**
         * Inserts a menu item at an index
         * @param {?} item
         * @param {?} index
         * @return {?}
         */
        SdsMenuComponent.prototype.insertItem = /**
         * Inserts a menu item at an index
         * @param {?} item
         * @param {?} index
         * @return {?}
         */
            function (item, index) {
                if (this._items.indexOf(item) === -1 && index < this._items.length) {
                    this._items.splice(index, 0, item);
                }
            };
        /** Removes an item from the menu. */
        /**
         * Removes an item from the menu.
         * @param {?} item
         * @return {?}
         */
        SdsMenuComponent.prototype.removeItem = /**
         * Removes an item from the menu.
         * @param {?} item
         * @return {?}
         */
            function (item) {
                /** @type {?} */
                var index = this._items.indexOf(item);
                if (this._items.indexOf(item) > -1) {
                    this._items.splice(index, 1);
                }
            };
        /** Handle a keyboard event from the menu */
        /**
         * Handle a keyboard event from the menu
         * @param {?} event
         * @return {?}
         */
        SdsMenuComponent.prototype._handleKeydown = /**
         * Handle a keyboard event from the menu
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // tslint:disable-next-line: deprecation
                /** @type {?} */
                var keyCode = event.keyCode;
                /** @type {?} */
                var manager = this._keyManager;
                switch (keyCode) {
                    case keycodes.ESCAPE:
                        this.closed.emit('keydown');
                        break;
                    case keycodes.HOME:
                    case keycodes.END:
                        if (!keycodes.hasModifierKey(event)) {
                            keyCode === keycodes.HOME
                                ? manager.setFirstItemActive()
                                : manager.setLastItemActive();
                            event.preventDefault();
                        }
                        break;
                    default:
                        if (keyCode === keycodes.UP_ARROW || keyCode === keycodes.DOWN_ARROW) {
                            manager.setFocusOrigin('keyboard');
                        }
                        manager.onKeydown(event);
                }
            };
        /** Starts the enter animation. */
        /**
         * Starts the enter animation.
         * @return {?}
         */
        SdsMenuComponent.prototype._startAnimation = /**
         * Starts the enter animation.
         * @return {?}
         */
            function () {
                this._panelAnimationState = 'enter';
            };
        /** Callback that is invoked when the panel animation completes. */
        /**
         * Callback that is invoked when the panel animation completes.
         * @param {?} event
         * @return {?}
         */
        SdsMenuComponent.prototype._onAnimationDone = /**
         * Callback that is invoked when the panel animation completes.
         * @param {?} event
         * @return {?}
         */
            function (event) { };
        /** Resets the panel animation to its initial state. */
        /**
         * Resets the panel animation to its initial state.
         * @return {?}
         */
        SdsMenuComponent.prototype._resetAnimation = /**
         * Resets the panel animation to its initial state.
         * @return {?}
         */
            function () {
                this._panelAnimationState = 'void';
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SdsMenuComponent.prototype._onAnimationStart = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // Scroll the content element to the top as soon as the animation starts.
                if (event.toState === 'enter' && this._keyManager.activeItemIndex === 0) {
                    event.element.scrollTop = 0;
                }
            };
        SdsMenuComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'sds-menu',
                        exportAs: 'sdsMenu',
                        template: "<ng-template>\n  <div\n    class=\"sds-overlay minw-menu maxw-mobile radius-overlay\"\n    [ngClass]=\"_classList\"\n    (keydown)=\"_handleKeydown($event)\"\n    (click)=\"closed.emit('click')\"\n    [@transformMenu]=\"_panelAnimationState\"\n    (@transformMenu.start)=\"_onAnimationStart($event)\"\n    (@transformMenu.done)=\"_onAnimationDone($event)\"\n    tabindex=\"-1\"\n    role=\"menu\"\n  >\n    <div class=\"sds-menu\" [class.sds-menu--small]=\"size === 'sm'\">\n      <ng-content></ng-content>\n    </div>\n  </div>\n</ng-template>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        encapsulation: core.ViewEncapsulation.None,
                        animations: [sdsMenuAnimations.transformMenu],
                        providers: [
                            { provide: SDS_MENU_TOKEN, useExisting: SdsMenuComponent }
                        ]
                    }] }
        ];
        /** @nocollapse */
        SdsMenuComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef }
            ];
        };
        SdsMenuComponent.propDecorators = {
            templateRef: [{ type: core.ViewChild, args: [core.TemplateRef,] }],
            size: [{ type: core.Input }],
            xPosition: [{ type: core.Input }],
            yPosition: [{ type: core.Input }],
            overlapTrigger: [{ type: core.Input }],
            panelClass: [{ type: core.Input, args: ['class',] }],
            closed: [{ type: core.Output }]
        };
        return SdsMenuComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SdsMenuHeaderComponent = /** @class */ (function () {
        function SdsMenuHeaderComponent() {
            this.hideClose = false;
        }
        SdsMenuHeaderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'sds-menu-header',
                        template: "<div class=\"sds-menu__header\">\n  <span class=\"sds-menu__header-title\"> <ng-content></ng-content> </span>\n  <button\n    *ngIf=\"!hideClose\"\n    aria-label=\"Close Menu\"\n    sds-menu-item\n    role=\"button\"\n  >\n  <fa-icon\n  [icon]=\"['fas', 'times']\"\n  [fixedWidth]=\"true\"\n></fa-icon>\n  </button>\n</div>\n"
                    }] }
        ];
        SdsMenuHeaderComponent.propDecorators = {
            hideClose: [{ type: core.Input }]
        };
        return SdsMenuHeaderComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SdsMenuItemComponent = /** @class */ (function () {
        function SdsMenuItemComponent(_elementRef, _focusMonitor, _parentMenu, _parentMenuHeader) {
            this._elementRef = _elementRef;
            this._focusMonitor = _focusMonitor;
            this._parentMenu = _parentMenu;
            this._parentMenuHeader = _parentMenuHeader;
            /**
             * Menu item class
             */
            this.class = this._getClass();
            /**
             * ARIA role for the menu item.
             */
            this.role = 'menuitem';
            /**
             * Menu item tab index
             */
            this.tabIndex = this.disabled ? '-1' : '0';
            /**
             * Holds the disable status value
             */
            this._disabled = false;
            // Start listening to focus changes
            _focusMonitor.monitor(this._elementRef, false);
            // Add this menu item to its parent menu
            // If item its inside a header
            // add it as the first item in the list
            if (_parentMenuHeader) {
                _parentMenu.insertItem(this, 0);
            }
            else {
                _parentMenu.addItem(this);
            }
        }
        Object.defineProperty(SdsMenuItemComponent.prototype, "disabled", {
            /** Whether the menu item should be disabled */
            get: /**
             * Whether the menu item should be disabled
             * @return {?}
             */ function () {
                return this._disabled;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._disabled = coercion.coerceBooleanProperty(value);
            },
            enumerable: true,
            configurable: true
        });
        /** Get item class */
        /**
         * Get item class
         * @return {?}
         */
        SdsMenuItemComponent.prototype._getClass = /**
         * Get item class
         * @return {?}
         */
            function () {
                /** @type {?} */
                var headerButtonSmall = this._parentMenu.size === 'sm' ? 'sds-button--small' : '';
                return this._parentMenuHeader
                    ? "sds-button sds-button--circular " + headerButtonSmall
                    : 'sds-menu__item';
            };
        /** Focuses the menu item. */
        /**
         * Focuses the menu item.
         * @param {?=} origin
         * @return {?}
         */
        SdsMenuItemComponent.prototype.focus = /**
         * Focuses the menu item.
         * @param {?=} origin
         * @return {?}
         */
            function (origin) {
                if (origin === void 0) {
                    origin = 'program';
                }
                this._focusMonitor.focusVia(this._elementRef.nativeElement, origin);
            };
        /** Stop listening to focus changes and remove item from parent */
        /**
         * Stop listening to focus changes and remove item from parent
         * @return {?}
         */
        SdsMenuItemComponent.prototype.ngOnDestroy = /**
         * Stop listening to focus changes and remove item from parent
         * @return {?}
         */
            function () {
                this._focusMonitor.stopMonitoring(this._elementRef);
                this._parentMenu.removeItem(this);
            };
        SdsMenuItemComponent.decorators = [
            { type: core.Component, args: [{
                        // tslint:disable-next-line: component-selector
                        selector: '[sds-menu-item]',
                        template: '<ng-content></ng-content>',
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        encapsulation: core.ViewEncapsulation.None
                    }] }
        ];
        /** @nocollapse */
        SdsMenuItemComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: a11y.FocusMonitor },
                { type: undefined, decorators: [{ type: core.Inject, args: [SDS_MENU_TOKEN,] }] },
                { type: SdsMenuHeaderComponent, decorators: [{ type: core.Optional }] }
            ];
        };
        SdsMenuItemComponent.propDecorators = {
            class: [{ type: core.HostBinding, args: ['class',] }],
            role: [{ type: core.HostBinding, args: ['attr.role',] }, { type: core.Input }],
            tabIndex: [{ type: core.HostBinding, args: ['attr.tabIndex',] }],
            disabled: [{ type: core.Input }]
        };
        return SdsMenuItemComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SdsMenuTriggerForDirective = /** @class */ (function () {
        function SdsMenuTriggerForDirective(_overlay, _element, _viewContainerRef, _focusMonitor) {
            var _this = this;
            this._overlay = _overlay;
            this._element = _element;
            this._viewContainerRef = _viewContainerRef;
            this._focusMonitor = _focusMonitor;
            /**
             * ARIA haspopup for the menu trigger.
             */
            this.ariaHasPopup = true;
            /**
             * Holds value for menuOpen variable
             */
            this._menuOpen = false;
            /**
             * PortalOutlet
             */
            this._overlayRef = null;
            /**
             * Tracks input type
             */
            this._openedBy = null;
            this._closingActionsSubscription = rxjs.Subscription.EMPTY;
            this._menuCloseSubscription = rxjs.Subscription.EMPTY;
            /**
             * Event emitted when the associated menu is opened.
             */
            this.menuOpened = new core.EventEmitter();
            /**
             * Event emitted when the associated menu is closed.
             */
            this.menuClosed = new core.EventEmitter();
            // On touch devices set _openedBy to 'touch'
            _element.nativeElement.addEventListener('touchstart', ( /**
             * @return {?}
             */function () { return (_this._openedBy = 'touch'); }), platform.normalizePassiveListenerOptions({ passive: true }));
        }
        Object.defineProperty(SdsMenuTriggerForDirective.prototype, "menuOpen", {
            /** ARIA expanded for the menu trigger. */
            get: /**
             * ARIA expanded for the menu trigger.
             * @return {?}
             */ function () {
                return this._menuOpen;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SdsMenuTriggerForDirective.prototype, "menu", {
            /** References the menu instance that the trigger is associated with. */
            get: /**
             * References the menu instance that the trigger is associated with.
             * @return {?}
             */ function () {
                return this._menu;
            },
            set: /**
             * @param {?} menu
             * @return {?}
             */ function (menu) {
                var _this = this;
                if (menu === this._menu) {
                    return;
                }
                this._menu = menu;
                this._menuCloseSubscription.unsubscribe();
                if (menu) {
                    this._menuCloseSubscription = menu.closed.asObservable().subscribe(( /**
                     * @return {?}
                     */function () {
                        _this._destroyMenu();
                    }));
                }
            },
            enumerable: true,
            configurable: true
        });
        /** Handles mouse presses on the trigger. */
        /**
         * Handles mouse presses on the trigger.
         * @param {?} event
         * @return {?}
         */
        SdsMenuTriggerForDirective.prototype._handleMousedown = /**
         * Handles mouse presses on the trigger.
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (!a11y.isFakeMousedownFromScreenReader(event)) {
                    // Since right or middle button clicks won't trigger the `click` event,
                    // we shouldn't consider the menu as opened by mouse in those cases.
                    this._openedBy = event.button === 0 ? 'mouse' : null;
                }
            };
        /** Toggles the menu between the open and closed states. */
        /**
         * Toggles the menu between the open and closed states.
         * @return {?}
         */
        SdsMenuTriggerForDirective.prototype.toggleMenu = /**
         * Toggles the menu between the open and closed states.
         * @return {?}
         */
            function () {
                return this._menuOpen ? this.closeMenu() : this.openMenu();
            };
        /**
         * @return {?}
         */
        SdsMenuTriggerForDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._overlayRef) {
                    this._overlayRef.dispose();
                    this._overlayRef = null;
                }
                this._element.nativeElement.removeEventListener('touchstart', ( /**
                 * @return {?}
                 */function () { return (_this._openedBy = 'touch'); }), platform.normalizePassiveListenerOptions({ passive: true }));
                this._menuCloseSubscription.unsubscribe();
                this._closingActionsSubscription.unsubscribe();
            };
        /** Opens the menu. */
        /**
         * Opens the menu.
         * @return {?}
         */
        SdsMenuTriggerForDirective.prototype.openMenu = /**
         * Opens the menu.
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._menuOpen) {
                    return;
                }
                /** @type {?} */
                var overlayRef = this._createOverlay();
                /** @type {?} */
                var overlayConfig = overlayRef.getConfig();
                this._setPosition(( /** @type {?} */(overlayConfig.positionStrategy)));
                overlayRef.attach(this._getPortal());
                this._closingActionsSubscription = this._menuClosingActions().subscribe(( /**
                 * @return {?}
                 */function () { return _this.closeMenu(); }));
                this._initMenu();
                if (this.menu instanceof SdsMenuComponent) {
                    this.menu._startAnimation();
                }
            };
        /** Closes the menu. */
        /**
         * Closes the menu.
         * @return {?}
         */
        SdsMenuTriggerForDirective.prototype.closeMenu = /**
         * Closes the menu.
         * @return {?}
         */
            function () {
                this.menu.closed.emit();
            };
        /** Focuses the menu trigger. */
        /**
         * Focuses the menu trigger.
         * @param {?=} origin
         * @return {?}
         */
        SdsMenuTriggerForDirective.prototype.focus = /**
         * Focuses the menu trigger.
         * @param {?=} origin
         * @return {?}
         */
            function (origin) {
                if (origin === void 0) {
                    origin = 'program';
                }
                this._focusMonitor.focusVia(this._element, origin);
            };
        /** This method sets the menu state to open and focuses the first item */
        /**
         * This method sets the menu state to open and focuses the first item
         * @private
         * @return {?}
         */
        SdsMenuTriggerForDirective.prototype._initMenu = /**
         * This method sets the menu state to open and focuses the first item
         * @private
         * @return {?}
         */
            function () {
                this._setIsMenuOpen(true);
                this.menu.focusFirstItem(this._openedBy || 'program');
            };
        /** sets open state */
        /**
         * sets open state
         * @private
         * @param {?} isOpen
         * @return {?}
         */
        SdsMenuTriggerForDirective.prototype._setIsMenuOpen = /**
         * sets open state
         * @private
         * @param {?} isOpen
         * @return {?}
         */
            function (isOpen) {
                this._menuOpen = isOpen;
                this._menuOpen ? this.menuOpened.emit() : this.menuClosed.emit();
            };
        /**
         * This method resets the menu when it's closed,
         * most importantly restoring focus to the menu trigger
         */
        /**
         * This method resets the menu when it's closed,
         * most importantly restoring focus to the menu trigger
         * @private
         * @return {?}
         */
        SdsMenuTriggerForDirective.prototype._resetMenu = /**
         * This method resets the menu when it's closed,
         * most importantly restoring focus to the menu trigger
         * @private
         * @return {?}
         */
            function () {
                this._setIsMenuOpen(false);
                if (!this._openedBy) {
                    this.focus();
                }
                else {
                    this.focus(this._openedBy);
                }
                this._openedBy = null;
            };
        /** Closes the menu and does the necessary cleanup. */
        /**
         * Closes the menu and does the necessary cleanup.
         * @private
         * @return {?}
         */
        SdsMenuTriggerForDirective.prototype._destroyMenu = /**
         * Closes the menu and does the necessary cleanup.
         * @private
         * @return {?}
         */
            function () {
                if (!this._overlayRef || !this.menuOpen) {
                    return;
                }
                this._closingActionsSubscription.unsubscribe();
                this._overlayRef.detach();
                if (this.menu instanceof SdsMenuComponent) {
                    this.menu._resetAnimation();
                    this._resetMenu();
                }
            };
        /**
         * This method creates the overlay from the provided menu's template and saves its
         * OverlayRef so that it can be attached to the DOM when openMenu is called.
         */
        /**
         * This method creates the overlay from the provided menu's template and saves its
         * OverlayRef so that it can be attached to the DOM when openMenu is called.
         * @private
         * @return {?}
         */
        SdsMenuTriggerForDirective.prototype._createOverlay = /**
         * This method creates the overlay from the provided menu's template and saves its
         * OverlayRef so that it can be attached to the DOM when openMenu is called.
         * @private
         * @return {?}
         */
            function () {
                if (!this._overlayRef) {
                    /** @type {?} */
                    var config = this._getOverlayConfig();
                    this._subscribeToPositions(( /** @type {?} */(config.positionStrategy)));
                    this._overlayRef = this._overlay.create(config);
                    this._overlayRef.keydownEvents().subscribe();
                }
                return this._overlayRef;
            };
        /**
         * This method builds the configuration object needed to create the overlay, the OverlayState.
         * @returns OverlayConfig
         */
        /**
         * This method builds the configuration object needed to create the overlay, the OverlayState.
         * @private
         * @return {?} OverlayConfig
         */
        SdsMenuTriggerForDirective.prototype._getOverlayConfig = /**
         * This method builds the configuration object needed to create the overlay, the OverlayState.
         * @private
         * @return {?} OverlayConfig
         */
            function () {
                return new overlay.OverlayConfig({
                    positionStrategy: this._overlay
                        .position()
                        .flexibleConnectedTo(this._element)
                        .withLockedPosition()
                        .withTransformOriginOn('.sds-overlay'),
                    hasBackdrop: true,
                    backdropClass: 'cdk-overlay-transparent-backdrop',
                    scrollStrategy: this._overlay.scrollStrategies.reposition()
                });
            };
        /**
         * Listens to changes in the position of the overlay and sets the correct classes
         * on the menu based on the new position.
         */
        /**
         * Listens to changes in the position of the overlay and sets the correct classes
         * on the menu based on the new position.
         * @private
         * @param {?} position
         * @return {?}
         */
        SdsMenuTriggerForDirective.prototype._subscribeToPositions = /**
         * Listens to changes in the position of the overlay and sets the correct classes
         * on the menu based on the new position.
         * @private
         * @param {?} position
         * @return {?}
         */
            function (position) {
                var _this = this;
                position.positionChanges.subscribe(( /**
                 * @param {?} change
                 * @return {?}
                 */function (change) {
                    /** @type {?} */
                    var posX = change.connectionPair.overlayX === 'start' ? 'after' : 'before';
                    /** @type {?} */
                    var posY = change.connectionPair.overlayY === 'top' ? 'below' : 'above';
                    _this.menu.setPositionClasses(posX, posY);
                }));
            };
        /**
         * Sets the appropriate positions on a position strategy
         * so the overlay connects with the trigger correctly.
         */
        /**
         * Sets the appropriate positions on a position strategy
         * so the overlay connects with the trigger correctly.
         * @private
         * @param {?} positionStrategy
         * @return {?}
         */
        SdsMenuTriggerForDirective.prototype._setPosition = /**
         * Sets the appropriate positions on a position strategy
         * so the overlay connects with the trigger correctly.
         * @private
         * @param {?} positionStrategy
         * @return {?}
         */
            function (positionStrategy) {
                var _a = __read(this.menu.xPosition === 'before' ? ['end', 'start'] : ['start', 'end'], 2), originX = _a[0], originFallbackX = _a[1];
                var _b = __read(this.menu.yPosition === 'above' ? ['bottom', 'top'] : ['top', 'bottom'], 2), overlayY = _b[0], overlayFallbackY = _b[1];
                var _c = __read([overlayY, overlayFallbackY], 2), originY = _c[0], originFallbackY = _c[1];
                var _d = __read([originX, originFallbackX], 2), overlayX = _d[0], overlayFallbackX = _d[1];
                /** @type {?} */
                var offsetY = 0;
                if (!this.menu.overlapTrigger) {
                    originY = overlayY === 'top' ? 'bottom' : 'top';
                    originFallbackY = overlayFallbackY === 'top' ? 'bottom' : 'top';
                }
                // Positions from most to least desirable
                positionStrategy.withPositions([
                    { originX: originX, originY: originY, overlayX: overlayX, overlayY: overlayY, offsetY: offsetY },
                    {
                        originX: originFallbackX,
                        originY: originY,
                        overlayX: overlayFallbackX,
                        overlayY: overlayY,
                        offsetY: offsetY
                    },
                    {
                        originX: originX,
                        originY: originFallbackY,
                        overlayX: overlayX,
                        overlayY: overlayFallbackY,
                        offsetY: -offsetY
                    },
                    {
                        originX: originFallbackX,
                        originY: originFallbackY,
                        overlayX: overlayFallbackX,
                        overlayY: overlayFallbackY,
                        offsetY: -offsetY
                    }
                ]);
            };
        /** Returns a stream that emits whenever an action that should close the menu occurs. */
        /**
         * Returns a stream that emits whenever an action that should close the menu occurs.
         * @private
         * @return {?}
         */
        SdsMenuTriggerForDirective.prototype._menuClosingActions = /**
         * Returns a stream that emits whenever an action that should close the menu occurs.
         * @private
         * @return {?}
         */
            function () {
                /** @type {?} */
                var backdrop = this._overlayRef.backdropClick();
                /** @type {?} */
                var detachments = this._overlayRef.detachments();
                return rxjs.merge(backdrop, detachments);
            };
        /** Gets the portal that should be attached to the overlay. */
        /**
         * Gets the portal that should be attached to the overlay.
         * @private
         * @return {?}
         */
        SdsMenuTriggerForDirective.prototype._getPortal = /**
         * Gets the portal that should be attached to the overlay.
         * @private
         * @return {?}
         */
            function () {
                if (!this._portal || this._portal.templateRef !== this.menu.templateRef) {
                    this._portal = new portal.TemplatePortal(this.menu.templateRef, this._viewContainerRef);
                }
                return this._portal;
            };
        SdsMenuTriggerForDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[sdsMenuTriggerFor]'
                    },] }
        ];
        /** @nocollapse */
        SdsMenuTriggerForDirective.ctorParameters = function () {
            return [
                { type: overlay.Overlay },
                { type: core.ElementRef },
                { type: core.ViewContainerRef },
                { type: a11y.FocusMonitor }
            ];
        };
        SdsMenuTriggerForDirective.propDecorators = {
            ariaHasPopup: [{ type: core.HostBinding, args: ['attr.aria-haspopup',] }],
            menuOpen: [{ type: core.HostBinding, args: ['attr.aria-expanded',] }],
            menu: [{ type: core.Input, args: ['sdsMenuTriggerFor',] }],
            menuOpened: [{ type: core.Output }],
            menuClosed: [{ type: core.Output }],
            _handleMousedown: [{ type: core.HostListener, args: ['mousedown', ['$event'],] }],
            toggleMenu: [{ type: core.HostListener, args: ['click',] }]
        };
        return SdsMenuTriggerForDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SdsMenuModule = /** @class */ (function () {
        function SdsMenuModule() {
        }
        SdsMenuModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, overlay.OverlayModule, angularFontawesome.FontAwesomeModule],
                        exports: [
                            SdsMenuComponent,
                            SdsMenuItemComponent,
                            SdsMenuTriggerForDirective,
                            SdsMenuHeaderComponent
                        ],
                        declarations: [
                            SdsMenuComponent,
                            SdsMenuItemComponent,
                            SdsMenuTriggerForDirective,
                            SdsMenuHeaderComponent
                        ],
                        providers: []
                    },] }
        ];
        return SdsMenuModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SearchSettings = /** @class */ (function () {
        function SearchSettings() {
            this.placeholder = 'Search';
            this.dropdown = {
                placeholder: '-Select-',
                options: [],
                inverse: false
            };
        }
        return SearchSettings;
    }());
    var SdsSearchComponent = /** @class */ (function () {
        function SdsSearchComponent(cd, focusMonitor, viewportRuler) {
            this.cd = cd;
            this.focusMonitor = focusMonitor;
            this.viewportRuler = viewportRuler;
            this.searchSettings = new SearchSettings();
            this.model = {};
            this.inputState = {
                initial: { visible: undefined },
                visible: undefined
            };
            this._onChange = ( /**
             * @param {?} _
             * @return {?}
             */function (_) { });
            this._onTouched = ( /**
             * @return {?}
             */function () { });
        }
        /**
         * @return {?}
         */
        SdsSearchComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.inputState.initial.visible = this.isInputVisible();
                this.inputState.visible = this.inputState.initial.visible;
                this.viewportRuler.change(0).subscribe(( /**
                 * @return {?}
                 */function () {
                    _this.inputState.initial.visible = _this.isInputVisible();
                    _this.inputState.visible = _this.inputState.initial.visible;
                }));
            };
        /**
         * @return {?}
         */
        SdsSearchComponent.prototype.hasDropdown = /**
         * @return {?}
         */
            function () {
                if (this.searchSettings &&
                    this.searchSettings.dropdown &&
                    this.searchSettings.dropdown.options &&
                    this.searchSettings.dropdown.options.length) {
                    return true;
                }
                else {
                    return false;
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SdsSearchComponent.prototype.handleClick = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                event.preventDefault();
                if (!this.inputState.visible) {
                    this.setInputVisibleStyles();
                    this.focusMonitor.focusVia(this.inputEl, 'program');
                }
                else if (this.inputEl.nativeElement.value || this.selectEl.nativeElement.value) {
                    this.model.searchText = this.inputEl.nativeElement.value;
                    if (this.selectEl && this.selectEl.nativeElement.value) {
                        this.model.searchCatergory = this.selectEl.nativeElement.value;
                    }
                    this._onChange(this.model);
                }
            };
        /**
         * @param {?} value
         * @return {?}
         */
        SdsSearchComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value && this.model !== value) {
                    this.model = value;
                    this.cd.markForCheck();
                }
                else {
                    this.model = {};
                    this.cd.markForCheck();
                }
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        SdsSearchComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this._onTouched = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        SdsSearchComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this._onChange = fn;
            };
        /**
         * @return {?}
         */
        SdsSearchComponent.prototype.isInputVisible = /**
         * @return {?}
         */
            function () {
                return this.inputEl.nativeElement.getBoundingClientRect().width
                    ? true
                    : false;
            };
        /**
         * @return {?}
         */
        SdsSearchComponent.prototype.setInputVisibleStyles = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var inputWidth = this.calculateInputWidth();
                this.inputEl.nativeElement.style.display = 'block';
                this.inputEl.nativeElement.style.position = 'absolute';
                this.inputEl.nativeElement.style.left = "-" + inputWidth + "px";
                this.inputEl.nativeElement.style.width = inputWidth + "px";
                this.inputState.visible = true;
            };
        /**
         * @return {?}
         */
        SdsSearchComponent.prototype.removeInputVisibleStyles = /**
         * @return {?}
         */
            function () {
                this.inputEl.nativeElement.style.display = '';
                this.inputEl.nativeElement.style.position = '';
                this.inputEl.nativeElement.style.left = '';
                this.inputEl.nativeElement.style.width = '';
                this.inputState.visible = false;
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SdsSearchComponent.prototype.focusChange = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (event === null && !this.inputState.initial.visible) {
                    this.removeInputVisibleStyles();
                }
            };
        /**
         * @return {?}
         */
        SdsSearchComponent.prototype.calculateInputWidth = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var buttonElement = this.buttonEl.nativeElement;
                /** @type {?} */
                var inputElement = this.inputEl.nativeElement;
                /** @type {?} */
                var rightPosition = buttonElement.getBoundingClientRect().left;
                /** @type {?} */
                var leftPosition = this.parentSelector
                    ? inputElement.closest(this.parentSelector).getBoundingClientRect().left
                    : 0;
                return Math.floor(rightPosition - leftPosition);
            };
        /**
         * @return {?}
         */
        SdsSearchComponent.prototype.getClass = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var cls = this.searchSettings && this.searchSettings.size === 'large'
                    ? 'usa-search--big'
                    : 'usa-search--small';
                return this.searchSettings.dropdown && this.searchSettings.dropdown.inverse
                    ? cls + " sds-inverse"
                    : cls;
            };
        SdsSearchComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'sds-search',
                        template: "<form class=\"usa-form usa-search\" [ngClass]=\"getClass()\" role=\"search\">\n  <label class=\"usa-sr-only\" for=\"options\">Dropdown label</label>\n  <select *ngIf=\"hasDropdown()\" [value]=\"model.searchCategory? model.searchCategory :''\" #selectEl name=\"search options\"\n    class=\"usa-select\" id=\"search-options\">\n    <option [value]=\"\"> {{searchSettings.dropdown.placeholder ? searchSettings.dropdown.placeholder : '-Select-'}}</option>\n    <ng-container *ngFor=\"let item of searchSettings.dropdown.options\">\n      <optgroup *ngIf=\"item.group\" label=\"{{item.label}}\">\n        <option *ngFor=\"let child of item.group\" [value]=\"child.value\" [selected]=\"model.searchCategory == child.value\"\n          [disabled]=\"child.disabled\">\n          {{ child.label }}\n        </option>\n      </optgroup>\n      <option *ngIf=\"!item.group\" [value]=\"item.value\" [selected]=\"model.searchCategory == item.value\" [disabled]=\"item.disabled\">{{\n        item.label }}</option>\n    </ng-container>\n  </select>\n  <ng-container *ngIf=\"(searchSettings.dropdown && searchSettings.dropdown.inverse); then inverseTemplate else inputTemplate\">\n  </ng-container>\n</form>\n\n<ng-template #inputTemplate> <label class=\"usa-sr-only\" for=\"search-field\">Search</label>\n  <input #inputEl [value]=\"model.searchText? model.searchText :''\" [ngClass]=\"inputClass\" id=\"search-field\" type=\"search\" class=\"usa-input\"\n    name=\"search\" [placeholder]=\"searchSettings.placeholder? searchSettings.placeholder : 'type here'\" />\n  <button class=\"usa-button\" type=\"submit\"  (click)=\"handleClick($event)\">\n    <span class=\"usa-sr-only\">Search</span>\n  </button>\n</ng-template>\n<ng-template #inverseTemplate>\n  <div class=\"sds-inverse__search\">\n    <ng-container [ngTemplateOutlet]=\"inputTemplate\"></ng-container>\n  </div>\n</ng-template>",
                        providers: [
                            {
                                provide: forms.NG_VALUE_ACCESSOR,
                                useExisting: core.forwardRef(( /**
                                 * @return {?}
                                 */function () { return SdsSearchComponent; })),
                                multi: true
                            }
                        ],
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        SdsSearchComponent.ctorParameters = function () {
            return [
                { type: core.ChangeDetectorRef },
                { type: a11y.FocusMonitor },
                { type: overlay.ViewportRuler }
            ];
        };
        SdsSearchComponent.propDecorators = {
            inputEl: [{ type: core.ViewChild, args: ['inputEl', { read: core.ElementRef },] }],
            selectEl: [{ type: core.ViewChild, args: ['selectEl', { read: core.ElementRef },] }],
            buttonEl: [{ type: core.ViewChild, args: ['buttonEl', { read: core.ElementRef },] }],
            inputClass: [{ type: core.Input }],
            parentSelector: [{ type: core.Input }],
            searchSettings: [{ type: core.Input }]
        };
        return SdsSearchComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SdsSearchModule = /** @class */ (function () {
        function SdsSearchModule() {
        }
        SdsSearchModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, a11y.A11yModule, forms.FormsModule],
                        exports: [SdsSearchComponent],
                        declarations: [SdsSearchComponent],
                        providers: []
                    },] }
        ];
        return SdsSearchModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Directive that triggers a callback whenever the width of
     * its associated element has changed.
     */
    var SdsObserveWidthDirective = /** @class */ (function () {
        function SdsObserveWidthDirective(_elementRef, viewportRuler) {
            this._elementRef = _elementRef;
            this.viewportRuler = viewportRuler;
            /**
             * Event emitted for each change in the element's width.
             */
            this.elementWidth = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        SdsObserveWidthDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.windowResize$ = this.viewportRuler
                    .change(0)
                    .pipe(operators.startWith(this._getElementWidth()))
                    .subscribe(( /**
             * @return {?}
             */function () { return _this._emitEvent(); }));
            };
        /**
         * @return {?}
         */
        SdsObserveWidthDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.windowResize$.unsubscribe();
            };
        /**
         * @return {?}
         */
        SdsObserveWidthDirective.prototype._emitEvent = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var width = this._getElementWidth();
                this.elementWidth.emit(width);
            };
        /**
         * @return {?}
         */
        SdsObserveWidthDirective.prototype._getElementWidth = /**
         * @return {?}
         */
            function () {
                return this._elementRef.nativeElement.offsetWidth;
            };
        SdsObserveWidthDirective.decorators = [
            { type: core.Directive, args: [{ selector: '[sdsObserveWidth]' },] }
        ];
        /** @nocollapse */
        SdsObserveWidthDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: overlay.ViewportRuler }
            ];
        };
        SdsObserveWidthDirective.propDecorators = {
            elementWidth: [{ type: core.Output, args: ['sdsObserveWidth',] }]
        };
        return SdsObserveWidthDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SdsObserversModule = /** @class */ (function () {
        function SdsObserversModule() {
        }
        SdsObserversModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [],
                        exports: [SdsObserveWidthDirective],
                        declarations: [SdsObserveWidthDirective],
                        providers: [],
                    },] }
        ];
        return SdsObserversModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Used primarily to avoid circular imports between `SdsAccordion` and `SdsAccordionItem`.
     * @type {?}
     */
    var SDS_TRUNCATED_TEXT_DATA = new core.InjectionToken('SdsTruncatedTextData');

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var sdsTruncateTextAnimations = {
        container: animations$1.trigger('container', [
            animations$1.state('void', animations$1.style({
                opacity: 0,
                transform: 'scale(0.8)'
            })),
            animations$1.transition('void => enter', animations$1.group([
                animations$1.query('.sds-overlay', animations$1.animate('100ms linear', animations$1.style({
                    opacity: 1
                }))),
                animations$1.animate('120ms cubic-bezier(0, 0, 0.2, 1)', animations$1.style({ transform: 'scale(1)' }))
            ])),
            animations$1.transition('* => void', animations$1.animate('100ms 25ms linear', animations$1.style({ opacity: 0 })))
        ])
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SdsTruncatedTextContainerComponent = /** @class */ (function () {
        function SdsTruncatedTextContainerComponent(data) {
            this.data = data;
            this._animationState = 'void';
        }
        /** Starts the animation. */
        /**
         * Starts the animation.
         * @return {?}
         */
        SdsTruncatedTextContainerComponent.prototype.startAnimation = /**
         * Starts the animation.
         * @return {?}
         */
            function () {
                this._animationState = 'enter';
            };
        /** Resets the animation to its initial state. */
        /**
         * Resets the animation to its initial state.
         * @return {?}
         */
        SdsTruncatedTextContainerComponent.prototype.resetAnimation = /**
         * Resets the animation to its initial state.
         * @return {?}
         */
            function () {
                this._animationState = 'void';
            };
        /** Intentionally left empty to trigger change detection */
        /**
         * Intentionally left empty to trigger change detection
         * @return {?}
         */
        SdsTruncatedTextContainerComponent.prototype._onAnimationDone = /**
         * Intentionally left empty to trigger change detection
         * @return {?}
         */
            function () { };
        SdsTruncatedTextContainerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'sds-truncated-text-container',
                        template: "\n    <div class=\"sds-overlay maxw-mobile radius-overlay padding-2\">{{ data.text }}</div>\n  ",
                        animations: [sdsTruncateTextAnimations.container]
                    }] }
        ];
        /** @nocollapse */
        SdsTruncatedTextContainerComponent.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: core.Inject, args: [SDS_TRUNCATED_TEXT_DATA,] }] }
            ];
        };
        SdsTruncatedTextContainerComponent.propDecorators = {
            _animationState: [{ type: core.HostBinding, args: ['@container',] }],
            _onAnimationDone: [{ type: core.HostListener, args: ['@container.done',] }]
        };
        return SdsTruncatedTextContainerComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SdsTruncateTextByLineDirective = /** @class */ (function () {
        function SdsTruncateTextByLineDirective(_overlay, _injector, _element, _viewportRuler, _viewContainerRef) {
            this._overlay = _overlay;
            this._injector = _injector;
            this._element = _element;
            this._viewportRuler = _viewportRuler;
            this._viewContainerRef = _viewContainerRef;
            /**
             * PortalOutlet
             */
            this._overlayRef = null;
            /**
             * Holds subscription to stream of overlay closing events
             */
            this._closingActionsSubscription = rxjs.Subscription.EMPTY;
        }
        Object.defineProperty(SdsTruncateTextByLineDirective.prototype, "textLinesLimit", {
            /** Maximum lines of text limit */
            get: /**
             * Maximum lines of text limit
             * @return {?}
             */ function () {
                return this._textLinesLimit;
            },
            set: /**
             * @param {?} _textLinesLimit
             * @return {?}
             */ function (_textLinesLimit) {
                _textLinesLimit = coercion.coerceNumberProperty(_textLinesLimit);
                if (this._textLinesLimit !== _textLinesLimit) {
                    this._textLinesLimit = _textLinesLimit;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SdsTruncateTextByLineDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.initialText = this._element.nativeElement.innerText.trim();
                // Clone element to facilitate calculations
                /** @type {?} */
                var hostCloneEl = ( /** @type {?} */(this._element.nativeElement.cloneNode()));
                // Add 1 character to calculate character width
                hostCloneEl.innerHTML = 'x';
                // Render the clone to get character width
                this._element.nativeElement.parentElement.appendChild(hostCloneEl);
                // Set the clone to inline to prevent cases where the clone
                // expands to 100% width of the container
                hostCloneEl.setAttribute('style', 'display: inline');
                // These are close approximations that are used to better guess
                // how many characters fit in X number of lines
                this.approximatedCharacterWidth = hostCloneEl.offsetWidth;
                // Remove clone after calculations
                hostCloneEl.remove();
            };
        /**
         * @return {?}
         */
        SdsTruncateTextByLineDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.windowResize$ = this._viewportRuler
                    .change(0)
                    .pipe(operators.startWith('Start'))
                    .subscribe(( /**
             * @return {?}
             */function () { return _this.updateUI(); }));
            };
        /**
         * @return {?}
         */
        SdsTruncateTextByLineDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (this._overlayRef) {
                    this._overlayRef.dispose();
                }
                this._closingActionsSubscription.unsubscribe();
                this.windowResize$.unsubscribe();
            };
        /** Configures and creates the CDK overlay */
        /**
         * Configures and creates the CDK overlay
         * @private
         * @return {?}
         */
        SdsTruncateTextByLineDirective.prototype._createOverlay = /**
         * Configures and creates the CDK overlay
         * @private
         * @return {?}
         */
            function () {
                /** @type {?} */
                var overlayPositions = {
                    originX: 'start',
                    originY: 'bottom',
                    overlayX: 'start',
                    overlayY: 'top'
                };
                /** @type {?} */
                var config = new overlay.OverlayConfig({
                    positionStrategy: this._overlay
                        .position()
                        .flexibleConnectedTo(this._element)
                        .withLockedPosition()
                        .withPositions([overlayPositions])
                        .withTransformOriginOn('.sds-overlay'),
                    hasBackdrop: true,
                    backdropClass: 'cdk-overlay-transparent-backdrop',
                    scrollStrategy: this._overlay.scrollStrategies.close()
                });
                return this._overlay.create(config);
            };
        /** Attach a ComponentPortal to the overlay **/
        /**
         * Attach a ComponentPortal to the overlay *
         * @private
         * @param {?} overlay
         * @return {?}
         */
        SdsTruncateTextByLineDirective.prototype._attachContainer = /**
         * Attach a ComponentPortal to the overlay *
         * @private
         * @param {?} overlay
         * @return {?}
         */
            function (overlay$$1) {
                /** @type {?} */
                var injector = new portal.PortalInjector(this._injector, new WeakMap([[SDS_TRUNCATED_TEXT_DATA, { text: this.initialText }]]));
                /** @type {?} */
                var containerPortal = new portal.ComponentPortal(SdsTruncatedTextContainerComponent, this._viewContainerRef, injector);
                /** @type {?} */
                var containerRef = overlay$$1.attach(containerPortal);
                return containerRef.instance;
            };
        /** Returns a stream that emits whenever an action that should close the overlay occurs. */
        /**
         * Returns a stream that emits whenever an action that should close the overlay occurs.
         * @private
         * @return {?}
         */
        SdsTruncateTextByLineDirective.prototype._overlayClosingActions = /**
         * Returns a stream that emits whenever an action that should close the overlay occurs.
         * @private
         * @return {?}
         */
            function () {
                /** @type {?} */
                var backdrop = this._overlayRef.backdropClick();
                /** @type {?} */
                var detachments = this._overlayRef.detachments();
                return rxjs.merge(backdrop, detachments);
            };
        /** Width of host element */
        /**
         * Width of host element
         * @private
         * @return {?}
         */
        SdsTruncateTextByLineDirective.prototype._getHostWidth = /**
         * Width of host element
         * @private
         * @return {?}
         */
            function () {
                return this._element.nativeElement.offsetWidth;
            };
        /** Approximated number of characters that are visible in the container */
        /**
         * Approximated number of characters that are visible in the container
         * @private
         * @return {?}
         */
        SdsTruncateTextByLineDirective.prototype._getVisibleCharacters = /**
         * Approximated number of characters that are visible in the container
         * @private
         * @return {?}
         */
            function () {
                return Math.floor((this._getHostWidth() / this.approximatedCharacterWidth) *
                    this.textLinesLimit);
            };
        /**
         * @private
         * @return {?}
         */
        SdsTruncateTextByLineDirective.prototype._isNotLongEnough = /**
         * @private
         * @return {?}
         */
            function () {
                return this._getVisibleCharacters() > this.initialText.length;
            };
        /**
         * @return {?}
         */
        SdsTruncateTextByLineDirective.prototype.openOverlay = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // Exit if all text can be visible in container
                if (this._isNotLongEnough())
                    return;
                this._overlayRef = this._createOverlay();
                /** @type {?} */
                var container = this._attachContainer(this._overlayRef);
                this._closingActionsSubscription = this._overlayClosingActions().subscribe(( /**
                 * @return {?}
                 */function () { return _this.closeOverlay(); }));
                // Wait for the next event loop tick to start the animation
                setTimeout(( /**
                 * @return {?}
                 */function () {
                    container.startAnimation();
                }));
            };
        /**
         * @return {?}
         */
        SdsTruncateTextByLineDirective.prototype.updateUI = /**
         * @return {?}
         */
            function () {
                // Exit if all text can be visible in container
                if (this._isNotLongEnough())
                    return;
                /** @type {?} */
                var ellipsis = '...';
                /** @type {?} */
                var limit = this._getVisibleCharacters() - ellipsis.length;
                /** @type {?} */
                var visibleText = this.initialText.slice(0, limit);
                {
                    /** @type {?} */
                    var isEndofWord = this.initialText.substr(limit, limit + 1) === ' ';
                    if (!isEndofWord) {
                        /** @type {?} */
                        var previousWord = visibleText.lastIndexOf(' ');
                        visibleText = visibleText.slice(0, previousWord);
                    }
                }
                this._element.nativeElement.innerText = visibleText + ellipsis;
            };
        /**
         * @return {?}
         */
        SdsTruncateTextByLineDirective.prototype.closeOverlay = /**
         * @return {?}
         */
            function () {
                this._closingActionsSubscription.unsubscribe();
                this._overlayRef.detach();
            };
        SdsTruncateTextByLineDirective.decorators = [
            { type: core.Directive, args: [{ selector: '[sdsTruncateTextByLine]' },] }
        ];
        /** @nocollapse */
        SdsTruncateTextByLineDirective.ctorParameters = function () {
            return [
                { type: overlay.Overlay },
                { type: core.Injector },
                { type: core.ElementRef },
                { type: overlay.ViewportRuler },
                { type: core.ViewContainerRef }
            ];
        };
        SdsTruncateTextByLineDirective.propDecorators = {
            textLinesLimit: [{ type: core.Input, args: ['sdsTruncateTextByLine',] }],
            openOverlay: [{ type: core.HostListener, args: ['click',] }]
        };
        return SdsTruncateTextByLineDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SdsTruncateModule = /** @class */ (function () {
        function SdsTruncateModule() {
        }
        SdsTruncateModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [],
                        exports: [SdsTruncateTextByLineDirective],
                        declarations: [
                            SdsTruncateTextByLineDirective,
                            SdsTruncatedTextContainerComponent
                        ],
                        providers: [],
                        entryComponents: [SdsTruncatedTextContainerComponent]
                    },] }
        ];
        return SdsTruncateModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Configuration for opening a modal dialog with the SdsDialog service.
     * @template D
     */
    var /**
     * Configuration for opening a modal dialog with the SdsDialog service.
     * @template D
     */ SdsDialogConfig = /** @class */ (function () {
        function SdsDialogConfig() {
            /**
             * The ARIA role of the dialog element.
             */
            this.role = 'dialog';
            /**
             * Custom class for the overlay pane.
             */
            this.panelClass = '';
            /**
             * Whether the dialog has a backdrop.
             */
            this.hasBackdrop = true;
            /**
             * Custom class for the backdrop,
             */
            this.backdropClass = '';
            /**
             * Whether the user can use escape or clicking on the backdrop to close the modal.
             */
            this.disableClose = false;
            /**
             * Width of the dialog.
             */
            this.width = '';
            /**
             * Height of the dialog.
             */
            this.height = '';
            /**
             * Max-width of the dialog. If a number is provided, pixel units are assumed. Defaults to 80vw
             */
            this.maxWidth = '80vw';
            /**
             * Data being injected into the child component.
             */
            this.data = null;
            /**
             * ID of the element that describes the dialog.
             */
            this.ariaDescribedBy = null;
            /**
             * Aria label to assign to the dialog element
             */
            this.ariaLabel = null;
            /**
             * Whether the dialog should focus the first focusable element on open.
             */
            this.autoFocus = true;
            /**
             * Whether the dialog should restore focus to the
             * previously-focused element, after it's closed.
             */
            this.restoreFocus = true;
            /**
             * Whether the dialog should close when the user goes backwards/forwards in history.
             * Note that this usually doesn't include clicking on links (unless the user is using
             * the `HashLocationStrategy`).
             */
            this.closeOnNavigation = true;
        }
        return SdsDialogConfig;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var animationBody = [
        // Note: The `enter` animation transitions to `transform: none`, because for some reason
        // specifying the transform explicitly, causes IE both to blur the dialog content and
        // decimate the animation performance. Leaving it as `none` solves both issues.
        animations$1.state('void, exit', animations$1.style({ opacity: 0, transform: 'scale(0.7)' })),
        animations$1.state('enter', animations$1.style({ transform: 'none' })),
        animations$1.transition('* => enter', animations$1.animate('150ms cubic-bezier(0, 0, 0.2, 1)', animations$1.style({ transform: 'none', opacity: 1 }))),
        animations$1.transition('* => void, * => exit', animations$1.animate('75ms cubic-bezier(0.4, 0.0, 0.2, 1)', animations$1.style({ opacity: 0 }))),
    ];
    /**
     * Animations used by SdsDialog.
     * \@docs-private
     * @type {?}
     */
    var sdsDialogAnimations = {
        /**
         * Animation that is applied on the dialog container by defalt.
         */
        dialogContainer: animations$1.trigger('dialogContainer', animationBody),
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Throws an exception for the case when a ComponentPortal is
     * attached to a DomPortalOutlet without an origin.
     * \@docs-private
     * @return {?}
     */
    function throwSdsDialogContentAlreadyAttachedError() {
        throw Error('Attempting to attach dialog content after content is already attached');
    }
    /**
     * Internal component that wraps user-provided dialog content.
     * \@docs-private
     */
    var SdsDialogContainerComponent = /** @class */ (function (_super) {
        __extends(SdsDialogContainerComponent, _super);
        function SdsDialogContainerComponent(_elementRef, _focusTrapFactory, _changeDetectorRef, _document, _config) {
            var _this = _super.call(this) || this;
            _this._elementRef = _elementRef;
            _this._focusTrapFactory = _focusTrapFactory;
            _this._changeDetectorRef = _changeDetectorRef;
            _this._document = _document;
            _this._config = _config;
            /**
             * Element that was focused before the dialog was opened. Save this to restore upon close.
             */
            _this._elementFocusedBeforeDialogWasOpened = null;
            /**
             * State of the dialog animation.
             */
            _this._state = 'enter';
            /**
             * Emits when an animation state changes.
             */
            _this._animationStateChanged = new core.EventEmitter();
            /**
             * ID of the element that should be considered as the dialog's label.
             */
            _this._ariaLabelledBy = null;
            return _this;
        }
        /**
         * Attach a ComponentPortal as content to this dialog container.
         * @param portal Portal to be attached as the dialog content.
         */
        /**
         * Attach a ComponentPortal as content to this dialog container.
         * @template T
         * @param {?} portal Portal to be attached as the dialog content.
         * @return {?}
         */
        SdsDialogContainerComponent.prototype.attachComponentPortal = /**
         * Attach a ComponentPortal as content to this dialog container.
         * @template T
         * @param {?} portal Portal to be attached as the dialog content.
         * @return {?}
         */
            function (portal$$1) {
                if (this._portalOutlet.hasAttached()) {
                    throwSdsDialogContentAlreadyAttachedError();
                }
                this._savePreviouslyFocusedElement();
                return this._portalOutlet.attachComponentPortal(portal$$1);
            };
        /**
         * Attach a TemplatePortal as content to this dialog container.
         * @param portal Portal to be attached as the dialog content.
         */
        /**
         * Attach a TemplatePortal as content to this dialog container.
         * @template C
         * @param {?} portal Portal to be attached as the dialog content.
         * @return {?}
         */
        SdsDialogContainerComponent.prototype.attachTemplatePortal = /**
         * Attach a TemplatePortal as content to this dialog container.
         * @template C
         * @param {?} portal Portal to be attached as the dialog content.
         * @return {?}
         */
            function (portal$$1) {
                if (this._portalOutlet.hasAttached()) {
                    throwSdsDialogContentAlreadyAttachedError();
                }
                this._savePreviouslyFocusedElement();
                return this._portalOutlet.attachTemplatePortal(portal$$1);
            };
        /** Moves the focus inside the focus trap. */
        /**
         * Moves the focus inside the focus trap.
         * @private
         * @return {?}
         */
        SdsDialogContainerComponent.prototype._trapFocus = /**
         * Moves the focus inside the focus trap.
         * @private
         * @return {?}
         */
            function () {
                if (!this._focusTrap) {
                    this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement);
                }
                // If were to attempt to focus immediately, then the content of the dialog would not yet be
                // ready in instances where change detection has to run first. To deal with this, we simply
                // wait for the microtask queue to be empty.
                if (this._config.autoFocus) {
                    this._focusTrap.focusInitialElementWhenReady();
                }
            };
        /** Restores focus to the element that was focused before the dialog opened. */
        /**
         * Restores focus to the element that was focused before the dialog opened.
         * @private
         * @return {?}
         */
        SdsDialogContainerComponent.prototype._restoreFocus = /**
         * Restores focus to the element that was focused before the dialog opened.
         * @private
         * @return {?}
         */
            function () {
                /** @type {?} */
                var toFocus = this._elementFocusedBeforeDialogWasOpened;
                // We need the extra check, because IE can set the `activeElement` to null in some cases.
                if (this._config.restoreFocus && toFocus && typeof toFocus.focus === 'function') {
                    toFocus.focus();
                }
                if (this._focusTrap) {
                    this._focusTrap.destroy();
                }
            };
        /** Saves a reference to the element that was focused before the dialog was opened. */
        /**
         * Saves a reference to the element that was focused before the dialog was opened.
         * @private
         * @return {?}
         */
        SdsDialogContainerComponent.prototype._savePreviouslyFocusedElement = /**
         * Saves a reference to the element that was focused before the dialog was opened.
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._document) {
                    this._elementFocusedBeforeDialogWasOpened = ( /** @type {?} */(this._document.activeElement));
                    // Note that there is no focus method when rendering on the server.
                    if (this._elementRef.nativeElement.focus) {
                        // Move focus onto the dialog immediately in order to prevent the user from accidentally
                        // opening multiple dialogs at the same time. Needs to be async, because the element
                        // may not be focusable immediately.
                        Promise.resolve().then(( /**
                         * @return {?}
                         */function () { return _this._elementRef.nativeElement.focus(); }));
                    }
                }
            };
        /** Callback, invoked whenever an animation on the host completes. */
        /**
         * Callback, invoked whenever an animation on the host completes.
         * @param {?} event
         * @return {?}
         */
        SdsDialogContainerComponent.prototype._onAnimationDone = /**
         * Callback, invoked whenever an animation on the host completes.
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (event.toState === 'enter') {
                    this._trapFocus();
                }
                else if (event.toState === 'exit') {
                    this._restoreFocus();
                }
                this._animationStateChanged.emit(event);
            };
        /** Callback, invoked when an animation on the host starts. */
        /**
         * Callback, invoked when an animation on the host starts.
         * @param {?} event
         * @return {?}
         */
        SdsDialogContainerComponent.prototype._onAnimationStart = /**
         * Callback, invoked when an animation on the host starts.
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this._animationStateChanged.emit(event);
            };
        /** Starts the dialog exit animation. */
        /**
         * Starts the dialog exit animation.
         * @return {?}
         */
        SdsDialogContainerComponent.prototype._startExitAnimation = /**
         * Starts the dialog exit animation.
         * @return {?}
         */
            function () {
                this._state = 'exit';
                // Mark the container for check so it can react if the
                // view container is using OnPush change detection.
                this._changeDetectorRef.markForCheck();
            };
        SdsDialogContainerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'sds-dialog-container',
                        template: "<button sds-dialog-close class=\"close-btn\">\n  <fa-icon [icon]=\"['fas', 'times']\"></fa-icon>\n</button>\n\n<!-- Alert Icons -->\n<div *ngIf=\"_config.alert\" [ngSwitch]=\"_config.alert\" class=\"sds-dialog-icon\">\n  <fa-icon *ngSwitchCase=\"'error'\" [icon]=\"['fas', 'ban']\" size=\"3x\"></fa-icon>\n  <fa-icon\n    *ngSwitchCase=\"'warning'\"\n    [icon]=\"['fas', 'exclamation-triangle']\"\n    size=\"3x\"\n  ></fa-icon>\n  <fa-icon\n    *ngSwitchCase=\"'info'\"\n    [icon]=\"['fas', 'info-circle']\"\n    size=\"3x\"\n  ></fa-icon>\n  <div *ngSwitchDefault>\n    Alert <em>{{ _config.alert }}</em> is not valid\n  </div>\n</div>\n\n<ng-template cdkPortalOutlet></ng-template>\n",
                        encapsulation: core.ViewEncapsulation.None,
                        // Using OnPush for dialogs caused some G3 sync issues. Disabled until we can track them down.
                        // tslint:disable-next-line:validate-decorators
                        changeDetection: core.ChangeDetectionStrategy.Default,
                        animations: [sdsDialogAnimations.dialogContainer],
                        // tslint:disable-next-line: use-host-property-decorator
                        host: {
                            'class': 'sds-dialog__container',
                            '[class.sds-dialog--alert]': '_config.alert',
                            '[class.sds-dialog--alert-error]': '_config.alert === "error"',
                            '[class.sds-dialog--alert-warning]': '_config.alert === "warning"',
                            '[class.sds-dialog--alert-info]': '_config.alert === "info"',
                            'tabindex': '-1',
                            'aria-modal': 'true',
                            '[attr.id]': '_id',
                            '[attr.role]': '_config.role',
                            '[attr.aria-labelledby]': '_config.ariaLabel ? null : _ariaLabelledBy',
                            '[attr.aria-label]': '_config.ariaLabel',
                            '[attr.aria-describedby]': '_config.ariaDescribedBy || null',
                            '[@dialogContainer]': '_state',
                            '(@dialogContainer.start)': '_onAnimationStart($event)',
                            '(@dialogContainer.done)': '_onAnimationDone($event)',
                        }
                    }] }
        ];
        /** @nocollapse */
        SdsDialogContainerComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: a11y.FocusTrapFactory },
                { type: core.ChangeDetectorRef },
                { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [common.DOCUMENT,] }] },
                { type: SdsDialogConfig }
            ];
        };
        SdsDialogContainerComponent.propDecorators = {
            _portalOutlet: [{ type: core.ViewChild, args: [portal.CdkPortalOutlet,] }]
        };
        return SdsDialogContainerComponent;
    }(portal.BasePortalOutlet));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // Counter for unique dialog ids.
    /** @type {?} */
    var uniqueId$2 = 0;
    /**
     * Reference to a dialog opened via the SdsDialog service.
     * @template T, R
     */
    var /**
     * Reference to a dialog opened via the SdsDialog service.
     * @template T, R
     */ SdsDialogRef = /** @class */ (function () {
        function SdsDialogRef(_overlayRef, _containerInstance, _location, id) {
            if (id === void 0) {
                id = "sds-dialog-" + uniqueId$2++;
            }
            var _this = this;
            this._overlayRef = _overlayRef;
            this._containerInstance = _containerInstance;
            this.id = id;
            /**
             * Whether the user is allowed to close the dialog.
             */
            this.disableClose = this._containerInstance._config.disableClose;
            /**
             * Subject for notifying the user that the dialog has finished opening.
             */
            this._afterOpened = new rxjs.Subject();
            /**
             * Subject for notifying the user that the dialog has finished closing.
             */
            this._afterClosed = new rxjs.Subject();
            /**
             * Subject for notifying the user that the dialog has started closing.
             */
            this._beforeClosed = new rxjs.Subject();
            // Pass the id along to the container.
            _containerInstance._id = id;
            // Emit when opening animation completes
            _containerInstance._animationStateChanged.pipe(operators.filter(( /**
             * @param {?} event
             * @return {?}
             */function (event) { return event.phaseName === 'done' && event.toState === 'enter'; })), operators.take(1))
                .subscribe(( /**
         * @return {?}
         */function () {
                _this._afterOpened.next();
                _this._afterOpened.complete();
            }));
            // Dispose overlay when closing animation is complete
            _containerInstance._animationStateChanged.pipe(operators.filter(( /**
             * @param {?} event
             * @return {?}
             */function (event) { return event.phaseName === 'done' && event.toState === 'exit'; })), operators.take(1)).subscribe(( /**
             * @return {?}
             */function () { return _this._overlayRef.dispose(); }));
            _overlayRef.detachments().subscribe(( /**
             * @return {?}
             */function () {
                _this._beforeClosed.next(_this._result);
                _this._beforeClosed.complete();
                _this._afterClosed.next(_this._result);
                _this._afterClosed.complete();
                _this.componentInstance = ( /** @type {?} */(null));
                _this._overlayRef.dispose();
            }));
            _overlayRef.keydownEvents()
                .pipe(operators.filter(( /**
         * @param {?} event
         * @return {?}
         */function (event) { return event.keyCode === keycodes.ESCAPE && !_this.disableClose; })))
                .subscribe(( /**
         * @return {?}
         */function () { return _this.close(); }));
        }
        /**
         * Close the dialog.
         * @param dialogResult Optional result to return to the dialog opener.
         */
        /**
         * Close the dialog.
         * @param {?=} dialogResult Optional result to return to the dialog opener.
         * @return {?}
         */
        SdsDialogRef.prototype.close = /**
         * Close the dialog.
         * @param {?=} dialogResult Optional result to return to the dialog opener.
         * @return {?}
         */
            function (dialogResult) {
                var _this = this;
                this._result = dialogResult;
                // Transition the backdrop in parallel to the dialog.
                this._containerInstance._animationStateChanged.pipe(operators.filter(( /**
                 * @param {?} event
                 * @return {?}
                 */function (event) { return event.phaseName === 'start'; })), operators.take(1))
                    .subscribe(( /**
             * @return {?}
             */function () {
                    _this._beforeClosed.next(dialogResult);
                    _this._beforeClosed.complete();
                    _this._overlayRef.detachBackdrop();
                }));
                this._containerInstance._startExitAnimation();
            };
        /**
         * Gets an observable that is notified when the dialog is finished opening.
         */
        /**
         * Gets an observable that is notified when the dialog is finished opening.
         * @return {?}
         */
        SdsDialogRef.prototype.afterOpened = /**
         * Gets an observable that is notified when the dialog is finished opening.
         * @return {?}
         */
            function () {
                return this._afterOpened.asObservable();
            };
        /**
         * Gets an observable that is notified when the dialog is finished closing.
         */
        /**
         * Gets an observable that is notified when the dialog is finished closing.
         * @return {?}
         */
        SdsDialogRef.prototype.afterClosed = /**
         * Gets an observable that is notified when the dialog is finished closing.
         * @return {?}
         */
            function () {
                return this._afterClosed.asObservable();
            };
        /**
         * Gets an observable that is notified when the dialog has started closing.
         */
        /**
         * Gets an observable that is notified when the dialog has started closing.
         * @return {?}
         */
        SdsDialogRef.prototype.beforeClosed = /**
         * Gets an observable that is notified when the dialog has started closing.
         * @return {?}
         */
            function () {
                return this._beforeClosed.asObservable();
            };
        /**
         * Gets an observable that emits when the overlay's backdrop has been clicked.
         */
        /**
         * Gets an observable that emits when the overlay's backdrop has been clicked.
         * @return {?}
         */
        SdsDialogRef.prototype.backdropClick = /**
         * Gets an observable that emits when the overlay's backdrop has been clicked.
         * @return {?}
         */
            function () {
                return this._overlayRef.backdropClick();
            };
        /**
         * Gets an observable that emits when keydown events are targeted on the overlay.
         */
        /**
         * Gets an observable that emits when keydown events are targeted on the overlay.
         * @return {?}
         */
        SdsDialogRef.prototype.keydownEvents = /**
         * Gets an observable that emits when keydown events are targeted on the overlay.
         * @return {?}
         */
            function () {
                return this._overlayRef.keydownEvents();
            };
        /**
         * Updates the dialog's position.
         * @param position New dialog position.
         */
        /**
         * Updates the dialog's position.
         * @template THIS
         * @this {THIS}
         * @param {?=} position New dialog position.
         * @return {THIS}
         */
        SdsDialogRef.prototype.updatePosition = /**
         * Updates the dialog's position.
         * @template THIS
         * @this {THIS}
         * @param {?=} position New dialog position.
         * @return {THIS}
         */
            function (position) {
                /** @type {?} */
                var strategy = ( /** @type {?} */(this))._getPositionStrategy();
                if (position && (position.left || position.right)) {
                    position.left ? strategy.left(position.left) : strategy.right(position.right);
                }
                else {
                    strategy.centerHorizontally();
                }
                if (position && (position.top || position.bottom)) {
                    position.top ? strategy.top(position.top) : strategy.bottom(position.bottom);
                }
                else {
                    strategy.centerVertically();
                }
                ( /** @type {?} */(this))._overlayRef.updatePosition();
                return ( /** @type {?} */(this));
            };
        /**
         * Updates the dialog's width and height.
         * @param width New width of the dialog.
         * @param height New height of the dialog.
         */
        /**
         * Updates the dialog's width and height.
         * @template THIS
         * @this {THIS}
         * @param {?=} width New width of the dialog.
         * @param {?=} height New height of the dialog.
         * @return {THIS}
         */
        SdsDialogRef.prototype.updateSize = /**
         * Updates the dialog's width and height.
         * @template THIS
         * @this {THIS}
         * @param {?=} width New width of the dialog.
         * @param {?=} height New height of the dialog.
         * @return {THIS}
         */
            function (width, height) {
                if (width === void 0) {
                    width = '';
                }
                if (height === void 0) {
                    height = '';
                }
                ( /** @type {?} */(this))._getPositionStrategy().width(width).height(height);
                ( /** @type {?} */(this))._overlayRef.updatePosition();
                return ( /** @type {?} */(this));
            };
        /** Add a CSS class or an array of classes to the overlay pane. */
        /**
         * Add a CSS class or an array of classes to the overlay pane.
         * @template THIS
         * @this {THIS}
         * @param {?} classes
         * @return {THIS}
         */
        SdsDialogRef.prototype.addPanelClass = /**
         * Add a CSS class or an array of classes to the overlay pane.
         * @template THIS
         * @this {THIS}
         * @param {?} classes
         * @return {THIS}
         */
            function (classes) {
                ( /** @type {?} */(this))._overlayRef.addPanelClass(classes);
                return ( /** @type {?} */(this));
            };
        /** Remove a CSS class or an array of classes from the overlay pane. */
        /**
         * Remove a CSS class or an array of classes from the overlay pane.
         * @template THIS
         * @this {THIS}
         * @param {?} classes
         * @return {THIS}
         */
        SdsDialogRef.prototype.removePanelClass = /**
         * Remove a CSS class or an array of classes from the overlay pane.
         * @template THIS
         * @this {THIS}
         * @param {?} classes
         * @return {THIS}
         */
            function (classes) {
                ( /** @type {?} */(this))._overlayRef.removePanelClass(classes);
                return ( /** @type {?} */(this));
            };
        /** Fetches the position strategy object from the overlay ref. */
        /**
         * Fetches the position strategy object from the overlay ref.
         * @private
         * @return {?}
         */
        SdsDialogRef.prototype._getPositionStrategy = /**
         * Fetches the position strategy object from the overlay ref.
         * @private
         * @return {?}
         */
            function () {
                return ( /** @type {?} */(this._overlayRef.getConfig().positionStrategy));
            };
        return SdsDialogRef;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Injection token that can be used to access the data that was passed in to a dialog.
     * @type {?}
     */
    var SDS_DIALOG_DATA = new core.InjectionToken('SdsDialogData');
    /**
     * Injection token that can be used to specify default dialog options.
     * @type {?}
     */
    var SDS_DIALOG_DEFAULT_OPTIONS = new core.InjectionToken('sds-dialog-default-options');
    /**
     * Injection token that determines the scroll handling while the dialog is open.
     * @type {?}
     */
    var SDS_DIALOG_SCROLL_STRATEGY = new core.InjectionToken('sds-dialog-scroll-strategy');
    /**
     * \@docs-private
     * @param {?} overlay
     * @return {?}
     */
    function SDS_DIALOG_SCROLL_STRATEGY_FACTORY(overlay$$1) {
        return ( /**
         * @return {?}
         */function () { return overlay$$1.scrollStrategies.block(); });
    }
    /**
     * \@docs-private
     * @param {?} overlay
     * @return {?}
     */
    function SDS_DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay$$1) {
        return ( /**
         * @return {?}
         */function () { return overlay$$1.scrollStrategies.block(); });
    }
    /**
     * \@docs-private
     * @type {?}
     */
    var SDS_DIALOG_SCROLL_STRATEGY_PROVIDER = {
        provide: SDS_DIALOG_SCROLL_STRATEGY,
        deps: [overlay.Overlay],
        useFactory: SDS_DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY,
    };
    /**
     * Service to open modal dialogs.
     */
    var SdsDialogService = /** @class */ (function () {
        function SdsDialogService(_overlay, _injector, _location, _defaultOptions, scrollStrategy, _parentDialog, _overlayContainer) {
            var _this = this;
            this._overlay = _overlay;
            this._injector = _injector;
            this._location = _location;
            this._defaultOptions = _defaultOptions;
            this._parentDialog = _parentDialog;
            this._overlayContainer = _overlayContainer;
            this._openDialogsAtThisLevel = [];
            this._afterAllClosedAtThisLevel = new rxjs.Subject();
            this._afterOpenedAtThisLevel = new rxjs.Subject();
            this._ariaHiddenElements = new Map();
            /**
             * Stream that emits when all open dialog have finished closing.
             * Will emit on subscribe if there are no open dialogs to begin with.
             */
            this.afterAllClosed = rxjs.defer(( /**
             * @return {?}
             */function () {
                return _this.openDialogs.length ?
                    _this._afterAllClosed :
                    _this._afterAllClosed.pipe(operators.startWith(undefined));
            }));
            this._scrollStrategy = scrollStrategy;
        }
        Object.defineProperty(SdsDialogService.prototype, "openDialogs", {
            /** Keeps track of the currently-open dialogs. */
            get: /**
             * Keeps track of the currently-open dialogs.
             * @return {?}
             */ function () {
                return this._parentDialog ? this._parentDialog.openDialogs : this._openDialogsAtThisLevel;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SdsDialogService.prototype, "afterOpened", {
            /** Stream that emits when a dialog has been opened. */
            get: /**
             * Stream that emits when a dialog has been opened.
             * @return {?}
             */ function () {
                return this._parentDialog ? this._parentDialog.afterOpened : this._afterOpenedAtThisLevel;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SdsDialogService.prototype, "_afterAllClosed", {
            get: /**
             * @return {?}
             */ function () {
                /** @type {?} */
                var parent = this._parentDialog;
                return parent ? parent._afterAllClosed : this._afterAllClosedAtThisLevel;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Opens a modal dialog containing the given component.
         * @param componentOrTemplateRef Type of the component to load into the dialog,
         *     or a TemplateRef to instantiate as the dialog content.
         * @param config Extra configuration options.
         * @returns Reference to the newly-opened dialog.
         */
        /**
         * Opens a modal dialog containing the given component.
         * @template T, D, R
         * @param {?} componentOrTemplateRef Type of the component to load into the dialog,
         *     or a TemplateRef to instantiate as the dialog content.
         * @param {?=} config Extra configuration options.
         * @return {?} Reference to the newly-opened dialog.
         */
        SdsDialogService.prototype.open = /**
         * Opens a modal dialog containing the given component.
         * @template T, D, R
         * @param {?} componentOrTemplateRef Type of the component to load into the dialog,
         *     or a TemplateRef to instantiate as the dialog content.
         * @param {?=} config Extra configuration options.
         * @return {?} Reference to the newly-opened dialog.
         */
            function (componentOrTemplateRef, config) {
                var _this = this;
                // Convenience widths names: small | medium | large
                // added to help with standardization
                if (config && config.width) {
                    switch (config.width) {
                        case 'small': {
                            config.width = '370px';
                            break;
                        }
                        case 'medium': {
                            config.width = '730px';
                            break;
                        }
                        case 'large': {
                            config.width = '960px';
                            break;
                        }
                        default: {
                            break;
                        }
                    }
                }
                config = _applyConfigDefaults(config, this._defaultOptions || new SdsDialogConfig());
                if (config.id && this.getDialogById(config.id)) {
                    throw Error("Dialog with id \"" + config.id + "\" exists already. The dialog id must be unique.");
                }
                /** @type {?} */
                var overlayRef = this._createOverlay(config);
                /** @type {?} */
                var dialogContainer = this._attachDialogContainer(overlayRef, config);
                /** @type {?} */
                var dialogRef = this._attachDialogContent(componentOrTemplateRef, dialogContainer, overlayRef, config);
                // If this is the first dialog that we're opening, hide all the non-overlay content.
                if (!this.openDialogs.length) {
                    this._hideNonDialogContentFromAssistiveTechnology();
                }
                this.openDialogs.push(dialogRef);
                dialogRef.afterClosed().subscribe(( /**
                 * @return {?}
                 */function () { return _this._removeOpenDialog(dialogRef); }));
                this.afterOpened.next(dialogRef);
                return dialogRef;
            };
        /**
         * Closes all of the currently-open dialogs.
         */
        /**
         * Closes all of the currently-open dialogs.
         * @return {?}
         */
        SdsDialogService.prototype.closeAll = /**
         * Closes all of the currently-open dialogs.
         * @return {?}
         */
            function () {
                this._closeDialogs(this.openDialogs);
            };
        /**
         * Finds an open dialog by its id.
         * @param id ID to use when looking up the dialog.
         */
        /**
         * Finds an open dialog by its id.
         * @param {?} id ID to use when looking up the dialog.
         * @return {?}
         */
        SdsDialogService.prototype.getDialogById = /**
         * Finds an open dialog by its id.
         * @param {?} id ID to use when looking up the dialog.
         * @return {?}
         */
            function (id) {
                return this.openDialogs.find(( /**
                 * @param {?} dialog
                 * @return {?}
                 */function (dialog) { return dialog.id === id; }));
            };
        /**
         * @return {?}
         */
        SdsDialogService.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                // Only close the dialogs at this level on destroy
                // since the parent service may still be active.
                this._closeDialogs(this._openDialogsAtThisLevel);
                this._afterAllClosedAtThisLevel.complete();
                this._afterOpenedAtThisLevel.complete();
            };
        /**
         * Creates the overlay into which the dialog will be loaded.
         * @param config The dialog configuration.
         * @returns A promise resolving to the OverlayRef for the created overlay.
         */
        /**
         * Creates the overlay into which the dialog will be loaded.
         * @private
         * @param {?} config The dialog configuration.
         * @return {?} A promise resolving to the OverlayRef for the created overlay.
         */
        SdsDialogService.prototype._createOverlay = /**
         * Creates the overlay into which the dialog will be loaded.
         * @private
         * @param {?} config The dialog configuration.
         * @return {?} A promise resolving to the OverlayRef for the created overlay.
         */
            function (config) {
                /** @type {?} */
                var overlayConfig = this._getOverlayConfig(config);
                return this._overlay.create(overlayConfig);
            };
        /**
         * Creates an overlay config from a dialog config.
         * @param dialogConfig The dialog configuration.
         * @returns The overlay configuration.
         */
        /**
         * Creates an overlay config from a dialog config.
         * @private
         * @param {?} dialogConfig The dialog configuration.
         * @return {?} The overlay configuration.
         */
        SdsDialogService.prototype._getOverlayConfig = /**
         * Creates an overlay config from a dialog config.
         * @private
         * @param {?} dialogConfig The dialog configuration.
         * @return {?} The overlay configuration.
         */
            function (dialogConfig) {
                /** @type {?} */
                var state = new overlay.OverlayConfig({
                    positionStrategy: this._overlay.position().global(),
                    scrollStrategy: dialogConfig.scrollStrategy || this._scrollStrategy(),
                    panelClass: dialogConfig.panelClass,
                    hasBackdrop: dialogConfig.hasBackdrop,
                    direction: dialogConfig.direction,
                    minWidth: dialogConfig.minWidth,
                    minHeight: dialogConfig.minHeight,
                    maxWidth: dialogConfig.maxWidth,
                    maxHeight: dialogConfig.maxHeight,
                    disposeOnNavigation: dialogConfig.closeOnNavigation
                });
                if (dialogConfig.backdropClass) {
                    state.backdropClass = dialogConfig.backdropClass;
                }
                return state;
            };
        /**
         * Attaches an SdsDialogContainerComponent to a dialog's already-created overlay.
         * @param overlay Reference to the dialog's underlying overlay.
         * @param config The dialog configuration.
         * @returns A promise resolving to a ComponentRef for the attached container.
         */
        /**
         * Attaches an SdsDialogContainerComponent to a dialog's already-created overlay.
         * @private
         * @param {?} overlay Reference to the dialog's underlying overlay.
         * @param {?} config The dialog configuration.
         * @return {?} A promise resolving to a ComponentRef for the attached container.
         */
        SdsDialogService.prototype._attachDialogContainer = /**
         * Attaches an SdsDialogContainerComponent to a dialog's already-created overlay.
         * @private
         * @param {?} overlay Reference to the dialog's underlying overlay.
         * @param {?} config The dialog configuration.
         * @return {?} A promise resolving to a ComponentRef for the attached container.
         */
            function (overlay$$1, config) {
                /** @type {?} */
                var userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
                /** @type {?} */
                var injector = new portal.PortalInjector(userInjector || this._injector, new WeakMap([
                    [SdsDialogConfig, config]
                ]));
                /** @type {?} */
                var containerPortal = new portal.ComponentPortal(SdsDialogContainerComponent, config.viewContainerRef, injector);
                /** @type {?} */
                var containerRef = overlay$$1.attach(containerPortal);
                return containerRef.instance;
            };
        /**
         * Attaches the user-provided component to the already-created SdsDialogContainerComponent.
         * @param componentOrTemplateRef The type of component being loaded into the dialog,
         *     or a TemplateRef to instantiate as the content.
         * @param dialogContainer Reference to the wrapping SdsDialogContainerComponent.
         * @param overlayRef Reference to the overlay in which the dialog resides.
         * @param config The dialog configuration.
         * @returns A promise resolving to the SdsDialogRef that should be returned to the user.
         */
        /**
         * Attaches the user-provided component to the already-created SdsDialogContainerComponent.
         * @private
         * @template T, R
         * @param {?} componentOrTemplateRef The type of component being loaded into the dialog,
         *     or a TemplateRef to instantiate as the content.
         * @param {?} dialogContainer Reference to the wrapping SdsDialogContainerComponent.
         * @param {?} overlayRef Reference to the overlay in which the dialog resides.
         * @param {?} config The dialog configuration.
         * @return {?} A promise resolving to the SdsDialogRef that should be returned to the user.
         */
        SdsDialogService.prototype._attachDialogContent = /**
         * Attaches the user-provided component to the already-created SdsDialogContainerComponent.
         * @private
         * @template T, R
         * @param {?} componentOrTemplateRef The type of component being loaded into the dialog,
         *     or a TemplateRef to instantiate as the content.
         * @param {?} dialogContainer Reference to the wrapping SdsDialogContainerComponent.
         * @param {?} overlayRef Reference to the overlay in which the dialog resides.
         * @param {?} config The dialog configuration.
         * @return {?} A promise resolving to the SdsDialogRef that should be returned to the user.
         */
            function (componentOrTemplateRef, dialogContainer, overlayRef, config) {
                // Create a reference to the dialog we're creating in order to give the user a handle
                // to modify and close it.
                /** @type {?} */
                var dialogRef = new SdsDialogRef(overlayRef, dialogContainer, this._location, config.id);
                // When the dialog backdrop is clicked, we want to close it.
                if (config.hasBackdrop) {
                    overlayRef.backdropClick().subscribe(( /**
                     * @return {?}
                     */function () {
                        if (!dialogRef.disableClose) {
                            dialogRef.close();
                        }
                    }));
                }
                if (componentOrTemplateRef instanceof core.TemplateRef) {
                    dialogContainer.attachTemplatePortal(new portal.TemplatePortal(componentOrTemplateRef, ( /** @type {?} */(null)), ( /** @type {?} */({ $implicit: config.data, dialogRef: dialogRef }))));
                }
                else {
                    /** @type {?} */
                    var injector = this._createInjector(config, dialogRef, dialogContainer);
                    /** @type {?} */
                    var contentRef = dialogContainer.attachComponentPortal(new portal.ComponentPortal(componentOrTemplateRef, undefined, injector));
                    dialogRef.componentInstance = contentRef.instance;
                }
                dialogRef
                    .updateSize(config.width, config.height)
                    .updatePosition(config.position);
                return dialogRef;
            };
        /**
         * Creates a custom injector to be used inside the dialog. This allows a component loaded inside
         * of a dialog to close itself and, optionally, to return a value.
         * @param config Config object that is used to construct the dialog.
         * @param dialogRef Reference to the dialog.
         * @param container Dialog container element that wraps all of the contents.
         * @returns The custom injector that can be used inside the dialog.
         */
        /**
         * Creates a custom injector to be used inside the dialog. This allows a component loaded inside
         * of a dialog to close itself and, optionally, to return a value.
         * @private
         * @template T
         * @param {?} config Config object that is used to construct the dialog.
         * @param {?} dialogRef Reference to the dialog.
         * @param {?} dialogContainer
         * @return {?} The custom injector that can be used inside the dialog.
         */
        SdsDialogService.prototype._createInjector = /**
         * Creates a custom injector to be used inside the dialog. This allows a component loaded inside
         * of a dialog to close itself and, optionally, to return a value.
         * @private
         * @template T
         * @param {?} config Config object that is used to construct the dialog.
         * @param {?} dialogRef Reference to the dialog.
         * @param {?} dialogContainer
         * @return {?} The custom injector that can be used inside the dialog.
         */
            function (config, dialogRef, dialogContainer) {
                /** @type {?} */
                var userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
                // The SdsDialogContainerComponent is injected in the portal as the SdsDialogContainerComponent and the dialog's
                // content are created out of the same ViewContainerRef and as such, are siblings for injector
                // purposes. To allow the hierarchy that is expected, the SdsDialogContainerComponent is explicitly
                // added to the injection tokens.
                /** @type {?} */
                var injectionTokens = new WeakMap([
                    [SdsDialogContainerComponent, dialogContainer],
                    [SDS_DIALOG_DATA, config.data],
                    [SdsDialogRef, dialogRef]
                ]);
                if (config.direction &&
                    (!userInjector || !userInjector.get(bidi.Directionality, null))) {
                    injectionTokens.set(bidi.Directionality, {
                        value: config.direction,
                        change: rxjs.of()
                    });
                }
                return new portal.PortalInjector(userInjector || this._injector, injectionTokens);
            };
        /**
         * Removes a dialog from the array of open dialogs.
         * @param dialogRef Dialog to be removed.
         */
        /**
         * Removes a dialog from the array of open dialogs.
         * @private
         * @param {?} dialogRef Dialog to be removed.
         * @return {?}
         */
        SdsDialogService.prototype._removeOpenDialog = /**
         * Removes a dialog from the array of open dialogs.
         * @private
         * @param {?} dialogRef Dialog to be removed.
         * @return {?}
         */
            function (dialogRef) {
                /** @type {?} */
                var index = this.openDialogs.indexOf(dialogRef);
                if (index > -1) {
                    this.openDialogs.splice(index, 1);
                    // If all the dialogs were closed, remove/restore the `aria-hidden`
                    // to a the siblings and emit to the `afterAllClosed` stream.
                    if (!this.openDialogs.length) {
                        this._ariaHiddenElements.forEach(( /**
                         * @param {?} previousValue
                         * @param {?} element
                         * @return {?}
                         */function (previousValue, element) {
                            if (previousValue) {
                                element.setAttribute('aria-hidden', previousValue);
                            }
                            else {
                                element.removeAttribute('aria-hidden');
                            }
                        }));
                        this._ariaHiddenElements.clear();
                        this._afterAllClosed.next();
                    }
                }
            };
        /**
         * Hides all of the content that isn't an overlay from assistive technology.
         */
        /**
         * Hides all of the content that isn't an overlay from assistive technology.
         * @private
         * @return {?}
         */
        SdsDialogService.prototype._hideNonDialogContentFromAssistiveTechnology = /**
         * Hides all of the content that isn't an overlay from assistive technology.
         * @private
         * @return {?}
         */
            function () {
                /** @type {?} */
                var overlayContainer = this._overlayContainer.getContainerElement();
                // Ensure that the overlay container is attached to the DOM.
                if (overlayContainer.parentElement) {
                    /** @type {?} */
                    var siblings = overlayContainer.parentElement.children;
                    for (var i = siblings.length - 1; i > -1; i--) {
                        /** @type {?} */
                        var sibling = siblings[i];
                        if (sibling !== overlayContainer &&
                            sibling.nodeName !== 'SCRIPT' &&
                            sibling.nodeName !== 'STYLE' &&
                            !sibling.hasAttribute('aria-live')) {
                            this._ariaHiddenElements.set(sibling, sibling.getAttribute('aria-hidden'));
                            sibling.setAttribute('aria-hidden', 'true');
                        }
                    }
                }
            };
        /** Closes all of the dialogs in an array. */
        /**
         * Closes all of the dialogs in an array.
         * @private
         * @param {?} dialogs
         * @return {?}
         */
        SdsDialogService.prototype._closeDialogs = /**
         * Closes all of the dialogs in an array.
         * @private
         * @param {?} dialogs
         * @return {?}
         */
            function (dialogs) {
                /** @type {?} */
                var i = dialogs.length;
                while (i--) {
                    // The `_openDialogs` property isn't updated after close until the rxjs subscription
                    // runs on the next microtask, in addition to modifying the array as we're going
                    // through it. We loop through all of them and call close without assuming that
                    // they'll be removed from the list instantaneously.
                    dialogs[i].close();
                }
            };
        SdsDialogService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        SdsDialogService.ctorParameters = function () {
            return [
                { type: overlay.Overlay },
                { type: core.Injector },
                { type: common.Location, decorators: [{ type: core.Optional }] },
                { type: SdsDialogConfig, decorators: [{ type: core.Optional }, { type: core.Inject, args: [SDS_DIALOG_DEFAULT_OPTIONS,] }] },
                { type: undefined, decorators: [{ type: core.Inject, args: [SDS_DIALOG_SCROLL_STRATEGY,] }] },
                { type: SdsDialogService, decorators: [{ type: core.Optional }, { type: core.SkipSelf }] },
                { type: overlay.OverlayContainer }
            ];
        };
        return SdsDialogService;
    }());
    /**
     * Applies default options to the dialog config.
     * @param {?=} config Config to be modified.
     * @param {?=} defaultOptions Default options provided.
     * @return {?} The new configuration object.
     */
    function _applyConfigDefaults(config, defaultOptions) {
        return __assign({}, defaultOptions, config);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Counter used to generate unique IDs for dialog elements.
     * @type {?}
     */
    var dialogElementUid = 0;
    /**
     * Button that will close the current dialog.
     */
    var SdsDialogCloseDirective = /** @class */ (function () {
        function SdsDialogCloseDirective(dialogRef, _elementRef, _dialog) {
            this.dialogRef = dialogRef;
            this._elementRef = _elementRef;
            this._dialog = _dialog;
        }
        /**
         * @return {?}
         */
        SdsDialogCloseDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                if (!this.dialogRef) {
                    // When this directive is included in a dialog via TemplateRef (rather than being
                    // in a Component), the DialogRef isn't available via injection because embedded
                    // views cannot be given a custom injector. Instead, we look up the DialogRef by
                    // ID. This must occur in `onInit`, as the ID binding for the dialog container won't
                    // be resolved at constructor time.
                    this.dialogRef = ( /** @type {?} */(getClosestDialog(this._elementRef, this._dialog.openDialogs)));
                }
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        SdsDialogCloseDirective.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                /** @type {?} */
                var proxiedChange = changes['_sdsDialogClose'] || changes['_sdsDialogCloseResult'];
                if (proxiedChange) {
                    this.dialogResult = proxiedChange.currentValue;
                }
            };
        SdsDialogCloseDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: "button[sds-dialog-close], button[sdsDialogClose]",
                        exportAs: 'sdsDialogClose',
                        // tslint:disable-next-line: use-host-property-decorator
                        host: {
                            '(click)': 'dialogRef.close(dialogResult)',
                            '[attr.aria-label]': 'ariaLabel || null',
                            'type': 'button',
                        }
                    },] }
        ];
        /** @nocollapse */
        SdsDialogCloseDirective.ctorParameters = function () {
            return [
                { type: SdsDialogRef, decorators: [{ type: core.Optional }] },
                { type: core.ElementRef },
                { type: SdsDialogService }
            ];
        };
        SdsDialogCloseDirective.propDecorators = {
            ariaLabel: [{ type: core.Input, args: ['aria-label',] }],
            dialogResult: [{ type: core.Input, args: ['sds-dialog-close',] }],
            _sdsDialogClose: [{ type: core.Input, args: ['sdsDialogClose',] }]
        };
        return SdsDialogCloseDirective;
    }());
    /**
     * Title of a dialog element. Stays fixed to the top of the dialog when scrolling.
     */
    var SdsDialogTitleDirective = /** @class */ (function () {
        function SdsDialogTitleDirective(_dialogRef, _elementRef, _dialog) {
            this._dialogRef = _dialogRef;
            this._elementRef = _elementRef;
            this._dialog = _dialog;
            this.id = "sds-dialog-title-" + dialogElementUid++;
        }
        /**
         * @return {?}
         */
        SdsDialogTitleDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (!this._dialogRef) {
                    this._dialogRef = ( /** @type {?} */(getClosestDialog(this._elementRef, this._dialog.openDialogs)));
                }
                if (this._dialogRef) {
                    Promise.resolve().then(( /**
                     * @return {?}
                     */function () {
                        /** @type {?} */
                        var container = _this._dialogRef._containerInstance;
                        if (container && !container._ariaLabelledBy) {
                            container._ariaLabelledBy = _this.id;
                        }
                    }));
                }
            };
        SdsDialogTitleDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[sds-dialog-title], [sdsDialogTitle]',
                        exportAs: 'sdsDialogTitle',
                        // tslint:disable-next-line: use-host-property-decorator
                        host: {
                            '[class.sds-dialog-title]': 'true',
                            '[id]': 'id',
                        },
                    },] }
        ];
        /** @nocollapse */
        SdsDialogTitleDirective.ctorParameters = function () {
            return [
                { type: SdsDialogRef, decorators: [{ type: core.Optional }] },
                { type: core.ElementRef },
                { type: SdsDialogService }
            ];
        };
        SdsDialogTitleDirective.propDecorators = {
            id: [{ type: core.Input }]
        };
        return SdsDialogTitleDirective;
    }());
    /**
     * SubTitle of a dialog element
     */
    var SdsDialogSubtitleDirective = /** @class */ (function () {
        function SdsDialogSubtitleDirective() {
        }
        SdsDialogSubtitleDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: "[sds-dialog-subtitle], sds-dialog-subtitle, [sdsDialogSubtitle]",
                        // tslint:disable-next-line: use-host-property-decorator
                        host: { '[class.sds-dialog-subtitle]': 'true' }
                    },] }
        ];
        return SdsDialogSubtitleDirective;
    }());
    /**
     * Scrollable content container of a dialog.
     */
    var SdsDialogContentDirective = /** @class */ (function () {
        function SdsDialogContentDirective() {
        }
        SdsDialogContentDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: "[sds-dialog-content], sds-dialog-content, [sdsDialogContent]",
                        // tslint:disable-next-line: use-host-property-decorator
                        host: { '[class.sds-dialog-content]': 'true' }
                    },] }
        ];
        return SdsDialogContentDirective;
    }());
    /**
     * Container for the bottom action buttons in a dialog.
     * Stays fixed to the bottom when scrolling.
     */
    var SdsDialogActionsDirective = /** @class */ (function () {
        function SdsDialogActionsDirective() {
        }
        SdsDialogActionsDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: "[sds-dialog-actions], sds-dialog-actions, [sdsDialogActions]",
                        // tslint:disable-next-line: use-host-property-decorator
                        host: { '[class.sds-dialog-actions]': 'true' }
                    },] }
        ];
        return SdsDialogActionsDirective;
    }());
    /**
     * Finds the closest SdsDialogRef to an element by looking at the DOM.
     * @param {?} element Element relative to which to look for a dialog.
     * @param {?} openDialogs References to the currently-open dialogs.
     * @return {?}
     */
    function getClosestDialog(element, openDialogs) {
        /** @type {?} */
        var parent = element.nativeElement.parentElement;
        while (parent && !parent.classList.contains('sds-dialog__container')) {
            parent = parent.parentElement;
        }
        return parent ? openDialogs.find(( /**
         * @param {?} dialog
         * @return {?}
         */function (dialog) { return dialog.id === ( /** @type {?} */(parent)).id; })) : null;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SdsDialogModule = /** @class */ (function () {
        function SdsDialogModule() {
        }
        SdsDialogModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, overlay.OverlayModule, portal.PortalModule, angularFontawesome.FontAwesomeModule],
                        exports: [
                            SdsDialogContainerComponent,
                            SdsDialogCloseDirective,
                            SdsDialogTitleDirective,
                            SdsDialogSubtitleDirective,
                            SdsDialogContentDirective,
                            SdsDialogActionsDirective
                        ],
                        declarations: [
                            SdsDialogContainerComponent,
                            SdsDialogCloseDirective,
                            SdsDialogTitleDirective,
                            SdsDialogSubtitleDirective,
                            SdsDialogActionsDirective,
                            SdsDialogContentDirective
                        ],
                        providers: [SdsDialogService, SDS_DIALOG_SCROLL_STRATEGY_PROVIDER],
                        entryComponents: [SdsDialogContainerComponent]
                    },] }
        ];
        return SdsDialogModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ExternalLinkDirective = /** @class */ (function () {
        function ExternalLinkDirective(el, renderer, cfr, vc) {
            this.el = el;
            this.renderer = renderer;
            this.cfr = cfr;
            this.vc = vc;
            this.hideIcon = false;
        }
        Object.defineProperty(ExternalLinkDirective.prototype, "isExternalLink", {
            get: /**
             * @private
             * @return {?}
             */ function () {
                return this.href.replace(/^https?:\/\//, '').replace(/^www\./, '').split('/')[0] != location.hostname;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ExternalLinkDirective.prototype.ngOnChanges = /**
         * @return {?}
         */
            function () {
                if (!this.isExternalLink) {
                    return;
                }
                if (!this.hideIcon) {
                    this.createIcon();
                }
            };
        /**
         * @private
         * @return {?}
         */
        ExternalLinkDirective.prototype.createIcon = /**
         * @private
         * @return {?}
         */
            function () {
                // tslint:disable-next-line:no-unused-expression
                this.vc.constructor.name === "ViewContainerRef_";
                /** @type {?} */
                var factory = this.cfr.resolveComponentFactory(angularFontawesome.FaIconComponent);
                /** @type {?} */
                var component = this.vc.createComponent(factory);
                component.instance.iconProp = ['fas', 'external-link-alt'];
                /** @type {?} */
                var spanElement = document.createElement('span');
                spanElement.classList.add('margin-left-2px');
                /** @type {?} */
                var supElement = document.createElement('sup');
                supElement.appendChild(component.location.nativeElement);
                spanElement.appendChild(supElement);
                this.el.nativeElement.appendChild(spanElement);
                component.instance.ngOnChanges({});
            };
        ExternalLinkDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'a[href]'
                    },] }
        ];
        /** @nocollapse */
        ExternalLinkDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Renderer2 },
                { type: core.ComponentFactoryResolver },
                { type: core.ViewContainerRef }
            ];
        };
        ExternalLinkDirective.propDecorators = {
            href: [{ type: core.Input }],
            hideIcon: [{ type: core.Input }]
        };
        return ExternalLinkDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SdsDirectivesModule = /** @class */ (function () {
        function SdsDirectivesModule() {
        }
        SdsDirectivesModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [ExternalLinkDirective],
                        imports: [
                            common.CommonModule, angularFontawesome.FontAwesomeModule
                        ],
                        entryComponents: [angularFontawesome.FaIconComponent],
                        exports: [ExternalLinkDirective]
                    },] }
        ];
        return SdsDirectivesModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SdsVideoPlayerComponent = /** @class */ (function () {
        function SdsVideoPlayerComponent() {
        }
        /**
         * @return {?}
         */
        SdsVideoPlayerComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                this.config = {
                    videoId: this.VPConfiguration.id,
                    captionsOnDefault: false,
                    seekInterval: this.VPConfiguration.seekInterval,
                    videoTitle: 'Video Player',
                    debug: this.VPConfiguration.debug
                };
                new InitPxVideo(this.config);
            };
        SdsVideoPlayerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'sds-video-player',
                        template: "<div class=\"px-video-container\" id=\"{{VPConfiguration.id}}\" [style.width.px]=\"VPConfiguration.width\" >\n  <div class=\"px-video-img-captions-container\" >\n      <div class=\"px-video-captions hide\" aria-hidden=\"true\"></div>\n      <video width=\"{{VPConfiguration.width}}\" height=\"{{VPConfiguration.height}}\" poster=\"{{VPConfiguration.poster}}\" controls preload={{VPConfiguration.preload}}>\n        <!-- if Safari/Chrome-->\n          <source src=\"{{VPConfiguration.sourceMp4}}\" type=\"video/mp4\" />\n          <!-- If Firefox/Opera/Chrome/IE -->\n          <source src=\"{{VPConfiguration.sourceWebm}}\" type=\"video/webm\" />\n          <track kind=\"subtitles\" kind=\"captions\" label=\"English captions\" src=\"{{VPConfiguration.caption}}\" srclang=\"en\" default />\n      </video>\n  </div>\n  <div class=\"px-video-controls\"></div>\n</div>\n",
                        encapsulation: core.ViewEncapsulation.None,
                        styles: [".pull-left{float:left}.sr-only{position:absolute!important;clip:rect(1px,1px,1px,1px);padding:0!important;border:0!important;height:1px!important;width:1px!important;overflow:hidden}.hide{display:none}.show-inline{display:inline-block}.px-video-img-captions-container *{box-sizing:border-box}.px-video-img-captions-container{position:relative}.px-video-progress{width:100%;height:10px}.px-video-progress[value]{-webkit-appearance:none;border:none}.px-video-progress[value]::-webkit-progress-bar{background-color:#e6e6e6}.px-video-progress[value]::-webkit-progress-value{background-color:#009cdf}.px-video-time{font-family:\"Helvetica Neue\",Helvetica,Arial,sans-serif;float:right;margin-top:2px;font-size:14px}.px-video-captions{position:absolute;top:0;left:0;width:100%;padding:.5em;min-height:2.5em;background-color:#000;color:#fff;font-size:1.1em;text-align:center;opacity:.75}.px-video-controls button{border:1px solid #fff;background:url(../images/px-video-sprite.svg) no-repeat;padding:0;margin:0 5px;width:25px;height:20px;overflow:hidden;cursor:pointer}.px-video-controls button:focus{border:1px dotted #999;outline:0}.px-video-controls button.px-video-restart{background-position:-6px -333px;margin-left:0}.px-video-controls button.px-video-restart:focus,.px-video-controls button.px-video-restart:hover{background-position:-6px -297px}.px-video-controls button.px-video-rewind{background-position:-6px -189px}.px-video-controls button.px-video-rewind:focus,.px-video-controls button.px-video-rewind:hover{background-position:-6px -153px}.px-video-controls button.px-video-play{background-position:-6px -45px}.px-video-controls button.px-video-play:focus,.px-video-controls button.px-video-play:hover{background-position:-6px -9px}.px-video-controls button.px-video-pause{background-position:-6px -117px}.px-video-controls button.px-video-pause:focus,.px-video-controls button.px-video-pause:hover{background-position:-6px -81px}.px-video-controls button.px-video-forward{background-position:-6px -261px}.px-video-controls button.px-video-forward:focus,.px-video-controls button.px-video-forward:hover{background-position:-6px -225px}.px-video-fullscreen-btn-container label{display:inline-block;width:25px;height:20px;margin-left:10px;background:url(../images/px-video-sprite.svg) -6px -907px no-repeat}.px-video-fullscreen-btn-container input[type=checkbox]:hover+label{background-position:-6px -943px;cursor:pointer}.px-video-fullscreen-btn-container input[type=checkbox]:focus+label{outline:#999 dotted 1px;background-position:-6px -943px}.px-video-fullscreen-btn-container input[type=checkbox]:checked+label{background-position:-6px -979px}.px-video-fullscreen-btn-container input[type=checkbox]:checked:hover+label{background-position:-6px -1015px}.px-video-captions-btn-container label{display:inline-block;width:25px;height:20px;margin-left:10px;background:url(../images/px-video-sprite.svg) -6px -835px no-repeat}.px-video-captions-btn-container input[type=checkbox]:hover+label{background-position:-6px -799px;cursor:pointer}.px-video-captions-btn-container input[type=checkbox]:focus+label{outline:#999 dotted 1px;background-position:-6px -799px}.px-video-captions-btn-container input[type=checkbox]:checked+label{background-position:-6px -871px}.px-video-mute-btn-container label{display:inline-block;width:25px;height:20px;margin-left:240px;margin-top:2px;background:url(../images/px-video-sprite.svg) -6px -476px no-repeat}.px-video-mute-btn-container input[type=checkbox]:hover+label{background-position:-6px -440px;cursor:pointer}.px-video-mute-btn-container input[type=checkbox]:focus+label{outline:#999 dotted 1px;background-position:-6px -440px}.px-video-mute-btn-container input[type=checkbox]:checked+label{background-position:-6px -692px}.px-video-mute-btn-container input[type=checkbox]:checked:focus+label,.px-video-mute-btn-container input[type=checkbox]:checked:hover+label{background-position:-6px -656px}.px-video-controls input[type=range]{-webkit-appearance:none;height:6px;width:100px;margin-top:8px;background-color:#e6e6e6;outline:0}.px-video-controls input[type=range]:focus::-webkit-slider-thumb{outline:#999 dotted 1px}.px-video-controls input[type=range]::-moz-range-track{-moz-appearance:none;height:6px;background-color:#e6e6e6;border:none}.px-video-controls input[type=range]::-webkit-slider-thumb{-webkit-appearance:none!important;height:10px;width:6px;background-color:#666}.px-video-controls input[type=range]::-moz-range-thumb{height:12px;width:8px;background-color:#666}@media screen and (-ms-high-contrast:active),(-ms-high-contrast:none){.px-video-controls input[type=range]{position:relative;padding:0;height:8px;top:-3px}.px-video-time{margin-top:4px}.px-video-captions{padding:8px;min-height:36px}}.px-video-container{position:relative}.px-video-container.fullscreen{position:fixed;top:0;bottom:0;left:0;right:0;-webkit-cursor-visibility:auto-hide}.px-video-controls.js-fullscreen-controls{position:absolute;bottom:0;width:100%;z-index:940;background:#fff}.px-video-captions.js-fullscreen-captions{min-height:3.5em;font-size:2.5em;padding:1em}.px-timetip{padding:5px 10px;font-family:\"Helvetica Neue\",Helvetica,Arial,sans-serif;font-size:14px;background:rgba(0,0,0,.83);border-radius:3px;color:#fff;width:auto}.px-timetip:after{top:100%;left:50%;border:10px solid rgba(43,43,43,0);content:\" \";height:0;width:0;position:absolute;pointer-events:none;border-top-color:#2b2b2b;margin-left:-10px}"]
                    }] }
        ];
        /** @nocollapse */
        SdsVideoPlayerComponent.ctorParameters = function () { return []; };
        SdsVideoPlayerComponent.propDecorators = {
            VPConfiguration: [{ type: core.Input }]
        };
        return SdsVideoPlayerComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SdsVideoPlayerModule = /** @class */ (function () {
        function SdsVideoPlayerModule() {
        }
        SdsVideoPlayerModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [SdsVideoPlayerComponent],
                        exports: [SdsVideoPlayerComponent],
                        imports: [
                            common.CommonModule
                        ],
                        providers: []
                    },] }
        ];
        return SdsVideoPlayerModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SdsPopupDirective = /** @class */ (function () {
        function SdsPopupDirective(el, renderer) {
            this.el = el;
            this.renderer = renderer;
            this.renderer.addClass(this.el.nativeElement, 'sds-popup');
            this.sdsPopupDiv = document.createElement('div');
            this.renderer.addClass(this.sdsPopupDiv, 'sds-popup__content');
        }
        /**
         * @return {?}
         */
        SdsPopupDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                this.renderer.appendChild(this.el.nativeElement, this.sdsPopup);
                this.renderer.addClass(this.sdsPopupDiv, this.placement);
                this.renderer.addClass(this.sdsPopupDiv, this.position);
                this.renderer.appendChild(this.sdsPopupDiv, this.el.nativeElement.children[0]);
                this.renderer.appendChild(this.el.nativeElement, this.sdsPopupDiv);
            };
        SdsPopupDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[sdsPopup]',
                        exportAs: 'sdsPopup'
                    },] }
        ];
        /** @nocollapse */
        SdsPopupDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Renderer2 }
            ];
        };
        SdsPopupDirective.propDecorators = {
            sdsPopup: [{ type: core.Input }],
            position: [{ type: core.Input }],
            placement: [{ type: core.Input }]
        };
        return SdsPopupDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SdsPopupModule = /** @class */ (function () {
        function SdsPopupModule() {
        }
        SdsPopupModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [SdsPopupDirective],
                        imports: [
                            common.CommonModule
                        ],
                        exports: [SdsPopupDirective]
                    },] }
        ];
        return SdsPopupModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SdsTextComponent = /** @class */ (function () {
        function SdsTextComponent(cd) {
            this.cd = cd;
            this.items = [];
            this.multiple = true;
            this._onChange = ( /**
             * @param {?} _
             * @return {?}
             */function (_) { });
            this._onTouched = ( /**
             * @return {?}
             */function () { });
        }
        // Helper method to programatically add a value to the existing items array
        // Helper method to programatically add a value to the existing items array
        /**
         * @param {?} val
         * @return {?}
         */
        SdsTextComponent.prototype.addItem =
            // Helper method to programatically add a value to the existing items array
            /**
             * @param {?} val
             * @return {?}
             */
            function (val) {
                if (this.multiple) {
                    this.items = __spread(this.items, [val]);
                    this.updateModel();
                }
            };
        // Method that is fired when the child component event notifies us that the items array has been modified within the child component
        // Method that is fired when the child component event notifies us that the items array has been modified within the child component
        /**
         * @param {?} $event
         * @return {?}
         */
        SdsTextComponent.prototype.updateItems =
            // Method that is fired when the child component event notifies us that the items array has been modified within the child component
            /**
             * @param {?} $event
             * @return {?}
             */
            function ($event) {
                this.updateModel();
            };
        // Helper method that gets a new instance of the model and notifies ControlValueAccessor that we have a new model for this FormControl (our custom component)
        // Helper method that gets a new instance of the model and notifies ControlValueAccessor that we have a new model for this FormControl (our custom component)
        /**
         * @return {?}
         */
        SdsTextComponent.prototype.updateModel =
            // Helper method that gets a new instance of the model and notifies ControlValueAccessor that we have a new model for this FormControl (our custom component)
            /**
             * @return {?}
             */
            function () {
                /** @type {?} */
                var model = this.getModel();
                this._onChange(model);
            };
        // Helper method to return a new instance of an array that contains our items
        // Helper method to return a new instance of an array that contains our items
        /**
         * @return {?}
         */
        SdsTextComponent.prototype.getModel =
            // Helper method to return a new instance of an array that contains our items
            /**
             * @return {?}
             */
            function () {
                return __spread(this.items);
            };
        // ControlValueAccessor (and Formly) is trying to update the value of the FormControl (our custom component) programatically
        // If there is a value we will just overwrite items
        // If there is no value we reset the items array to be empty
        // ControlValueAccessor (and Formly) is trying to update the value of the FormControl (our custom component) programatically
        // If there is a value we will just overwrite items
        // If there is no value we reset the items array to be empty
        /**
         * @param {?} value
         * @return {?}
         */
        SdsTextComponent.prototype.writeValue =
            // ControlValueAccessor (and Formly) is trying to update the value of the FormControl (our custom component) programatically
            // If there is a value we will just overwrite items
            // If there is no value we reset the items array to be empty
            /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value && value.length && this.items !== value) {
                    this.items = value;
                    this.cd.markForCheck();
                }
                else {
                    this.items = [];
                    this.cd.markForCheck();
                }
            };
        // ControlValueAccessor hook that lets us call this._onChange(var) to let the form know our variable has changed (in this case model)
        // ControlValueAccessor hook that lets us call this._onChange(var) to let the form know our variable has changed (in this case model)
        /**
         * @param {?} fn
         * @return {?}
         */
        SdsTextComponent.prototype.registerOnChange =
            // ControlValueAccessor hook that lets us call this._onChange(var) to let the form know our variable has changed (in this case model)
            /**
             * @param {?} fn
             * @return {?}
             */
            function (fn) {
                this._onChange = fn;
            };
        // ControlValueAccessor hook (not used)
        // ControlValueAccessor hook (not used)
        /**
         * @param {?} fn
         * @return {?}
         */
        SdsTextComponent.prototype.registerOnTouched =
            // ControlValueAccessor hook (not used)
            /**
             * @param {?} fn
             * @return {?}
             */
            function (fn) {
                this._onTouched = fn;
            };
        SdsTextComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'sds-text',
                        template: "\n    <div>\n      <input #searchInput class=\"usa-input display-inline-block\" />\n      <button class=\"usa-button margin-left-05 display-inline-block\" (click)=\"addItem(searchInput.value); searchInput.value=''\">Add Item</button>\n    </div>\n\n    <h4>Component Items</h4>\n    <pre>{{ items | json }}</pre>\n\n    <hr />\n\n    <h4>Child Component Items <small>(click to remove)</small></h4>\n    <sds-text-child [(items)]=\"items\" (itemsChange)=\"updateItems($event)\"></sds-text-child>\n  ",
                        providers: [
                            {
                                provide: forms.NG_VALUE_ACCESSOR,
                                useExisting: core.forwardRef(( /**
                                 * @return {?}
                                 */function () { return SdsTextComponent; })),
                                multi: true
                            }
                        ],
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        SdsTextComponent.ctorParameters = function () {
            return [
                { type: core.ChangeDetectorRef }
            ];
        };
        return SdsTextComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SdsTextChildComponent = /** @class */ (function () {
        function SdsTextChildComponent() {
            this.itemsChange = new core.EventEmitter();
        }
        // Method to remove an item from the items array, emits an event that the parent component is listening for
        // Method to remove an item from the items array, emits an event that the parent component is listening for
        /**
         * @param {?} index
         * @return {?}
         */
        SdsTextChildComponent.prototype.removeItem =
            // Method to remove an item from the items array, emits an event that the parent component is listening for
            /**
             * @param {?} index
             * @return {?}
             */
            function (index) {
                this.items.splice(index, 1);
                this.itemsChange.emit(this.items);
            };
        SdsTextChildComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'sds-text-child',
                        template: "\n    <ng-container *ngIf=\"items\">\n      <span class=\"sds-tag sds-tag--chip margin-x-05\" style=\"cursor:pointer;\" *ngFor=\"let item of items; let i=index\" (click)=\"removeItem(i)\">{{item}} <small class=\"margin-left-05\">(x)</small></span>\n    </ng-container>\n  "
                    }] }
        ];
        SdsTextChildComponent.propDecorators = {
            items: [{ type: core.Input }],
            itemsChange: [{ type: core.Output }]
        };
        return SdsTextChildComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SdsTextModule = /** @class */ (function () {
        function SdsTextModule() {
        }
        SdsTextModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, a11y.A11yModule, forms.FormsModule],
                        exports: [SdsTextComponent, SdsTextChildComponent],
                        declarations: [SdsTextComponent, SdsTextChildComponent],
                        providers: []
                    },] }
        ];
        return SdsTextModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    exports.SdsAccordionModule = SdsAccordionModule;
    exports.SdsPageModule = SdsPageModule;
    exports.SdsToolbarModule = SdsToolbarModule;
    exports.SdsHeaderModule = SdsHeaderModule;
    exports.SdsFooterModule = SdsFooterModule;
    exports.PaginationModule = PaginationModule;
    exports.SDSAutocompleteComponent = SDSAutocompleteComponent;
    exports.SdsAutocompleteModule = SdsAutocompleteModule;
    exports.SDSAutocompletelConfiguration = SDSAutocompletelConfiguration;
    exports.SDSHiercarchicalServiceSearchItem = SDSHiercarchicalServiceSearchItem;
    exports.SdsSelectedResultsModule = SdsSelectedResultsModule;
    exports.SDSSelectedItemModel = SDSSelectedItemModel;
    exports.SDSSelectedResultConfiguration = SDSSelectedResultConfiguration;
    exports.SDSSelectedItemModelHelper = SDSSelectedItemModelHelper;
    exports.SelectionMode = SelectionMode;
    exports.SdsSideNavigationModule = SdsSideNavigationModule;
    exports.SdsSearchResultListModule = SdsSearchResultListModule;
    exports.FooterModel = FooterModel;
    exports.FooterLinkSection = FooterLinkSection;
    exports.FooterLink = FooterLink;
    exports.HeaderHome = HeaderHome;
    exports.HeaderNavigationLink = HeaderNavigationLink;
    exports.HeaderSecondaryLink = HeaderSecondaryLink;
    exports.NavigationMode = NavigationMode;
    exports.SideNavigationModel = SideNavigationModel;
    exports.NavigationLink = NavigationLink;
    exports.SdsMenuModule = SdsMenuModule;
    exports.SdsSearchModule = SdsSearchModule;
    exports.SdsObserversModule = SdsObserversModule;
    exports.SdsTruncateModule = SdsTruncateModule;
    exports.SdsTabOutsideModule = SdsTabOutsideModule;
    exports.SDSClickOutsideModule = SDSClickOutsideModule;
    exports.SDS_DIALOG_SCROLL_STRATEGY_FACTORY = SDS_DIALOG_SCROLL_STRATEGY_FACTORY;
    exports.SDS_DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY = SDS_DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY;
    exports.SDS_DIALOG_DATA = SDS_DIALOG_DATA;
    exports.SDS_DIALOG_DEFAULT_OPTIONS = SDS_DIALOG_DEFAULT_OPTIONS;
    exports.SDS_DIALOG_SCROLL_STRATEGY = SDS_DIALOG_SCROLL_STRATEGY;
    exports.SDS_DIALOG_SCROLL_STRATEGY_PROVIDER = SDS_DIALOG_SCROLL_STRATEGY_PROVIDER;
    exports.SdsDialogService = SdsDialogService;
    exports.SdsDialogRef = SdsDialogRef;
    exports.SdsDialogModule = SdsDialogModule;
    exports.SdsDirectivesModule = SdsDirectivesModule;
    exports.SdsVideoPlayerModule = SdsVideoPlayerModule;
    exports.SdsPopupModule = SdsPopupModule;
    exports.SdsCollapseModule = SdsCollapseModule;
    exports.SdsTextComponent = SdsTextComponent;
    exports.SdsTextModule = SdsTextModule;
    exports.SearchSettings = SearchSettings;
    exports.SdsSearchComponent = SdsSearchComponent;
    exports.f = sdsExpansionAnimations;
    exports.c = SDS_ACCORDION;
    exports.g = SdsAccordionItemContentDirective;
    exports.d = SdsAccordionItemHeaderComponent;
    exports.e = SdsAccordionItemComponent;
    exports.a = SdsAccordionDirective;
    exports.w = SDSAutocompleteSearchComponent;
    exports.t = SdsAutocompleteSearchModule;
    exports.u = SDSClickOutsideDirective;
    exports.p = CollapseDirective;
    exports.bn = sdsDialogAnimations;
    exports.bl = SdsDialogConfig;
    exports.bm = SdsDialogContainerComponent;
    exports.bs = SdsDialogActionsDirective;
    exports.bo = SdsDialogCloseDirective;
    exports.br = SdsDialogContentDirective;
    exports.bq = SdsDialogSubtitleDirective;
    exports.bp = SdsDialogTitleDirective;
    exports.bt = ExternalLinkDirective;
    exports.q = SdsFooterComponent;
    exports.n = SdsHeaderComponent;
    exports.bc = sdsMenuAnimations;
    exports.be = SdsMenuHeaderComponent;
    exports.bd = SdsMenuItemComponent;
    exports.bf = SdsMenuTriggerForDirective;
    exports.z = SDS_MENU_TOKEN;
    exports.bb = SdsMenuComponent;
    exports.bg = SdsObserveWidthDirective;
    exports.h = SdsPageComponent;
    exports.i = SdsPageOptionsComponent;
    exports.r = PaginationComponent;
    exports.bv = SdsPopupDirective;
    exports.y = SdsSearchResultListComponent;
    exports.s = SDSSelectedResultComponent;
    exports.x = SdsSideNavigationComponent;
    exports.v = SDSTabOutsideDirective;
    exports.bw = SdsTextChildComponent;
    exports.k = sdsToolbarAnimations;
    exports.l = SdsToolbarExpandDirective;
    exports.m = SdsToolbarHeaderComponent;
    exports.j = SdsToolbarComponent;
    exports.o = SdsTopBannerComponent;
    exports.bj = sdsTruncateTextAnimations;
    exports.bi = SdsTruncatedTextContainerComponent;
    exports.bh = SdsTruncateTextByLineDirective;
    exports.bk = SDS_TRUNCATED_TEXT_DATA;
    exports.bu = SdsVideoPlayerComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=gsa-sam-components.umd.js.map